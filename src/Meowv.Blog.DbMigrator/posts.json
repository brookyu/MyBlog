[
  {
    "title": "计算机基础知识",
    "author": "阿星Plus",
    "url": "2015-11-20-computer-knowledge",
    "markdown": "# 计算机基础知识\n\n二进制数的运算方法，电子计算机具有强大的运算能力，它可以进行两种运算：算术运算和逻辑运算。\n\n## 二进制数的算术运算\n\n二进制数的算术运算包括：加、减、乘、除四则运算，下面分别予以介绍。\n\n### （1）二进制数的加法\n\n根据“逢二进一”规则，二进制数加法的法则为：\n\n```\n0＋0＝0\n0＋1＝1＋0＝1\n1＋1＝0　（进位为1）\n1＋1＋1＝1 （进位为1）\n```\n\n### （2）二进制数的减法\n\n根据“借一有二”的规则，二进制数减法的法则为：\n\n```\n0－0＝0\n1－1＝0\n1－0＝1\n0－1＝1 （借位为1）\n```\n\n### （3）二进制数的乘法\n\n二进制数乘法过程可仿照十进制数乘法进行。但由于二进制数只有0或1两种可能的乘数位，导致二进制乘法更为简单。二进制数乘法的法则为：\n\n```\n0×0＝0\n0×1＝1×0＝0\n1×1＝1\n```\n\n由低位到高位，用乘数的每一位去乘被乘数，若乘数的某一位为1，则该次部分积为被乘数；若乘数的某一位为0，则该次部分积为0。某次部分积的最低位必须和本位乘数对齐，所有部分积相加的结果则为相乘得到的乘积。\n\n### （4）二进制数的除法\n\n二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。\n\n## 二进制数的逻辑运算\n\n二进制数的逻辑运算包括逻辑加法（“或”运算）、逻辑乘法（“与”运算）、逻辑否定（“非”运算）和逻辑“异或”运算。\n\n### （1）逻辑“或”运算\n\n又称为逻辑加，可用符号“＋”或“∨”来表示。逻辑“或”运算的规则如下：\n\n```\n0＋0＝0或0∨0＝0\n0＋1＝1或0∨1＝1\n1＋0＝1或1∨0＝1\n1＋1＝1或1∨1＝1\n```\n\n可见，两个相“或”的逻辑变量中，只要有一个为1，“或”运算的结果就为1。仅当两个变量都为0时，或运算的结果才为0。计算时，要特别注意和算术运算的加法加以区别。\n\n### （2）逻辑“与”运算\n\n又称为逻辑乘，常用符号“×”或“· ”或“∧”表示。“与”运算遵循如下运算规则：\n\n```\n0×1＝0或0·1＝0或0∧1＝0\n1×0＝0或1·0＝0或1∧0＝0\n1×1＝1或1·1＝1或1∧1＝1\n```\n\n可见，两个相“与”的逻辑变量中，只要有一个为0，“与”运算的结果就为0。仅当两个变量都为1时，“与”运算的结果才为1。\n\n### （3）逻辑“非”运算\n\n又称为逻辑否定，实际上就是将原逻辑变量的状态求反，其运算规则如下：\n\n可见，在变量的上方加一横线表示“非”。逻辑变量为0时，“非”运算的结果为1。逻辑变量为1时，“非”运算的结果为0。\n\n### （4）逻辑“异或”运算\n\n“异或”运算，常用符号“”或“”来表示，其运算规则为：\n\n```\n00＝0 或 00＝0\n01＝1 或 01＝1\n10＝1 或 10＝1\n11＝0 或 11＝0\n```\n\n可见：两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为0。取值相异时，“异或”的结果为1\n\n以上仅就逻辑变量只有一位的情况得到了逻辑“与”、“或”、“非”、“异或”运算的运算规则。当逻辑变量为多位时，可在两个逻辑变量对应位之间按上述规则进行运算。特别注意，所有的逻辑运算都是按位进行的，位与位之间没有任何联系，即不存在算术运算过程中的进位或借位关系。下面举例说明。\n\n- 【例】 如两变量的取值 X＝00FFH，Y＝5555H，求Z1＝X∧Y；Z2＝X∨Y；Z3＝；Z4＝XY的值。\n\n```\n解：\nX＝0000000011111111\nY＝0101010101010101\n则：\nZ1＝0000000001010101＝0055H\nZ2＝0101010111111111＝55FFH\nZ3＝1111111100000000＝FF00H\nZ4＝0101010110101010＝55AAH\n```\n\n## 数在计算机中的表示\n\n在计算机中要处理的数有无符号数和有符号数。这些数在计算机中是如何表示的呢？\n\n- 1．无符号数\n\n所谓无符号数，通常表示一个数的绝对值，即数的各位都用来表示数值的大小。一个字节（8位）二进制数只能表示0～255范围内的数。因此，要表示大于255的数，必须采用多个字节来表示，它的长度可以为任意倍字节长，其数据格式如图1.1所示。\n\n\n- 2．有符号数\n\n所谓有符号数，即用来表示一个任意位长的正数或负数。我们知道，在普通数字中，区分正负数是在数的绝对值前面加上符号来表示，即“＋”表示正数，“－”表示负数。在计算机中数的符号也数码化了，即用一位二进制数位来表示符号。一般是，用一个数的最高位来表示符号位，用“0”表示正号，用“1”表示负号，而其余位为数值位。其数据格式如图1.2所示。\n\n\n- 3．有符号数的原码、反码、补码及补码运算\n\n带正、负号的二进制数称为数的真值表示。\n\n```\n例如：X＝＋1010110\n　　　Y＝－0110101\n```\n\n为了运算方便，在计算机里的有符号数，有三种表示方法，即原码、反码和补码，称为机器数。\n\n### 原码\n\n正数的符号位用“0”表示，负数的符号位用“1”表示，其余数字位表示数值本身，这种表示法称为原码。\n\n例如：上例中\n\n```\n[X]原＝01010110\n[Y]原＝10110101\n```\n\n对于0，可以认为它是＋0，也可以认为它是－0。因此在原码中，0有下列两种表示\n\n```\n[＋0]原＝00000000\n[－0]原＝10000000\n```\n\n原码表示数的方法很简单，只需要在真值的基础上，将符号位用数码“0”和“1”表示即可。但采用原码表示的数在计算机中进行加减运算时很麻烦。如：遇到两个异号数相加，或两个同号数相减时，就要用减法运算。为了把减法运算转变成加法运算，则引入了反码和补码。\n\n### 反码\n\n在原码表示的基础上很容易求得一个数的反码。正数的反码与原码相同，而负数的反码则是在原码的基础上，符号位不变（仍为1），其余数位按位求反，即0→1，1→0。\n\n例如：上例中\n\n```\n[X]反＝01010110\n[Y]反＝11001010\n而：[＋0]反＝00000000\n　　[－0]反＝11111111\n```\n\n### 补码\n\n一个数的补码也很容易求得。如果是正数，补码同原码也同反码，如果是负数，则在反码的基础上最末位加1。\n\n例如：上例中\n\n```\n[X]补＝01010110＝[X]反＝[X]原 \n[Y]补＝11001011\n注：补码中0只有一种表示，无正负之分，即：\n[＋0]补＝[－0]补＝00000000\n不难证明，补码具有如下特性：\n[[X]补]补＝[X]原\n```\n\n用8位二进制数来表示无符号数及有符号数的原码、反码、补码时的对应关系见表1.5。\n\n由表1.5可知，用8位二进制数，表示无符号数为0～255；表示原码为－127～＋127；表示反码为－127～＋127；表示补码为－128～＋127。\n\n### 补码运算\n\n两个用补码表示的带符号数进行加减运算时，特点是把符号位上表示正负的“1”和“0”也看成数，与数值部分一同进行运算，所得的结果也为补码形式，即结果的符号位为“0”，表示正数，结果的符号位为“1”表示负数。下面分加、减两种情况予以讨论。\n两个带符号的数X和Y进行相加时，是将两个数分别转换为补码的形式，然后进行补码加运算，所得的结果为和的补码形式。即：\n\n```\n[X＋Y]补＝[X]补＋[Y]补\n```\n\n- 【例】 用补码进行下列运算 (＋18)＋(－15)；(－18)＋(＋15)；(－18)＋(－11)\n\n解：...\n\n由例1.2可知：当带符号的数采用补码形式进行相加时，可把符号位也当作普通数字一样与数值部分一起进行加法运算，若符号位上产生进位时，则自动丢掉，所得的结果为两数之和的补码形式。如果想得到运算后原码的结果，可对运算结果再求一次补码即可。\n\n### 两个带符号数相减，可通过下面的公式进行\n\n```\nX－Y＝X＋（－Y）\n则　[X－Y]补＝[X＋(－Y)]补＝[X]补＋[－Y]补\n```\n\n可见：求[X－Y]补，可以用[X]补和[－Y]补相加来实现。这里关键在于求[－Y]补。如果已知[Y]补，那么对[Y]补的每一位（包括符号位）都按位求反，然后再在末位加1，结果即为[－Y]补。（证明从略）。一般称[－Y]补为对[Y]补的“变补”，即[[Y]补]变补＝[－Y]补；已知[Y]补求[－Y]补的过程叫变补。\n这样一来，求两个带符号的二进制数之差，可以用“减数（补码）变补与被减数（补码）相加”来实现。这是补码表示法的主要优点之一。\n\n- 【例】 用补码进行下列运算：① 96－19； ② (－56)－(－17)\n\n```\n解：① X＝96，Y＝19 则[X]补＝01100000\n[Y]补＝00010011\n[－Y]补＝11101101故 [X－Y]补＝[X－Y]原＝01001101＝＋77\n```\n\n```\n② X＝－56，Y＝－17， 则\n[X]补＝11001000\n[Y]补＝11101111\n[－Y]补＝00010001\n则 [X－Y]补＝11011001\n故 [X－Y]原 ＝[[X－Y]补]补＝10100111＝－39\n综上所述，对于补码的加、减运算可用下边一般公式表示：\n[X±Y]补＝[X]补＋[±Y]补 （都小于2n+1）\n```\n\n### 溢出判断\n\n当两个有符号数进行补码运算时，若运算结果的绝对值超出运算装置容量时，数值部分就会发生溢出，占据符号位的位置，导致错误的结果。这种现象通常称为补码溢出，简称溢出。这和正常运算时符号位的进位自动丢失在性质上是不同的。下面举例说明。例如：某运算装置共有五位，除最高位表示符号位外，还有四位用来表示数值。先看下面两组运算。\n\n① 计算13＋7＝？\n\n② 计算(－4)＋(－4)＝？\n\n- ① 的运算结果显然是错误的，因为两个正数相加不可能得到负数的结果，产生错误的原因是由于两个数相加后的数值超出了加法装置所允许位数（数值部分4位，可以表示的最大数值为24＝16），因而从数值的最高位向符号位产生了进位，或说这种现象是由于“溢出”而造成的。\n- ② 的结果显然是正确的，由符号位产生的进位自动丢失。\n\n为了保证运算结果的正确性，计算机必须能够判别出是正常进位还是发生了溢出错误。\n微机中常用的溢出判别称为双高位判别法，并常用“异或”电路来实现溢出判别。\n\n## 数的编码方法\n\n在计算机里，所有用到的数字、字母、符号、指令等都必须用特定的二进制码来表示，这就是二进制编码。\n\n### 二进制编码的十进制数\n\n- 计算机只能识别二进制数，但是，人们却熟悉十进制数。所以，在计算机输入和输出数据时，往往采用十进制数表示。不过，这样的十进制数是用二进制编码表示的，称为二进制编码的十进制数——BCD（binary code decimal）码。\n- 用二进制数为十进制数编码，每一位十进制数需要由四位二进制数来表示。四位二进制数共有16种编码形式，由于十进制数只有0～9十个数码，故有六个码是多余的，放弃不用。而这种多余性便产生了多种不同的BCD码。在计算机中较常用的是8421 BCD码（在以后的章节中简称BCD码）。这种BCD码用四位二进制数表示一位十进制数的数码0～9，而这四位的权从高位到低位依次为8，4，2，1。十进制数0～15与8421 BCD码的编码关系见表1.6。\n\n```\n例如：(208)10＝(0010 0000 1000)8421 BCD\n　　　(1001 0001 0111 0101)8421 BCD＝(9175)10\n```\n\n### 字母与符号的编码\n\n- 在计算机里，字母和符号也必须用特定的二进制编码来表示。目前，在微机、通信设备和仪器仪表中广泛采用的是美国标准信息交换码ASCII（american standard code for information interchange）码。它用七位二进制码表示一个字母或符号，共能表示27＝128个不同的字符。其中包括数字0～9、英文26个大、小写字母、运算符、标点及其他的一些控制符号。常用的七位ASCII码见表1.7。\n\n例如：数字0的ASCII码为0110000B 或 30H\n　　　数字9的ASCII码为0111001B 或 39H\n　　　字母A的ASCII码为1000001B　或 41H\n\n- ASCII码多用于微型计算机的输入/输出设备（如电传打字机）及在数据传送过程中进行奇偶校验。\n",
    "category": "Other",
    "tag": [
      "计算机基础",
      "进制转换"
    ],
    "createdAt": "2015-11-20 17:24:20"
  },
  {
    "title": "实习“满月”工作感受",
    "author": "阿星Plus",
    "url": "2016-05-18-internship-month-summary",
    "markdown": "今天是2016年5月18日，时间过得真快，自上个月18号到今天来公司刚好一个月。这一个月的学习生活，让我学到了很多，不管是技术上还是生活阅历上都得到了很大的提升。\n\n在公司，和大家相处的都很融洽，大家一起吃饭，一起加班，一起讨论技术。在团队中，有高学历，有低学历，但是大家并不会因为学历的原因而疏远。刚进公司什么都不懂，慢慢的适应了现有的环境，每天上班下班加班，乐此不疲。\n\n祝经理，人很随性，对上班工作没有具体的硬性要求，弹性工作，正是我想要的。刚到公司的第一个星期，感觉很轻松，每天到点下班，有很多空余的时间，随着时间的推移，慢慢的有任务了，变得忙起来，每天要加班完成任务。正是这样，才让我得到了提升。从前端到后端再到测试，全接触。\n\n在我来“路博特”面试的时候，我已经收到其他公司的offer，之所以选择“路博特”，我主要从公司环境和公司氛围以及面试官来判定的。我当初既然选择了这里，我就会一如既往的在这里继续学习下去。我对公司的第一印象还是不错的，那么在这里不仅可以得到技能上的提升，还能收获身心的愉悦。\n\n说说这一个月在公司做的事情吧，其实也没什么，每天的工作日报都已经写得很详细了。第一，主要参与了一个教育局登记系统的项目，完成了几个JS的特效，充当了几次测试，熟悉了一下后天逻辑，完成了几个小的功能点。第二，一个公司自主二次开发的工作流平台，这个主要熟悉了一下流程，不做详解，接下来的重点既是这个。第三，学会若干技术点，比如iis安装部署等若干问题，文件的共享、访问，代码调试技巧等等。还有就是，一些非技术性技能，应该叫软技能吧！待人处事啊，处理工作中的问题啊，填写报销单啊之类的。\n\n最后就总结一下自己的不足和接下来的计划吧。工作上，有些许不足，不完美的地方。比如，在测试教育局登记系统的时候没有充分测试，有时候为了图速度，准确率不高。测试就是一个心细的活，像我这样可能会适得其反。还有比如JS效果的实现，在我本地是实现了，那么在服务器上了？在不同的浏览器上面呢？没有做好相应的兼容性，都是我的问题所在。\n\n接下来，我首先会完成公司安排下发的任务，在完成任务的同时，考虑更多的后果，不同的情况，做好相应的测试，确保万无一失。在自己完成任务的同时，学会帮助他人。因为帮助他人就是提升自己。还有就是按照自己的学习计划每天学习，不断进步。有不懂先自己研究，研究不出来问问同事。\n\n希望接下来的日子，能够共同成长进步！\n",
    "category": "Summary",
    "tag": [
      "工作总结",
      "实习",
      "总结"
    ],
    "createdAt": "2016-05-18 14:27:18"
  },
  {
    "title": "2016年终总结",
    "author": "阿星Plus",
    "url": "2017-01-04-2016-summary",
    "markdown": "### 一、工作总结\n\n2016年对我来说意义非凡，结束掉学生生涯正式步入职场，进入“路博特”，开始我的编码生活。这一年不仅学到了更多的专业知识同时也长了不少见识。从入职到现在已有八个多月的时间，在公司担任.Net研发一职。\n\n总的来说2016年实现了个人的预期目标，以下是2016年预期目标一览。\n\n1.2016年4月18日入职“武汉路博特工程科技有限公司”\n\n2.2016年6月熟练掌握三层架构开发网站\n\n3.2016年9月 .NET MVC 学习并入门\n\n4.2016年10月25日结束驾考生涯，驾驶证到手\n\n5.2016年11月可利用Entity Framework开发简单网站\n\n6.2016年12月对前端有了新的认识可开发自适应PC和手机屏幕的网页\n\n下面重点总结在公司开发过的网站以及参与过的项目。刚进公司主要是熟悉环境，了解行情，快速进行学习，适应公司的发展需要。最开始参与了一个教育局报名管理系统，负责了其部分JS特效及一些后台功能的实现。然后客串测试直至项目顺利上线。在这个小小的项目中，体会到了团队协同、效率、编码能力、测试等的至关重要。\n\n由于个人前端能力突出，紧接着便被安排编写设计院网站，在完成前端所有页面之后协同开发后台在短短不到一周的时间完成该项目。但是遗留下的问题却有很多，因为经验不足导致Bug众多。深深体会到维护一个项目远远比开发一个项目要难得多。从这个项目过渡，接下来的时间开发了至科网站、集团网站、路博特网站、至科检测人员资格查询系统前台、优仕德项目网站、江汉区交警大队网站、麦都教育网站等等公司一系列有关前台的页面。并且主导了域名的注册、备案、上线以及后期的维护工作。\n\n以上便是我2016入职以来的工作总结。\n\n### 二、自我评价\n\n#### 优点：\n\n1.环境适应能力强，能够很快适应新的工作环境\n\n2.具备团队合作意识，善于协调团队分工合作\n\n3.能够虚心接受他人的意见与建议，对符合的予以采纳\n\n4.各方面的知识都有涉猎，学习能力较快，接受新事物能力强\n\n5.能够在最短时间内完成Leader下发的任务，并自由合理分配时间\n\n6.在编程开发过程中，对项目有自己的见解以及问题解决方案\n\n#### 缺点：\n\n1.后半年积极度不高，比较懒散\n\n2.涉猎知识较多，但是都不精通\n\n3.个人能力和团队能力有限，不能更加完美的解决现有项目问题\n\n4.情绪化比较严重，不能合理控制自己的心情\n\n#### 对自己的要求：\n\n1.合理控制自己的时间\n\n2.在现有项目的基础上，完善不足之处\n\n3.学而知不足，专一研究DotNet技术，由此进行发散学习\n\n### 三、建议意见\n\n1.员工归属感需增强，实行奖惩制度，提高福利待遇\n\n2.希望公司可以大幅度提供住宿，家较远的员工可以给予公交补贴\n\n3.技术方面，向框架式开发渐进，框架开发速度快，效率高。急需一套属于公司内部的网站开发框架。\n",
    "category": "Summary",
    "tag": [
      "年终总结",
      "总结",
      "2016"
    ],
    "createdAt": "2017-01-04 01:59:04"
  },
  {
    "title": "我的实习记录",
    "author": "阿星Plus",
    "url": "2017-05-31-internship-summary",
    "markdown": "#### 2017年7月\n\n1、签订劳动合同，转正，实习期结束\n\n2、React-Native 学习研究\n\n#### 2017年6月19日星期一 — 2017年6月23日星期五\n\n1、重装系统/开发环境\n\n2、动态表单设计开发完成\n\n3、请假两天回武汉领毕业证、办理党员组织关系手续\n\n4、表单Bootstrap美化\n\n#### 2017年6月5日星期三 — 2017年6月9日星期五\n\n1、AC项目上线前的数据增量整理导出导入，Bug修改，业务功能刚改等\n\n2、动态报名表单实现 可创建表单，将创建的表单解析成html，根据创建的表单进行报名登记数据\n\n3、因公司内部原因，居家办公一周，6月15日恢复公司上班\n\n#### 2017年5月31日星期三 — 2017年6月2日星五\n\n1、动态表单研究\n\n2、微信编辑器修改出版\n\n3、AC项目需求更改，写业务代码\n\n#### 2017年5月22日星期一 — 2017年5月27日星期六\n\n1、仿活动行表单自定义设计器-简版\n\n2、AC项目遗漏问题解决\n\n3、服务器折腾、Hexo+Github折腾\n\n#### 2017年5月15日星期四 — 2017年5月19日星期五\n\n1、AC bug修复、需求更改 上线\n\n2、微信编辑器研究，demo\n\n3、自我学习\n\n#### 2017年4月29日星期六 — 2017年5月3日星期三休假\n\n#### 2017年5月4日星期四 — 2017年5月12日星期五\n\nAC汽车项目需求变更，第二版改版\n\n#### 2017年4月24日星期一 — 2017年4月28日星期五\n\n1、AC汽车项目bug修改\n\n2、WordPress数据导出、XML处理、导入数据至sqlserver\n\n3、AC汽车项目第一版完成，需求更改，确定需求，五一放假之后具体实施\n\n4、微信商城相关项目被打回，bug很多，功能没完成、重做重改\n\n#### 2017年4月17日星期一 — 2017年4月23日星期天\n\n1、AC汽车项目开发，我主要负责前台，由另一名同事负责后台\n\n2、终端连锁、EMBA、门店托管、产业研究院、论坛活动、盈利商家、咨询、调研、专栏、作者……\n\n3、19,20,21号晚上加班至9点+、22,23号周末全天加班完成全部开发工作\n\n4、终端连锁：按公司名称搜索、按公司首字母筛选搜索、首次加载10条信息，点击加载更多、详情内容页面\n\n5、门店托管：首次加载5条信息，点击加载更多、是否接手判断、详情内容页面\n\n6、论坛活动：首次加载5条信息，点击加载更多、内容详情页面、依据开始时间结束时间判断活动状态\\(已开始、已结束、还剩多少天开始\\)\n\n7、盈利商家：首次加载12条信息，点击加载更多、内容详情页面、合作状态、按类型分类搜索\n\n8、商家入驻、我要联系、我要报名、我要接手、我要合作、发布项目的表单提交\n\n9、调研，专栏，作者：依据现有项目进行二次修改，分类显示不同的页面，调研话题的显示、作者列表、属于作者的文章列表……\n\n9、banner轮播图，上一页，下一页、新浪腾讯微博分享、微信二维码、返回顶部、全站伪静态……\n\n10、耗时的功能点：json数据时间格式转换问题、时间的计算问题\\(临界值\\)、表单验证提示\\(SMValidator\\)、分类搜索功能\n\n#### 2017年4月5日星期三 — 2017年4月7日星期五请假回校答辩\n\n#### 2017年4月10日星期一 — 2017年4月14日星期五\n\n1、微信商城购买页调整，可在后台设置是否允许开发票，如果订单只含有不可开发票商品，\"我要发票\"不显示，增加前后收货地址、Email、后台收货地址修改功能，增加显示开发票的金额，购买前必须注册，如果商品为虚拟物品，详情页给出提示：\"本商品为虚拟商品，一经售出，概不退换。\"\n\n2、AC汽车项目需求更改，数据库创建，开发准备工作\n\n3、[当然我在瞎扯](http://api.xj8c.cc/articles)API接口开发\n\n#### 2017年3月27日星期一 — 2017年4月1日星期六\n\n1、微信商城虚拟物品交付邮件查收打开监控\n\n2、微信商城虚拟物品交付下载地址点击监控\n\n3、程序处理两张图片叠加在一起\n\n4、资讯站采埃孚ZF技术专栏信息展示\n\n5、新闻发布关键发布和定时发布为空验证检查\n\n6、AC汽车项目产品开发会议，需求讲解\n\n7、AC汽车项目开发计划表，4-5天，一个工作日完成\n\n8、AC汽车项目数据库 Table Schema、document created\n\n9、微信商城发送邮件切换至商用系统\\(Webpower\\)\n\n10、Web Service 使用学习、接口调用\n\n#### 2017年3月22日星期三 — 2017年3月24日星期五\n\n1、入职培训\n\n2、DotNetFrame框架搭建\n\n3、自己学习\n\n4、入职培训考试 - 92\n\n#### 2017年3月21日星期二\n\n1、文章关键词报表查询及导出\n\n2、GasgooNewsAuto 资讯站遗漏专题页\n\n#### 2017年3月20日星期一\n\n1、电脑中毒，系统重装\n\n2、微信商城项目首页样式更改，热门商品全部显示\n\n#### 2017年3月17日星期五\n\n1、资讯站发布新闻分类默认选中功能\n\n2、微信商城维护加载优化\n\n#### 2017年3月16日星期四\n\n自我学习看框架源码\n\n#### 2017年3月15日星期三\n\n1、索喜专题企业聚焦图片轮播\n\n2、文档转换\\(word，txt\\)为PDF\n\n#### 2017年3月14日星期二\n\n1、UEditor编辑器图片等比例缩放定制功能 √\n\n2、UEditor编辑器插入视频在线预览\n\n#### 2017年3月13日星期一\n\n1、ASP.NET MVC\n\n2、UEditor编辑器图片等比例缩放功能\n\n3、UEditor编辑器上传视频多终端显示\n\n#### 2017年3月10日星期五\n\n1、PC版快速专题 上下翻页状态修复 √\n\n2、商城项目图片处理、优化 √\n\n3、每周例会，项目汇报/ReactJS技术分享 √\n\n#### 2017年3月9日星期四\n\n1、PC版快速专题链接增加 √\n\n2、商城项目图片处理\n\n#### 2017年3月8日星期三\n\n1、PC版快速专题 √\n\n2、li多列图片上下页功能 jQuery分页插件jPages\n\n#### 2017年3月7日星期二\n\n1、资讯运营报表 √\n\n2、Vue.js\n\n3、PC版专题页\n\n#### 2017年3月6日星期一\n\n1、资讯站头尾部链接添加\n\n2、报表查询及导出\n\n#### 2017年3月3日星期五\n\n1、二维码的显示与隐藏\n\n2、本地加入图片随机展示\n\n3、会议项目汇报，微信小程序技术分享，每周例会主题技术分享\n\n4、Ueditor 上传图片等比例缩放\n\n#### 2017年3月2日星期四\n\n1、WEB API访问数据库，json接口 √\n\n2、.NET WEB API跨域方法配置 √\n\n3、ajax跨域解析，随机展示图片 √\n\n#### 2017年3月1日星期三\n\n1、原生js实现随机显示图片\n\n2、WEB API\n\n#### 2017年2月28日星期二\n\n1、提交实现发送邮件功能\n\n2、高峰论坛移动端专题 签入到SVN\n\n3、jQuery与javascript代码互转示例\n\n#### 2017年2月27日星期一\n\n1、正式入职上海盖世网络技术有限公司\n\n2、开发环境配置\n\n3、页面查看更多/收起功能\n\n#### 2017年2月10日星期五\n\n提辞职申请，项目整理，第一家实习公司生涯结束\n\n#### 2017年2月9日星期四\n\n原生js+css3实现下拉刷新效果\n\n#### 2017年2月8日星期三 - 请病假1天\n\n#### 2017年2月7日星期二\n\n自我学习，聚餐，简历更新，着手离职\n\n#### 2017年2月6日星期一\n\n1、开年第一天上班，例会\n\n2、电脑出问题，重装系统，配置开发环境\n\n3、同事离职，项目交接整理\n\n#### 2017年1月22日星期日\n\n最后一天上班，我要回家过年了\n\n#### 2017年1月21日星期六\n\n江汉区交通大队网站年前最终版本发布\n\n#### 2017年1月20日星期五\n\n前往总公司吃年饭领红包\n\n#### 2017年1月19日星期四\n\n江汉区交通大队网站页面修改、IE提示\n\n#### 2017年1月18日星期三\n\n江汉区交通大队网站线上测试、改Bug，外出部署项目\n\n#### 2017年1月17日星期二\n\n江汉区交通大队网站开发完成，数据填充，线上发布\n\n#### 2017年1月16日星期一\n\n江汉区交通大队网站用户签收通知、整合项目\n\n#### 2017年1月13日星期五\n\n江汉区交通大队网站后台每日值班、签收用户增删改查登录功能完成\n\n#### 2017年1月12日星期四\n\n江汉区交通大队网站后台三层框架、后台登录、签收弹窗、每日值班模块完成\n\n#### 2017年1月11日星期三\n\n江汉区交通大队第二版网站党建、新闻、政务、大队长信箱模块完成\n\n#### 2017年1月10日星期二\n\n1、麦都网站bug修改\n\n2、江汉区交通大队第二版网站首页完成\n\n#### 2017年1月9日星期一\n\n1、麦都网站bug修改\n\n2、网站维护\n\n#### 2017年1月6日星期五\n\n1、麦都网站前后台全部完成、发布线上测试\n\n2、至科cktit.com域名接入备案\n\n#### 2017年1月5日星期四\n\n1、麦都网站后台课程介绍模块全部完成\n\n2、URL重写实现前台伪静态化\n\n#### 2017年1月4日星期三\n\n1、麦都网站后台多层项目搭建，后台整体框架、登录模块、课程介绍\n\n2、购买域名cktit.com相关\n\n3、[2016年年终总结](http://www.jianshu.com/p/e709942f145c)\n\n4、至科人员检测资格查询系统后台二维码信息修改\n\n#### 2017年1月3日星期二\n\n麦都网站前端页面\\(自适应PC及手机\\)全部完成\n\n#### 2016年12月30日星期五\n\n麦都网站课程介绍、师资力量、考试资讯完成\n\n#### 2016年12月29日星期四\n\n麦都网站前台首页、关于我们完成\n\n#### 2016年12月28日星期三\n\n麦都网站前台首页 头部导航、轮播图、简介、讲师、课程介绍栏目\n\n#### 2016年12月27日星期二\n\n1、响应式导航\n\n2、麦都网站前台响应式布局解决方案\n\n3、Bootstrap栅格化布局\n\n#### 2016年12月26日星期一\n\n1、Sass CSS预处理器\n\n2、Linq...\n\n#### 2016年12月23日星期五\n\n1、Linq To SQL\n\n2、NoSql、MongoDB数据库基础\n\n#### 2016年12月22日星期四\n\n1、Google Code Prettify 代码高亮使用\n\n2、ASP.NET MVC5官方教程\\(中文版\\).pdf\\(看完\\)\n\n3、深入理解Bootstrap\n\n#### 2016年12月21日星期三\n\n1、ASP.NET MVC5\\(7层架构\\) 注册、登录、注销、修改密码功能实现\n\n2、Entity Framework6 Code First 相关\n\n#### 2016年12月20日星期二\n\nMVC5 && EF6\n\n#### 2016年12月19日星期一\n\n1、试验室信息管理系统修改意见、PPT\n\n2、ASP.NET MVC 实例学习\n\n#### 2016年12月16日星期五\n\n1、至科人员检测资格查询系统添加返回和打印按钮\n\n2、ASP.NET Razor语法\n\n#### 2016年12月15日星期四\n\n1、江汉区交警大队网站前台全部完成\n\n#### 2016年12月14日星期三\n\n1、江汉区交警大队网站旧版后台代码修改\n\n2、江汉区交警大队网站新版前台代码政务、服务、关于三个页面完成\n\n#### 2016年12月13日星期二\n\n江汉区交警大队网站前台代码首页和新闻页面完成\n\n#### 2016年12月12日星期一\n\n1、PDF《CSS揭秘》研读\n\n2、江汉区交警大队网站前台代码\n\n#### 2016年12月9日星期五\n\n1、Asp.Net 缓存、本地化和全球化、监控和诊断、单元测试、测试驱动开发TDD、配置与部署\n\n2、将博CMS\n\n3、HTTPS网站加密\n\n4、CSS三栏布局\n\n#### 2016年12月8日星期四\n\n1、江汉区交警大队网站功能修改\n\n2、[瞎JB扯](https://xj8c.cc)文章详情页面接入百度分享并支持https、自动获取文章内容添加到关键字及描述\n\n#### 2016年12月7日星期三\n\n1、前往武汉江汉区交警大队出差,项目部署,需求,改版方案...\n\n#### 2016年12月6日星期二\n\n1、江汉区交警大队网站每日值班功能完成\n\n2、留言功能实现\n\n3、首页漂浮窗\n\n#### 2016年12月5日星期一\n\n1、[至科](http://zktit.com/)网站导航修改兼容IE9+\n\n2、Entity Framework模式、ASP.NET MVC Ajax/分页/认证与授权\n\n#### 2016年12月2日星期五\n\n1、网站在线打包成App平台\n\n2、C\\#的匿名函数\n\n3、江汉区交警大队网站内容以及页面修改\n\n4、网站漂浮窗实现\n\n#### 2016年12月1日星期四\n\n1、C\\#的Attribute\n\n2、C\\#的预处理指令\n\n3、C\\#的反射机制\n\n4、C\\#的正则表达式\n\n#### 2016年11月30日星期三\n\n1、C\\#文件读写操作 IO\n\n2、C\\#委托 Delegate\n\n3、C\\#异常处理 ExceptionHandle\n\n4、C\\#事件处理机制 Event\n\n5、C\\#索引器 Indexer\n\n6、C\\#泛型 Generic\n\n7、ASP.NET MVC Introduce\n\n#### 2016年11月29日星期二\n\n1、Asp.Net MVC学习\n\n2、[武汉至科检测技术有限公司网站](http://zktit.com/)、[武汉东方建设集团建筑设计院网站](http://www.dfjssj.com/)、武汉至科检测技术有限公司论坛 3个网站功能清单整理\n\n#### 2016年11月28日星期一\n\n1、[喵呜网](http://meowv.com) 站点搬家\n\n1. 备份MySQL数据库\n2. 打包整个站点代码文件,通过FTP工具将其下载至本地\n3. 修改配置文件\n4. 上传至新服务器,导入MySQL数据库\n5. 解析IP地址,刷新本地DNS缓存\n6. 访问成功,搬家完成\n\n2、中电云集-云主机助手 工具\n\n3、Bootstrap Application\n\n4、CSS绝对底部方案\n\n#### 2016年11月25日星期五\n\n1、npm包管理工具\n\n2、Markdown语法\n\n#### 2016年11月24日星期四\n\n1、图片裁剪生成不同尺寸\n\n2、全屏背景轮播循环案例\n\n3、检测资格查询系统信息上传\n\n#### 2016年11月23日星期三\n\n1、SAE Sina\n\n2、C\\# ConsoleApplication 2048\n\n#### 2016年11月22日星期二\n\n1、HTML5\n\n2、至科网站导入报告、页面改写维护\n\n3、借助Flash完成图片批量上传\n\n#### 2016年11月21日星期一\n\n1、Github项目整理、静态资源上传\n\n2、Bolg更新\n\n3、前端插件学习以及整理\n\n#### 2016年11月18日星期五\n\n1、Layui 文档学习、Demo练习\n\n2、至科网站报告添加跟踪维护、技术指导\n\n3、本地在线学习/网校搭建\n\n#### 2016年11月17日星期四\n\n1、json序列化、反序列化\n\n2、在线搭建网校的方案\n\n3、JSHelper运用\n\n#### 2016年11月16日星期三\n\n1、Git命令学习\n\n2、网站Rewrite防盗链配置文件\n\n3、至科网站报告查询更新至线上\n\n4、本地网校平台搭建解决方案\n\n#### 2016年11月15日星期二\n\n1、自制html源码查看工具\n\n2、VUE.JS、Jquery文字提示插件\n\n3、Git命令学习\n\n4、看书jQuery开发从入门到精通\n\n#### 2016年11月14日星期一\n\n1、集团网站logo修改\n\n2、优仕德网站footer修改\n\n3、自适应全屏banner Demo\n\n#### 2016年11月11日星期五\n\n1、在线学习平台搭建解决方案\n\n2、武汉东方建设集团网站维护修改\n\n#### 2016年11月10日星期四\n\n1、Excel数据导入SQLServer完成\n\n2、报告查询码提取器小工具\n\n#### 2016年11月9日星期三\n\n1、HTML5 Canvas\n\n2、Excel数据导入SQLServer\n\n3、上传报告页面代码编写\n\n#### 2016年11月8日星期二\n\n1、Lims框架\n\n2、至科报告添加\n\n3、HTML5 localStorage 本地存储与读取\n\n4、有关二级域名的知识学习以及全站https加密处理等\n\n#### 2016年11月7日星期一\n\n1、七牛云存储SDK\n\n2、C\\#上传图片至七牛云\n\n#### 2016年11月4日星期五\n\n1、登陆页面重写、优化\n\n2、框架搭建\n\n#### 2016年11月3日星期四\n\n1、url重写研究,页面伪静态技术\n\n2、Vue.js学习\n\n#### 2016年11月2日星期三\n\n1、 Liger UI API\n\n2、代码发布，上传上线\n\n3、JS算法案例学习\n\n4、C\\#后台代码优化功能点实现\n\n#### 2016年11月1日星期二\n\n1、 Liger UI API\n\n2、NextEasy .net快速开发平台\n\n3、一般处理程序\n\n#### 2016年10月31日星期一\n\n1、 Liger UI框架搭建修改\n\n2、 Asp.net URL重写\n\n3、一般处理程序+html+ajax\n\n#### 2016年10月28日星期五\n\n1、jQuery Liger UI框架\n\n2、Bootstrap\n\n3、Webqic快速开发平台\n\n#### 2016年10月27日星期四\n\n1、jQuery学习、案例代码编写\n\n2、RoadFlow框架修改\n\n3、jQuery Liger UI API、Demo学习\n\n4、jQuery Liger UI框架搭建\n\n#### 2016年10月26日星期三\n\n1、权限管理框架申请及其查看\n\n2、Sina SAE\n\n3、.Net多图上传案例\n\n4、源码学习\n\n#### 2016年10月25日星期二—科目四考试\\(结束驾考生涯，驾驶证到手\\)\n\n#### 2016年10月24日星期一\n\n1、搭建在线慕课平台框架选择和方案的整理\n\n2、权限管理框架\n\n3、FineUI 通用权限管理框架（AppBoxPro）\n\n4、FuneUI ASP.NET 控件库 Demo\n\n#### 2016年10月21日星期五\n\n1、优仕德交互效果修改\n\n2、整合代码，转移至新服务器\n\n3、H+后台UI框架\n\n#### 2016年10月20日星期四\n\n1、后台UI\n\n2、Sina SAE\n\n3、优仕德项目\n\n4、jquery实例运用\n\n5、前端知识点总结\n\n#### 2016年10月19日星期三\n\n1、360等国产浏览器兼容性\n\n2、优仕德项目导航显示效果js修改、页面修改、搜索框百度搜索js\n\n3、githup学习\n\n#### 2016年10月18日星期二\n\n1、至科检测接入加密UKID登录\n\n2、Bug修改\n\n#### 2016年10月17日星期一\n\n1、至科检测工作流登录页面3种方案\n\n2、优仕德Bug修改\n\n#### 2016年10月14日星期五\n\n1、文件断点续传技术\n\n2、至科人员检测Bug修改、页面重写、兼容主流浏览器\n\n3、优仕德教育项目Bug修改、页面调整维护\n\n4、Hexo+GitHub学习研究\n\n5、IE不支持placeholder属性的解决方案研究\n\n6、Validator、jquery全选/反选 Demo\n\n#### 2016年10月13日星期四—考试科目三\n\n#### 2016年10月12日星期三\n\n1、优仕德项目招考信息列表详情页\n\n2、优仕德项目分页PageHelper\n\n#### 2016年10月11日星期二\n\n1、Html、css编码规范html页面编写\n\n2、Webservice\n\n3、Html全屏背景自适应效果demo\n\n4、优仕德项目后台详情页面\n\n#### 2016年10月10日星期一\n\n1、培训机构HTML代码 全部完成\n\n2、项目发布\n\n#### 2016年10月9日星期日\n\n培训机构HTML代码完成90%\n\n#### 2016年10月8日星期六\n\n1、发布至科监测类项目简报网站至服务器\n\n2、至科报告协助上传、维护\n\n3、培训机构HTML代码\n\n#### 2016年9月30日星期五\n\n1、微信公众号处理\n\n2、地图标注\n\n3、网页结构分析、代码编写\n\n#### 2016年9月29日星期四\n\n1、百度地图标注接入数据库、本地查询案例\n\n2、微信公众号\n\n3、至科网站维护小Bug修改\n\n#### 2016年9月28日星期三\n\n1、百度地图自定义标注研究\n\n2、结合数据库动态添加标注案例\n\n3、动态解析数组学习\n\n#### 2016年9月27日星期二\n\n1、地图标注研究以及案例\n\n2、至科报告查询代添加\n\n#### 2016年9月26日星期一\n\n1、至科微信公众号菜单添加\n\n2、后台UI框架\n\n#### 2016年9月23日星期五\n\n1、ASPOSE.WORD 操作Word Demo\n\n2、PHP基础语法学习\n\n3、微信公众号开发学习\n\n4、文档，文件，项目整理\n\n#### 2016年9月22日星期四\n\n1、WeX5 App 打包\n\n2、Oracle 基础学习\n\n3、.Net 奇淫巧技\n\n#### 2016年9月21日星期三\n\n1、WeX5 Baas.Net环境部署完成\n\n2、Base.Net后端开发学习\n\n3、研究微信公众号开发\n\n4、 微擎平台搭建学习\n\n#### 2016年9月20日星期二\n\n1、WeX5 hybrid APP开发学习\n\n2、WeX5 Baas.Net环境部署，需要VS2015最新版本\n\n3、本地应用打包学习、观看WeX5 在线学习文档\n\n4、2048 APP案例\n\n#### 2016年9月19日星期一\n\n1、WebAPP学习\n\n2、移动端框架jquery.mobil\n\n3、网站维护\n\n4、WebAPP 火车票查询案例\n\n#### 2016年9月18日星期日\n\n1、上线集团网站\n\n2、至科网站维护\n\n#### 2016年9月5日—2016年9月14日请假练车考试科目二\n\n#### 2016年9月2日星期五\n\n1、源码整理归档，数据库备份\n\n2、Asp.Net Mvc学习\n\n#### 2016年9月1日星期四\n\n1、Asp.Net MVC 学习\n\n2、电子宣传册在线制作\n\n#### 2016年8月31日星期三\n\n1、电子宣传册\n\n2、集团网站Bug修改、维护\n\n3、Entity Framework学习、EF三层搭建，增删改查案例\n\n#### 2016年8月30日星期二\n\n1、WebApp方案\n\n2、WeX5开源移动开发框架\n\n3、Entity Framework了解学习\n\n#### 2016年8月29日星期一\n\n1、电子宣传册\n\n2、网站维护\n\n3、ASP.NET MVC学习\n\n#### 2016年8月26日星期五\n\n1、Hadoop核心架构研究抄录\n\n2、C\\#语法糖\\(自动属性、隐式类型、匿名类型、Lambad表达式…\\)\n\n3、C\\#，T4模板学习\n\n#### 2016年8月25日星期四\n\n1、集团网站维护、时间修改\n\n2、至科网站维护、文字修改\n\n3、电子宣传册\n\n#### 2016年8月24日星期三\n\n1、检测单位上岗人员检测资格查询系统完善\n\n2、Node.js\n\n3、集团网站新闻时间修改、维护\n\n#### 2016年8月23日星期二\n\n1、继续集团网站备案\n\n2、QR-Code二维码生成\n\n3、至科检测资格信息管理系统\n\n4、工作室网站美化调整\n\n#### 2016年8月22日星期一\n\n1、至科网站导航检测报告真伪查询修改\n\n2、检测人员资格查询后台界面修改调整\n\n3、短信验证提交容联审核通过，根据审核通过模板Id修改短信验证，现都可查询\n\n4、添加无验证查询页面用于二维码扫描查询\n\n5、集团网站接入阿里云备案\n\n#### 2016年8月19日星期五\n\n1、集团网站、设计院网站、至科网站维护\n\n2、至科检测人员资格信息管理系统\n\n3、.Net Ajax应用与学习\n\n#### 2016年8月18日星期四\n\n1、设计院网站Bug修改，信息替换，导航调整，招聘英才列表显示调整\n\n2、至科网站Bug修改，热点检测项目滚动特效，图片修改，添加试验室信息管理系统链接，查询系统下报告查询添加验证码限制查询功能\n\n3、至科检测人员资格信息管理系统页面修改，增加图片验证码限制功能\n\n#### 2016年8月17日星期三\n\n1、至科人员资格查询系统上线\n\n2、至科、设计院、路博特网站更新需求、Bug修改\n\n3、至科、设计院网站后台增加上传新闻图片功能\n\n4、极验验证码\n\n#### 2016年8月16日星期二\n\n1、至科检测资格信息查询系统本地发布进行后台测试\n\n2、检测资格查询系统Bug修改\n\n3、H5 & CSS3 实战书看完\n\n#### 2016年8月15日星期一\n\n1、至科检测资格信息查询系统静态页面完成\n\n2、表单验证js完成\n\n3、后台用户查询登录三层代码完成\n\n4、登录页面保存用户信息至数据库完成\n\n5、手机验证码发送并校验完成\n\n6、点击弹窗显示和关闭\n\n7、修改路博特页面文字错误\n\n8、美化至科检测资格信息查询系统后台\n\n9、至科检测资格信息查询系统前后台完成，可接入容联短信平台进入测试阶段\n\n#### 2016年8月12日星期五\n\n1、学习node.js\n\n2、至科、集团、路博特网站代码修改整理\n\n3、转达任务至团队人员，转发邮件\n\n4、上传代码，上线网站\n\n5、至科资格检测信息管理系统对接\n\n#### 2016年8月8日—2016年8月11日请假回家休息\n\n#### 第十六周总结\n\n本周完成工作\n\n1.集团网站Bug修改\n\n2.路博特网站框架、数据库搭建\n\n3.三层代码以及解决方案模块\n\n4.容联短信验证接口代码实现、文档说明\n\n5.各个版本代码整理、备份管理...\n\n本周工作总结\n\n本周主要完成了集团网站的Bug修改，经过测试之手，网站存在很多Bug，都是在开发过程中疏忽的。软件测试这个环节在软件行业中是至关重要的，很多人认为软件开发中贡献最大的人是开发人员，这个观点不能否认，但是软件测试人员也扮演着非常重要的角色。经此次开发过程遇到的一些问题，学到了不少经验。在填充数据的时候遇到一个SQL错误，.Net SqlClient Data Provider，经过查阅资料，分析原因，最后得以解决并且进行记录\\(SQL错误：.Net SqlClient Data Provider\\)...\n\n下周工作计划\n\n下周请假，回家好好休息，上班后好好工作。\n\n#### 2016年8月5日星期五\n\n1.集团网站后台公益事业、活动剪辑详情页面\n\n2.容联短信验证接口代码实现、文档说明\n\n3.事业单位等培训机构网站\n\n4.路博特网站交接、后台页面图标logo、链接更换\n\n5.集团网站Bug修改完毕\n\n6.至科、集团网站源码发送\n\n#### 2016年8月4日星期四\n\n1.容联短信接口文档学习\n\n2.Demo,暂时只可以实现接收收短信，未进行验证。\n\n2.集团网站Bug修改\n\n#### 2016年8月3日星期三\n\n1.集团网站Bug修改\n\n2.Lbt网站3层代码完成\n\n3.后台解决方案模块完成\n\n#### 2016年8月2日星期二\n\n1、集团网站Bug修改\n\n2、Lbt网站简介模块完成\n\n3、各种琐事…\n\n#### 2016年8月1日星期一\n\n1、集团网站完成\n\n2、上传Lims管理系统\n\n3、Lucene.Net+盘古分词学习\n\n4、Lbt数据库\n\n5、Model代码\n\n#### 第十五周总结\n\n本周完成工作\n\n1.集团网站后台功能已全部实现\n\n2.前台数据绑定完成90%左右\n\n本周工作总结\n\n集团网站从前台到后台，收获颇多。\n\n本周开始着手写集团网站后台代码，因为是自己写的前台页面，所以对整个页面的架构是一目了然的。\n\n首先根据前台页面创建了网站数据库。让后利用代码生成器生成网站Model层代码，对于代码生成的好处就是可以减轻工作量，因为网站涉及到30来个数据表，如果是手写Model层代码会耗费大量的时间。\n\n根据生成的Model层代码手写Dal与Bll层增删改查的代码。这个耗费了我大量的时间。可以说在三成架构中，网站的Dal层其实就是网站的灵魂，所有的增删改查分页查询等等都离不开Dal层。\n\n分页用的存储过程，存储过程的好处有很多，运行速度快，可以接收参数、输出参数、返回单个值或者多个结果集以及返回值。这样网站相对来说会比较稳定。\n\n然后在后台开发中，用到了多图上传，因为之前没有做过，便在网上学习了一下多图上传的案例，总的来说我有两种解决方案，一种是多图上传的插件，这个比较强大，学习了一下弄懂了其原理，另外一种便是循环上传图片，因为多图上传还是需要一张一张的上传，这个比较简单，由于时间和效率的原因，我采用了循环上传。\n\n最后一个便是缩略图生成，这个在网上找的现成的生成缩略图的一个方法，看了一下代码，可以高按照度或者宽度的比例来生成对应的缩略图，而且也不会对图片造成变形。直接调用，在前台资质资格、集团荣誉、领导关怀三个模块用上了。\n\n一个工作日的时间，完成了集团网站后台所用逻辑代码，以及前台90%的数据绑定。\n\n下周工作计划\n\n1.网站数据添加完毕\n\n2.交由测试人员进行测试\n\n3.配合测试人员进行Bug修改\n\n4.完善手头上的工作，休假一星期\n\n#### 2016年7月29日星期五\n\n1.工程业绩模块\n\n① 竣工工程 - 增删改查、分页列表、分类查询、前台数据绑定\n\n② 在建工程 - 增删改查、分页列表、分类查询、前台数据绑定\n\n③ 设计工程 - 增删改查、分页列表、前台数据绑定\n\n2.企业文化模块\n\n① 公益事业 - 增删改查、多图上传、前台数据绑定、轮播显示\n\n② 活动剪辑 - 增删改查、多图上传、前台数据绑定、轮播显示\n\n3.联系我们 - 全部完成\n\n4.友情链接 - 全部完成\n\n5.后台首页 - 文字更换、logo修改、页面修改美化优化\n\n6.后台修改密码功能完成\n\n7.后台整体页面搭建完成\n\n8.前台数据绑定完成\n\n#### 2016年7月28日星期四\n\n1.集团网站工程业绩模块\n\n① 竣工工程后台增删改查，图片上传，列表显示，分类查询\n\n② 在建工程后台增删改查，图片上传，列表显示，分类查询\n\n③ 设计工程后台增删改查，图片上传，列表显示\n\n2.集团网站企业文化模块\n\n① 公益事业后台增删改查，多图上传并显示\n\n② 活动剪辑页面添加完成\n\n#### 2016年7月27日星期三\n\n1.集团网站联系我们模块\n\n① 在线留言完成\n\n② 联系方式\\(站点信息\\)完成\n\n2.友情链接前台数据绑定\n\n3.学习多图上传，实时预览代码\n\n#### 2016年7月26日星期二\n\n1.友情链接模块增删改查\n\n2.企业文化模块\n\n① 企业理念Update\n\n② 党团建设增删改查\n\n3.人力资源模块\n\n① 简历投递上传下载\n\n② 学习平台增删改查\n\n4.联系我们页面搭建完毕\n\n#### 2016年7月25日星期一\n\n一、集团网站\n\n1.新闻中心模块\n\n添加、后台列表展示、删除、分页查询、分类型查询完成\n\n2.科技创新模块\n\n① 技术中心、科研领域修改功能完成\n\n② 科技成果添加、后台展示、删除、分页查询、分类型查询完成\n\n3.人力资源模块\n\n① 人才战略修改功能完成\n\n② 人才聚集添加、后台带缩略图展示、删除、分页查询完成\n\n③ 人才招聘添加、后台展示、删除、分页查询完成\n\n二、至科网站\n\n1.整理上线所缺数据文档\n\n2.修改至科网站Logo及导航菜单颜色\n\n三、路博特网站\n\n1.路博特主机域名绑定\n\n2.上线路博特静态页面网站\n\n#### 第十四周总结\n\n本周完成工作\n\n1.至科网站上线工作\\(代码整理、数据填充...\\)完成\n\n2.路博特网站所有HTML静态页面完成\n\n3.路博特网站后台数据库搭建完成\n\n4.路博特网站后台3层框架代码搭建完成\n\n5.[路博特](http://www.lubok.cn) 网站域名备案成功\n\n6.集团网站所有HTML静态页面完成\n\n7.集团网站项目计划流程图\n\n8.集团网站后台数据库搭建完成\n\n9.集团网站后台登录模块、关于集团模块完成\n\n本周工作总结\n\n本周在三个网站之间来回切换，至科网站上线工作完成，只差备案成功，上传代码，算是告一段落。\n\n公司内部网站改版，独立完成了PC版及手机自适应版静态页面路博特网站，一并完成后台数据库的搭建及网站3层框架的搭建。\n\n主要时间还是花在集团网站上，集团网站页面众多，虽说有部分重复页面，但是也还是达到了36个页面。花费了我很多时间来完成，美工多次外出办公回来传达需求，修修改改终于在周四完成了所有页面，然后马不停蹄创建数据库，搭建后台框架进行项目计划安排分析。现已经完成登录模块、关于集团模块的后台代码。\n\n下周工作计划\n\n1.全身心投入到集团网站后台开发当中去，按计划表进行开发，在周末之前完成所有后台逻辑代码\n\n2.配合完成至科网站上线及备案工作...\n\n#### 2016年7月22日星期五\n\n集团网站后台\n\n1、Model层所有代码完成\n\n2、登录模块完成\n\n关于集团模块\n\n1、集团简介、董事长致辞、组织结构三大模块Update完成\n\n2、资格资质、集团荣誉、领导关怀，标题，多图上传，列表展示，存储过程分页查询完成\n\n新闻中心模块—新闻中心模块界面搭建完成，数据访问层\\(Dal\\)代码完成\n\n#### 2016年7月21日星期四\n\n1、Lbt网站数据库搭建完毕\n\n2、Lbt网站三层框架搭建\n\n3、集团网站项目计划图\n\n4、集团网站数据库搭建完毕\n\n5、集团网站三层框架搭建\n\n6、集团网站后台页面框架搭建\n\n#### 2016年7月20日星期三\n\n1、集团网站静态页面全部完成\n\n① 领导关怀页面完成\n\n② 技术中心页面完成\n\n③ 活动剪辑详情页完成\n\n④ 公益事业、公益事业详情页完成\n\n⑤ 科研领域完成\n\n⑥ 简历投递完成\n\n⑦ 学习平台、学习平台详情页完成\n\n2、集团网站后台数据库搭建\n\n#### 2016年7月19日星期二\n\n1、集团网站修改添加页面\n\n① 工法标准改为工法，增加技术规章类型\n\n② 水利建设工程改为园林绿化\n\n③ 工程业绩模块增加设计工程页面\n\n④ 工地整理工程改为土地整理工程\n\n⑤ 后台数据库搭建\n\n2、[路博特](http://www.lubok.cn) 网站域名备案成功，新增[设计院](http://dfjssj.com) 网站打印核验单初审通过，待邮寄核验单。\n\n#### 2016年7月18日星期一\n\n1、至科网站上线数据填充\n\n2、集团网站页面添加和修改\n\n3、分配至科网站数据填充任务给ZouXueXia\n\n4、jquery插件学习及使用\n\n#### 第十三周总结\n\n本周有事请假了一天，首先这一周完成了路博特静态网站，PC版和手机版自适应页面\n\n路博特网站备案告一段落，静等管局审核完成\n\n着手至科网站上线任务，修改了至科网站的一些bug和新增了一些功能\\(登录UKID验证\\)\n\n集团为网站因需求而进行修改压面，添加页面\n\n计划下周将至科网站上线全部完成，开始集团网站前后台和路博特网站后台代码编写\n\n#### 2016年7月15日星期五\n\n请假一天...\n\n#### 2016年7月14日星期四\n\n1、完善路博特网站页面\n\n2、路博特数据库搭建\n\n3、至科网站：新闻中心-至科空间模块完成\n\n4、至科网站：服务项目模块修订整改\n\n5、后台测试数据删除，数据库测试数据清空\n\n6、整合至科网站源码、部署版代码，随时可以上线\n\n7、集团网站：人力资源-添加人才聚集模块、首页-banner图更换...\n\n#### 2016年7月13日星期三\n\n1、路博特网站静态页面全部完成\n\n2、至科网站页面信息修改\n\n3、至科后台登录加入UKID数据验证\n\n4、最新版至科网站发布与上传\n\n#### 2016年7月12日星期二\n\n路博特网站\n\n首页、走进路博特、解决方案、解决方案详情页、新闻资讯、加入我们、联系我们-页面完成\n\n新闻资讯详情页，无样式模板\n\n产品与解决方案公用一个页面。暂时没有多余的项目，建议导航目前只放一个解决方案，产品保留，需要的时候可以加上。\n\n#### 2016年7月11日星期一\n\n1、提交备案信息\\(管局审核中\\)，等待审核结果\n\n2、学习Node.js\n\n3、整理有关OA、CRM、ERP...解决方案的展示文字\n\n4、整理路博特网站相关资料\n\n#### 第十二周总结\n\n这周完成了公司集团网站的所有静态页面，这是我在公司做的第三个项目了。感觉好累，现在有点力不从心，没有刚开始的激情了。\n\n大夏天，好友同学们都回家避暑去了，然而我已经很早就没有暑假可言了。\n\n马上出来实习就三个月了，好想回家，从过年到现在都没有回过家，想回去看看。\n\n#### 2016年7月8日星期五\n\n1、教育局Js代码加密\n\n2、Node.js学习\n\n3、集团网站导航修改\n\n#### 2016年7月7日星期四\n\n1、打印网站备案核验单\n\n2、修改集团网站静态页面\n\n① 工程业绩模块：竣工工程、在建工程修改为图文展示样式\n\n② 工程业绩详情页\n\n3、网站所有信息及联系方式修改\n\n4、数据库：\\(用户、新闻中心、新闻类型、工程业绩、业绩类型、联系我们-在线留言、联系我们-联系方式）表创建\n\n#### 2016年7月6日星期三\n\n湖北武汉，暴雨，休息一天\n\n#### 2016年7月5日星期二\n\n1、集团网站静态页面全部完成\n\n2、放弃之前路博特域名，进行新网站备案\n\n3、网站备案，核减单待打印上传\n\n4、集团网站需修改部分信息\n\n#### 2016年7月4日星期一\n\n1、集团网站 - html页面\n\n① 新闻中心模块完成\n\n② 科技创新模块完成\n\n③ 人力资源模块完成\n\n④ 企业文化模块完成\n\n⑤ 联系我们模块完成\n\n2、集团网站页面美化\n\n#### 第十一周总结\n\n本月工作内容\n\n1、设计院网站\n\n2、至科网站\n\n3、集团网站\n\n4、路博特网站\n\n5、有关域名备案等相关工作\n\n本月工作总结\n\n1、设计院网站两个版本的前台页面\n\n2、分工合作，完成设计院数据库设计，后台代码编写\n\n3、至科网站前台页面\n\n4、至科网站后台代码编写\n\n5、经测试修改两个网站存在的Bug，达到可以上线的版本\n\n6、正在进行集团网站前台页面的代码编写\n\n7、域名备案等工作\n\n8、工作需求中的自我学习\\(Asp.Net存储过程、JS各种动画效果、H5+CSS3全新前端代码、寻找论坛BBS源码、Asp.Net富文本框使用案例\\)\n\n下月工作计划\n\n1、集团网站前端页面\n\n2、集团网站后台代码\n\n3、路博特网站前端页面\n\n4、路博特网站后台代码\n\n5、工作中的其它任务\n\n6、自我学习\n\n4月份来公司，至今也已两个多月了。\n\n马上就是3个月了，学到了很多，也领悟了很多。\n\n7月份想要请假休息几天回家一趟，感觉有点疲惫。\n\n#### 2016年7月1日星期五\n\n1、集团网站首页全部完成\n\n2、关于集团模块\\(集团简介、董事长致辞、组织结构、资质资格、集团荣誉、领导关怀页面\\)完成\n\n3、工程业绩页面\\(竣工工程模块\\)\n\n4、提交工信部域名注销备案申请\n\n#### 2016年6月30日星期四\n\n1、集团网站首页\n\n2、域名注册证书\n\n#### 2016年6月29日星期三\n\n1、跟进花生壳域名过户，填写过户原因\n\n2、修改至科网站导航样式、联系我们页面\n\n3、JS速度动画、透明度动画、缓冲动画、多物体动画、链式动画、同事运动案例，万能运动框架编写\n\n4、集团网站首页代码编写\n\n#### 2016年6月28日星期二\n\n1、联系花生壳办理域名过户...\n\n2、查看，对比后，提供企业邮箱的两种方案\n\n3、寻找Asp.Net版BBS源码\n\n#### 2016年6月27日星期一\n\n1、修改设计院和至科两个网站的bug\n\n2、JS划入划出特效学习\n\n#### 第十周总结\n\n本周完成工作\n\n1、两个网站的bug修改\n\n2、至科网站的后台编码，前台数据绑定，功能模块全部完成\n\n3、提交了设计院网站的最终版本\n\n4、报告查询模块查询报告\n\n5、整合了至科网站最终版本含源码版和部署版\n\n本周达到了预期结果：\n\n1、设计院的网站告一段落，全部完成\n\n2、至科网站前后台全部完成，经测试修改整合也已完成改版\n\n正在进行中的事情：\n\n1、路博特网站\n\n2、[集团网站](http://www.whdfjs.com/)\n\n下周工作计划\n\n1、编写集团网站静态页面\n\n2、后台管理系统\n\n3、路博特网站\n\n#### 2016年6月24日星期五\n\n1、安排今日任务\n\n① ChenXia：集团网站设计、以第一版为主\n\n② ZouXueXia：设计院网站和至科网站总体测试\n\n③ PengYun：路博特网站前台/后台\\(从后台开始\\)\n\n④ MySelf：集团网站前台页面HTML代码，跟进设计，提出建议，修改方案\n\n2、分享完整的富文本框编辑器Demo\n\n3、整理总结文件上传与下载的功能知识点\n\n4、整合至科网站最终版本含源码版和部署版\n\n5、Web前端css工作流，代码技巧，语法糖学习\n\n6、集团网站首页头部logo、右侧搜索、导航栏\n\n#### 2016年6月23日星期四\n\n1、修改至科测试所提交的Bug\n\n2、发布最新版本提供测试人员进行反测\n\n3、反测bug修改，测试完成，发布服务器，至科网站到达一个节点\n\n4、修复文件下载模块，文件下载无法打开问题。\n\n#### 2016年6月22日星期三\n\n1、协助网站备案，邮寄核验单\n\n2、整合设计院网站最终版本含源码版和部署版\n\n3、修改至科网站测试所存在的bug\n\n4、更改至科网站所有时间统一为年月日形式\n\n5、报告查询中修改报告信息时显示所有信息\n\n6、报告查询添加日志管理模块，协同完成\n\n#### 2016年6月21日星期二\n\n1、报告查询之增加查询码功能模块\n\n① 增加查询码字段，修改3层数据\n\n② 完成带有查询码功能的增删改查\n\n③ 依据报告编号使用不可逆算法MD5加密截取其中5位字符串保存至数据库\n\n④ 前台报告查询功能初步实现\n\n2、至科网站整体调试修改，总体功能需求全部实现\n\n3、部署至科网站提交给测试人员进行测试\n\n4、设计院网站域名备案信息等若干问题\n\n#### 2016年6月20日星期一\n\n1、申诉路博特域名账号密码相关信息，找出问题所在\n\n2、联系花生壳官方客服，找到修改账号密码解决办法\n\n3、至科网站任务规划\n\n4、至科网站后台报告查询模块增删改查\n\n5、至科网站前后报告查询模块查询功能\n\n① 依据报告编号精确查询\n\n② 为空提示\n\n③ 不存在给出提示\n\n④ 正确显示查询信息\n\n⑤ 依据后台填写报告内容，填多少信息，查出来就是多少信息\n\n6、接收路博特设计网页设计方案，分析效果，实现难度，不合理之处...\n\n7、至科后台部分修改\n\n① 友情链接模块修改\n\n② 所有页面防止不登录直接访问\n\n#### 第九周总结\n\n写总结，坚持的也有两个月了，收货颇多。\n\n这周同学聚餐了，喝的酩酊大醉，还记得大一那会，懵懵懂懂，一转眼大学都已经快要结束了。\n\n这周写了美工设计的所有psd页面，写完前端继续协助做后端。改了测试给的上个网站的bug。希望在下周完结手头上的所有事。因为报考了驾校一直没时间去练车，准备在忙完手上的项目请假一个星期回学校去练车，一直拖下去也不是办法。\n\n今天父亲节，突然想家了，半年多了还没回去过，等待下一个小长假，我想回家看看。\n\n...不想写了，烦！\n\n#### 2016年6月17日星期五\n\n1、至科网站页面修改，添加新功能\n\n2、后台主页添加时钟\n\n3、修改密码功能\n\n4、后台查询报告模块\n\n5、动态添加检测参数信息\n\n6、查询报告模块添加功能\n\n7、至科待办事项分配\n\n#### 2016年6月16日星期四\n\n1、查看提交的测试缺陷报告\n\n2、分析缺陷报告中的bug\n\n3、修改设计院网站bug及规避bug\n\n4、合并整合至科网站代码\n\n5、报告查询页面\n\n6、报告查询表数据库设计\n\n7、数据字典整理\n\n8、至科后台图片替换，页面添加修改美化\n\n#### 2016年6月15日星期三\n\n1、装系统\n\n2、搭建论坛\n\n3、创建设计院网站下载中心、友情链接两个表\n\n4、根据需求手写model、dal、bll三层代码\n\n5、完成后台下载中心之上传文件功能\n\n6、后台下载中心文件管理功能\n\n7、文件信息列表分页、删除功能\n\n8、前台所有页面转换为aspx页面\n\n#### 2016年6月14日星期二\n\n1、人力资源模块完成\n\n2、联系我们模块完成\n\n3、添加禁止选中页面内容脚本\\(可选\\)\n\n4、添加禁止鼠标右键脚本\\(可选\\)\n\n5、至科页面全部实现完成\n\n6、至科页面思维导向图\n\n7、服务器中配置MVC项目\n\n8、和PengYun交流后台页面搭建及代码实现\n\n9、至科后台代码，文件上传与下载Demo\n\n#### 2016年6月13日星期一\n\n1、修复设计院网站bug\n\n2、至科网站\n\n1.关于至科模块，公司简介、荣誉资质、试验室、工程业绩4个页面完成\n\n① 图片瀑布流布局\n\n② 图片大图弹窗浏览\n\n2.服务项目模块，地基基础工程检测、建筑幕墙工程检测、钢结构工程检测、主体结构检测、节能检测、工程设备检测6大页面完成\n\n3.下载中心模块，委托单下载、规范下载2个页面完成\n\n4.新闻中心模块，公司新闻、行业新闻、新闻详情3个页面完成\n\n5.整个网站禁止复制内容\n\n#### 第八周总结\n\n刚刚过完端午，相信大家都有吃粽子吧，呃...反正我没吃。\n\n这一周，总感觉是上一周，可能是玩了三天，糊涂了，这一周完成了一个项目。\n\n整个项目的一大半由我一人完成，其中包括：前台静态页面，利用HTML5+CSS+JavaScript编写、提供一套后台UI、后台6\\) 三层框架搭建、整体优化布局、登录模块、新闻资讯、招聘英才、数据库三个表的设计。。。\n\n今天周日，因为放了三天假，所以今天正常上班，又接手了一个新的项目，和上一个项目类似，可又不类似，总之是多了很多细节，看似简单的页面，却要调试很久。各种特效，用户交互效果也很多。写了一天多一共写了三个页面，第三个页面还没有完全完成。有点吃不消了，作为一共.Net开发，却被公司用来写前端页面，写完前端页面又要继续跟踪后台代码。。。一个网站十几个页面，全由我一个人完成，没日没夜的写。\n\n是不是应该和经理提出...嗯，我需要一个助手，页面太多了吃不消。希望有人能帮我分担一下。这样我也不用那么累。是吧？\n\n#### 2016年6月12日星期日\n\n1、至科网站 – 首页\n\n① 首页总体代码完成\n\n② 至科集团简介、热点检测项目、新闻资讯三大小模块完成\n\n③ 底部二维码/公司信息/友链\n\n2、关于至科/公司简介页面完成\n\n3、荣誉资质页面 – 难点\n\n4、查看设计院网站测试bug并修改\n\n5、和PengYun对接至科网站后台功能\n\n6、对至科网站图片内容、大小提出疑问并让美工修改\n\n#### 2016年6月9日星期四 - 2016年6月11日星期六 - 端午节放假\n\n#### 2016年6月8日星期三\n\n1、修改设计院网站遗留Bug\n\n① 后台上传图片给出建议像素提示\n\n② 服务项目模块每页显示12条数据\n\n③ 修改翻页无效问题\n\n④ 修复上传图片重名的弊端\n\n2、至科网站 – 首页\n\n① 首页总体设计\n\n② 头部加入收藏JS效果\n\n③ 炫酷3D导航栏\n\n④ 首页banner图轮播\n\n⑤ 首页内容区布局\n\n#### 2016年6月7日星期二\n\n1、整合设计院网站\n\n2、开发文档编写\n\n3、设计院后台图片处理\n\n4、所有代码整理，美化\n\n5、至科网页样式交涉分析\n\n#### 2016年6月6日星期一\n\n1、设计院网站\n\n2、修改密码功能\n\n3、后台页面修改\n\n4、快捷编辑\n\n5、存储过程分页\n\n#### 第七周总结\n\n七七四十九了。本周接手了公司的一个项目，相对来说比较忙，今天还加了一整天班。\n\n这一周完成了美工所设计的第二版设计院PSD，整整十几个页面加部分JS特效，修修补补总算完成。然后写完页面继续跟着做后台。截至周日，我所负责的两个模块，新闻信息发布和招聘英才后台增删改查，前台显示，分页查询等等已圆满完成。\n\n期间，遇到好几个坑，然后又自己填坑，所有数据访问都是自己手写，以往都是添加和显示在不同的页面，这一次这个后台添加和显示在同一个页面，是一个Tab切换效果。涉及到修改传值到添加那里显示出来。久久不能解决，最后静下心来想了想解决方案，然后成功解决。\n\n然后就是利用了存储过程，写了一个数字分页查询。现在，对于我来说，一个项目的增删改查已经不是问题了。从前台到后台，都能信手拈来，这种感觉很好。不过还是有些不足，很多技术还是不会，希望能继续接触一些前沿的技术，达到.net行业的标准。今天很累，在公司写了一天代码。天气热加上上火，真是难受。\n\n就先总结到这里吧，2016年6月5日22:33分。\n\n#### 2016年6月3日星期五\n\n设计院网站第二版终结\n\n学习网页相关知识\n\n设计院后台招聘信息模块\n\n#### 2016年6月2日星期四\n\n设计院网站设计\n\n#### 2016年6月1日星期三\n\n1、设计院网站\n\n2、近期工作总结\n\n3、开会内容\n\n① 教育局项目\n\n② Lims项目\n\n③ OA\n\n④ 设计院网站\n\n⑤ 手提袋\n\n⑥ 至科网站改版升级\\(报告查询\\)\n\n⑦ Lbt网站改版升级\n\n#### 2016年5月31日星期二\n\n1、设计院网站数据库\n\n2、设计院网站页面\n\n3、设计院网站后台\n\n#### 2016年5月30日星期一\n\n1、SQL架构+数据导入导出\n\n2、学习JS解析json\n\n3、C\\#.Net解析json\n\n4、响应式Web设计 HTML5和CSS3实战\n\n5、H5全新语义化元素整理总结\n\n#### 第六周总结\n\n这周过得比较快，只上了三天班，请假了两天。周一完成了设计院网站的第一个html版本，周二周三回学校去了。\n\n转眼间，马上就要毕业了。回学校照了个毕业照，然后毕业证头像采集，让室友陪我打了几把LOL，哈哈，原来我是真的很坑。\n\n这周接触了一个新的UI，FineUI。基于 jQuery / ExtJS 的 ASP.NET 一个控件库，由来自中国的程序员 三生石上 和 RingoDing 创建并维护。在博客园中看到的，然后一路跟随到FineUI官网，并瞅了瞅，感觉还不错。利用其拖拖拽拽就完成了一个demo。不过好归好，在其华丽的背后总有那么些不足之处，这还是服务器端控件，严重的拖慢了网页加载速度，而且异常的臃肿。就不与其它UI作比较了，毕竟各有各的优势。\n\n嗯，还有就是我在腾讯云买了一个服务器。最低配置的那种，不过对我来说可以用了。我将自己做过的项目都挂上去了，拿来测试、瞎折腾还是可以的。\n\n马上第七周了，这一周应该会很忙，设计院的网站开始做了，框架已经搭建好，只等数据库设计完成了。然后我还要更改网站样式，因为第一版略显丑态，不太合适，美工又重新设计了新的样式。黑暗的世界马上来临。\n\n#### 2016年5月27日星期五\n\n1、搭建设计院后台3+层框架\n\n2、数据库搭建分析\n\n3、后台UI修改\n\n4、折腾服务器，将自己的项目上传至服务器\n\n#### 2016年5月26日星期四\n\n1、分析设计院网页实现方法\n\n2、学习FineUI\n\n3、利用FineUI完成登录Demo\n\n#### 2016年5月25日星期三\n\n上午毕业证头像采集，下午照了毕业照\n\n#### 2016年5月24日星期二\n\n请假的第一天，今天返校了\n\n#### 2016年5月23日星期一\n\n1、完成设计院网站的设计\n\n2、响应式Web设计学习\n\n3、看书《H5和CSS3实战》\n\n#### 第五周总结\n\n第五周了，公司走了个同事，是我在第一周总结中提到的一个学长。在之前，他就跟我说过，他干不长，不喜欢公司的这种模式，他认为学不到东西。所以他告诉我，他忍不住了，要辞职了。两个字，呵呵~\n\n这周，感觉过得蛮快，周一跟经理一起出去了一趟，早早地起了床，真正体验到了一把，客户就是上帝。对，没错，我们去见客户了，本来是去部署项目的，可是，压根不是我想的那样，被打回来了，客户的随便一句话，可能在他认为就一个小小的东西，我们都要修改半天。…后来还好，虽然还有不少问题，但是第二天如期上线了。\n\n不知不觉，已经到五月下旬了，来这个公司是4月18号到今天也有一个月零4天了。差不多什么也都摸清楚了，鉴于第一份实习工作，还是老老实实待下去，既呆之则安之。\n\n最近老是忧心忡忡的，也不知道怎么回事，仔细想想，也就那回事，每天上班下班挤公交，回到小窝睡大觉。\n\n可能是报考了驾校的原因，因为是之前没工作在学校报的，考了科一，直到现在车碰都没碰过。两个字：惆怅。现在也没时间回去学，不知道什么时候能拿到驾照！\n\n明天又是星期一，是我最不喜欢的一天，因为明天早上的车有个特点，那就是特别堵特别堵特别堵。。。\n\n#### 2016年5月20日星期五\n\n1、继续编写页面\n\n2、开会总结\n\n① 教育局登记系统成效及不足\n\n2016年5月22日星期天\n\n1、下午公司加班写了个页面\n\n2、开会\n\n① GuoHongYu，教育局登记系统\n\n② JiDaoMiao，至科检测工作流平台\n\n③ Me，设计院网站\n\n#### 2016年5月19日星期四\n\n1、OA debug\n\n2、编写信义东方网页\n\n#### 2016年5月18日星期三\n\n1、JS特效学习\n\n2、幼儿园系统后台界面美化\n\n3、提交一个月工作感受\n\n4、晚上会议\n\n① 月度总结\n\n② 工作日志，计划性\n\n③ 设计图定稿\n\n④ Lims系统\n\n⑤ OA\n\n#### 2016年5月17日星期二\n\n1、解决幼儿园系统时间转换问题\n\n2、电脑死机蓝屏进不了系统，重装系统\n\n3、学习前端知识\n\n4、和ChenXia沟通设计样式，分析实现效果\n\n5、晚上会议\n\n①项目部署完成，教育局报名系统告一段落\n\n②测试人员~\n\n③多浏览器的兼容性\n\n④敏捷开发\n\n⑤接下来重点Lims产品、设计院网站\n\n⑥每天的工作日志、工作状态、工作计划\n\n⑦需求分析…\n\n#### 2016年5月16日星期一\n\n1、跟随外出学习\n\n2、帮助中心\n\n3、引导页面窗口调整\n\n4、报名页面弹窗提示\n\n5、服务到期功能\n\n#### 第四周总结\n\n差不多也一个月了，第四周也结束了。本周主要围绕公司两大项目走，事情特别多，加了很多班，周日加了一整天班，周六陪女朋友一天。\n\n报名系统周一上线，希望能够完美通关。不然又要苦了我们这些实习生，一个多星期的修修补补，功能完善，测试，改bug…乐此不疲。\n\n还有就是公司内部的工作流项目，确立了新的需求，利用开源框架roadflow二次开发，个人感觉虽然节省了很多时间，但是来改人家的框架是多么不容易的一件事，有种生拽硬拉的感觉。特别不爽。不过，对于实习生的我来说，只能处理项目的边边角角。啦啦啦~\n\n本周公司发了我第一个月为期10天的实习工资，中间出了很多小波折，希望下个月发工资的时候可以解决。\n\n#### 2016年5月15日星期日\n\n1、帮助中心页面\n\n2、报名改登记\n\n3、修改图片文字\n\n4、测试...\n\n#### 2016年5月13日星期五\n\n1、教育局报名系统代码\n\n2、学会填写报销单，报销加班打车费用！\n\n3、测试教育局报名系统\n\n4、至科代码\n\n5、编写两个html页面\n\n#### 2016年5月12日星期四\n\n1、处理图片显示逻辑，房产证和购房合同上传了哪张就显示哪张，没上传显示默认图\n\n2、增加居住证图片显示，没上传显示默认图\n\n3、教育局和学校各页面图片显示，默认图片的处理\n\n4、教育局报名系统2016年秋季小学起始报名登记工作开始啦展示框\n\n5、教育局报名系统沌口片区和汉南片区登记入口页面\n\n#### 2016年5月11日星期三\n\n1、至科系统的上传与下载\n\n2、iis不安全端口解决方案\n\n3、学习教育局报名系统\n\n4、晚上会议\n\n① 针对教育局报名系统的bug做出任务划分\n\n② 教育局报名系统的逻辑梳理\n\n③ 图片显示问题\n\n#### 2016年5月10日星期二\n\n1、弹窗获取当前所选中radio的值\n\n2、文件的上传与下载\n\n3、数据绑定案例\n\n4、教育局报名系统测试\n\n5、Cookie之登录页面记住我\n\n#### 2016年5月9日星期一\n\n1、熟悉教育局报名系统代码\n\n2、至科代码\n\n3、JS控制table点击按钮增加行\n\n4、子窗体的子窗体给父窗体传值问题\n\n#### 第三周总结\n\n好快，实习第三周结束了。\n\n这周主要是针对公司的一个教育报名系统进行整改，测试。本周加了两天班，这是我第一次加班，不打卡，不记考勤，周六早早地到了公司，等了半个多小时才进去。中午经理和我们一起吃了饭，当然是他买单。\n\n本来周末两天是想要回学校的，但是计划赶不上变化，时间都奉献了。\n\n每天都在和那个特别烂的报名系统打交道，感觉好烦躁。\n\n嗯，今天是母亲节，祝全天下伟大的母亲节日快乐。\n\n这周就先这样把，明天又是一个新的开始，接下来，要给经理提交一份有关福利待遇的建议方案。\n\n打算在本月18号之前写一份“满月”体验报告。\n\n从上月18号到今天是第20天。\n\n漫漫职场程序路，何时才能到尽头？\n\n#### 2016年5月8日星期日\n\n1、教育局报名系统测试\n\n2、修改教育局报名系统存在的bug\n\n3、撰写有关福利待遇的建议方案\n\n4、浏览博客园网站，收听.NET FM，聆听时下前沿技术\n\n5、加班加到21:35，没什么想说的了\n\n#### 2016年5月7日星期六\n\n1、今天加班\n\n2、鼓捣OCR图像文字识别技术，demo案例\n\n3、教育局报名系统整合，界面美化\n\n4、整理教育局报名系统测试账号\n\n#### 2016年5月6日星期五\n\n1、去掉上传按钮，统一进行上传\n\n2、上传图片采用GUID+文件名命名，避免重名\n\n3、学会目录分离算法，避免和解决大量文件保存在同一个目录下的问题，通过目录分离算法来保证在不同的图片保存在不同的目录下。\n\n4、界面美化\n\n5、研究“以图搜图”技术,现有两种方案，具体实现有待研究\n\n① 感知哈希算法\n\n⑴ 缩小图片尺寸 将图片缩小到8x8的尺寸, 总共64个像素. 这一步的作用是去除各种图片尺寸和图片比例的差异, 只保留结构、明暗等基本信息.\n\n⑵ 转为灰度图片 将缩小后的图片, 转为64级灰度图片\n\n⑶ 计算灰度平均值 计算图片中所有像素的灰度平均值\n\n⑷ 比较像素的灰度 将每个像素的灰度与平均值进行比较, 如果大于或等于平均值记为1, 小于平均值记为0.\n\n⑸ 计算哈希值 将上一步的比较结果, 组合在一起, 就构成了一个64位的二进制整数, 这就是这张图片的指纹.\n\n⑹ 比图片指纹 得到图片的指纹后, 就可以对比不同的图片的指纹, 计算出64位中有多少位是不一样的. 如果不相同的数据位数不超过5, 就说明两张图片很相似, 如果大于10, 说明它们是两张不同的图片.\n\n② OCR图像文字识别技术\n\n因为户口本、房产证、出生证明等图片上的文字是固定的，所以可以获取户口本、房产证、出生证明等图片上的文字信息来验证图片正确与否。\n\n#### 2016年5月5日星期四\n\n1、上午会议\n\n① ChenZong对公司做介绍，现状，规划\n\n② 上市，产品\n\n③ 绩效问题\n\n④ 研发大楼\n\n⑤ 千万级智能建筑项目\n\n⑥ 分公司\\(十堰、宜昌~\\)\n\n⑦ 待遇问题\n\n2、完成GuoHongYu安排的任务，整合修改的代码\n\n3、测试教育局报名系统\n\n4、报名系统存在问题\n\n① 获取片区信息，有部分小区显示不存在\n\n② 选择特定小区“万科金域蓝湾小区”下面不隐藏\n\n③ 特定小区“滨湖小区”下一步没反应\n\n④ 所有选择房产证和购房合同页面，选择房产证没问题，选择购房合同，则会弹出提示输入门牌号和房产证\n\n#### 2016年5月4日星期三\n\n1、整个上午开会\n\n① 主题分享之图文技术点应用解析\n\n② 确定无特别情况，每周四晚组织《学习会》\n\n③ 近期的工作重点：两个系统\n\n④ 绩效考核办法讲解\n\n⑤ 教育局需求分析\n\n⑥ 公司娱乐活动建议型方案\n\n⑦ 现有问题总结，解决方案\n\n2、图片修改“报名”改“登记”\n\n3、图片上传问题异常解决\n\n4、下拉框上传不刷新\n\n5、教育局报名系统页面微调，兼容性\n\n#### 2016年5月3日星期二\n\n1、至科检测工作流平台\n\n2、搭建多层结构的博客项目\n\n3、前台登录页面\n\n4、后台登录模块\n\n5、联系人列表aspx版增删改查\n\n6、晚上会议\n\n① 教育局报名系统测试报告点评\n\n② 教育局报名系统bug修改，需求分析\n\n③ LoadRunner压力测试\n\n④ 以图搜图技术\n\n#### 2016年5月2日星期一\n\n今天是休假最后一天，\\(^o^\\)/YES!\n\n#### 第二周总结\n\n一晃半个月就这样过去了，第二周过的是那样的快，今天是五一劳动节，按国家规定我们放假三天。在紧凑的工作生活中又带来些许的放松，我刚从学校回到住处。对的，自己一个人太无聊，我跑到学校去了，去见见我那室友们。\n\n看看上面的每日任务，这周说真的，并没有学到什么，这周下发的任务很少基本上没有，所有就选择了自己安排，总的来说，学了点jQueryEasyUI、搞了一个用一般处理程序+HTML+ajax完成的增删改查小案例，哦！还有那个SQL的存储过程分页，跟进了公司的一个教育局管理系统，完成了其中的两个小模块。其它的小事就不往上面写了，大概就是这样把！\n\n渐渐地天气热了起来，夏天给人的感觉总是那么浮躁。不知为何，现在的我根本静不下心来了，没有了在学校的那种拼劲，慢慢的我感觉到自己松懈了，偏偏上班了却又没有那种特别明确的目标了。在学校的时候就想着找个公司好好实习，好好学技术，努力提升自己的价值。反而现在到了公司却有种迷茫的感觉。是自己的问题？抑或是公司的问题？\n\n仔细想了想，应该还是个人原因，就拿目前的我和之前的我对比一下：现在晚上早早地上了床，大概每晚10点多左右，就算睡不着也躺在床上。之前在学校，基本上都是12点过后才上床睡觉的，不是在敲代码，就是在看视频。\n\n不能因为现在有了一个落脚地，就因此松懈啊！还是要不断的学习才可以，既然选择了程序员这条路，就要不遗余力的去编码，去学习，学习如逆水行舟不进则退啊！除非你想一直只拿2K的薪水。这不是我想要生活，我要过上高质量的生活水平，现在的我还是远远不够的，埋头苦干才是硬道理，技术才是王道，奔跑吧，阿星！\n\n不在沉默中暴发，就在沉默中灭亡！\n\n#### 2016年4月29日星期五\n\n1、教育局报名系统测试\n\n2、教育局报名系统完善图片上传功能\n\n3、一般处理程序联系人列表的增删改查案例\n\n4、分页展示信息列表\n\n5、至科检测工作流平台表单、流程设计\n\n#### 2016年4月28日星期四\n\n1、至科检测工作流平台表单、流程设计\n\n2、Html页面+ 一般处理程序留言评论案例\n\n3、一般处理程序联系人列表的增删改查案例\n\n4、存储过程分页\n\n#### 2016年4月27日星期三\n\n1、教育局系统遮罩层图片显示功能模块\n\n2、至科检测工作流平台表单、流程设计\n\n3、ajax异步请求实现注册\n\n#### 2016年4月26日星期二\n\n1、修改网站流量统计页面代码\n\n2、学习在线投票功能案例\n\n3、学习jQueryEasyUI，搭建页面，进行增删改查操作\n\n4、晚上会议\n\n①教育局报名系统业务流程，项目介绍等\n\n②Lims产品介绍\n\n#### 2016年4月25日星期一\n\n1、观看WebApp相关资料和视频\n\n2、学习登录注册Demo后台逻辑\n\n3、学习观看新闻管理系统Demo\n\n4、学习文件上传下载Demo\n\n5、晚上会议\n\n①针对自己的学习情况，谈谈对公司上司及自己的一些看法\n\n②Boss对我们存在的一些问题进行讲解答疑\n\n③对教育局管理系统和至科实验室信息管理系统的切入、学习\n\n④教育局管理系统项目转化为产品的打算、预想\n\n⑤观看《青春代码》微电影\n\n#### 第一周总结\n\n这是我的第一次正式工作，我现在是一名大二的学生。这个时间段应该是在学校无忧无虑的过着安稳的日子的，可是我却已经出来实习了。至于为什么这么早出来找工作其实有很多原因的，有个人原因也有学校的原因，总之吧，在学校我感觉我已经学不到东西了，所以还不如早点出来锻炼锻炼自己。这个过程真的蛮艰难的，对于一个初入职场的小白来说是这样的。2016年4月15日，我的3个舍友牺牲了自己的时间帮我提行李到我所租房子的地方，打扫卫生，整理房间...真的很感谢他们，东西比较多，如果是我一个人拿的话，估计会更艰难，为表感谢，我请他们去饭店吃了一顿。\n\n我住的这个地方，距离我工作的地方，不堵车的话大概半小时的公交路程。接下来的两天，我熟悉了这里的环境，合租房，公共卫生间，真的有很多的不方便。我找的这个地方地段比较好，但是这也恰恰增加了我的经济负担，往往地段比较好的位置，消费都是比较高的。\n\n每天上班都要走很远的路程，武汉这个地方，这两年到处都在修路，真是非常的不方便。第一天上班的前一晚我特别兴奋，大晚上的在床上翻来覆去一直睡不着，早上提前了一个小时到公司，非常尴尬，因为是打卡式的，我进不去，只好在外边转了几圈直到8点左右我才上去进行一系列的入职流程。公司的上班时间是8:30--5:30，有了第一天的经验，我早上一般都是6点半起床，进行洗漱后7点准时出发，走到公交站大概7:30左右，不管堵不堵车，一个小时的缓冲时间是肯定可以到公司的。\n\n在公司按部就班的进行实习学习，我的领导个人感觉还是蛮nice的，比较人性化，喜欢和我们交流，有好几次中午都是和我们几个实习生一起走路去吃饭。一起和我实习的是我的一个学长，当时也是蛮诧异的，他和我是同一天进入这个公司的，当时还感叹了一下，这个世界其实有时候还是蛮小的。\n\n不管怎么样，这是我的第一份工作，我希望自己能够做好，不断增强自己，早日达到标准。\n\n#### 2016年4月22日星期五\n\n1、熟悉教育局报名管理系统后台逻辑\n\n2、完成GuoHongYu分配的任务\n\n3、学习三层架构\n\n#### 2016年4月21日星期四\n\n1、完成图片上传之前本地预览功能\n\n2、上午会议\n\n① Jin日里程碑提交规范\n\n② Lims观后感或者测试报告点评\n\n③ 近期任务：配合GuoHongYu安排的任务、学习\n\n④ C\\#开发编码规范\n\n3、学习RoadFlow工作流引擎，教育局报名管理系统\n\n4、来游戏•复盘设计方案分析\n\n5、研究H5 APP开发 - WeX5\n\n#### 2016年4月20日星期三\n\n1、继续观看信息系统，并写观后感\n\n2、仿淘宝图片大图显示js代码特效\n\n3、图片上传之前本地预览功能\n\n#### 2016年4月19日星期二\n\n1、登陆系统练习\n\n2、在线观看至科实验室信息管理系统\n\n#### 2016年4月18日星期一\n\n1、第一天上班，配置电脑，熟悉环境\n\n2、登录系统练习\n",
    "category": "Summary",
    "tag": [
      "工作总结",
      "实习",
      "总结"
    ],
    "createdAt": "2017-05-31 16:00:31"
  },
  {
    "title": "2017年终总结",
    "author": "阿星Plus",
    "url": "2018-01-02-2017-summary",
    "markdown": "眼看17年就要过去了，还是动动手指向自己汇报汇报今年的流水账吧！\n\n2017年2月10日我辞掉了第一家公司的实习工作，在武汉陪着女朋友嗨了一周之后独自一人踏上了前往魔都上海的旅途。至此，魔都漂泊的日子正式开始了。\n\n在经历了几天的挤地铁，投简历和一系列面试之后，于2017年2月22日正式拿到上海盖世汽车网络技术有限公司的offer。\n\n接下来便是找房子、租房子、熟悉环境，五天之后正式入职。\n\n4月份请假回校答辩，6月底再次回校，大学生涯结束了，正式毕业拿到毕业证，顺便还正式成为了一名中华人民共和国党员。\n\n2017年7月正式签订劳动合同，转正，实习期结束。\n\n一晃一年过去了，这一年我过的很充实，虽然很辛苦但是乐在其中。\n\n作为一名程序员，最开心的莫过于技术的提升。这一年的工作中，接触了许多新技术，我也不断学习着进步着。\n\n刚从学校走出来的我，主要做web开发，其它的都只是有所了解浅尝辄止，从来没有真正的去做过项目，借着公司的项目，现在会了微信小程序开发、Native App开发。\n\n在公司主要用.NET开发网站，写写脚本，小工具，爬虫等等。慢慢接触了ReactNative、APICloud、WebApi、WebService、.Net MVC、.Net Core、Linux、Nginx、微信小程序，并且能够上手简单使用，同时做了几个网站，小程序和App 并且全部上线使用中。\n\n新的一年，给自己先定一个不能达到的小目标，比方说我先挣它一个亿。\n",
    "category": "Summary",
    "tag": [
      "年终总结",
      "总结",
      "2017"
    ],
    "createdAt": "2018-01-02 13:01:02"
  },
  {
    "title": "执行超大sql文件",
    "author": "阿星Plus",
    "url": "2018-01-24-execute-sql",
    "markdown": "```sql\nosql -S 127.0.0.1 -U sa -P 123456 -i d:\\test.sql\n```\n\n#### osql为SQL Server的命令，在cmd中执行该命令，一般安装完SQL Server后该命令对应的路径会自动添加到系统环境变量中\n\n* S 表示要连接的数据库服务器\n* U 表示登录的用户ID\n* P 表示登录密码\n* i 表示要执行的脚本文件路径\n",
    "category": "Database",
    "tag": [
      "SqlServer",
      "SQL"
    ],
    "createdAt": "2018-01-24 10:04:24"
  },
  {
    "title": "移除Windows图标快捷方式小箭头",
    "author": "阿星Plus",
    "url": "2018-02-20-remove-shortcuts",
    "markdown": "以管理员身份运行 cmd，键入以下代码即可。\n\n```scheme\nreg delete \"HKEY_CLASSES_ROOT\\lnkfile\" /v IsShortcut /f & taskkill /f /im explorer.exe & start explorer.exe \n```\n",
    "category": "Other",
    "tag": [
      "Windows"
    ],
    "createdAt": "2018-02-20 18:22:20"
  },
  {
    "title": "HTML60秒倒计时",
    "author": "阿星Plus",
    "url": "2018-04-19-countdown",
    "markdown": "```markup\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>60秒倒计时</title>\n</head>\n\n<body>\n    <input type=\"button\" id=\"btn\" value=\"获取验证码\" onclick=\"sendemail()\" />\n</body>\n\n</html>\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n<script>\nvar countdown = 5\n\nfunction sendemail() {\n    var obj = $(\"#btn\")\n    settime(obj)\n    console.log('发送邮件')\n}\n\nfunction settime(obj) {\n    if (countdown == 0) {\n        obj.attr('disabled', false)\n        obj.val(\"获取验证码\")\n        countdown = 5\n        return\n    } else {\n        obj.attr('disabled', true)\n        obj.val(\"重新发送(\" + countdown + \")\")\n        countdown--\n    }\n    setTimeout(function() {\n        settime(obj)\n    }, 1000)\n}\n</script>\n```\n",
    "category": "Web",
    "tag": [
      "HTML",
      "倒计时"
    ],
    "createdAt": "2018-04-19 17:34:19"
  },
  {
    "title": "游标循环处理数据",
    "author": "阿星Plus",
    "url": "2018-06-20-cursor",
    "markdown": "在开发中，经常会遇到一个场景。需要批量处理数据，循环添加、删除、修改一些数据。\n\n**需求：**\n\n有 文章表（dbo.Gas\\_Article）、文章作者表（dbo.Gas\\_ArticleAuthor）\n\n现在需要在后台统计出每个作者共发布了多少文章，和所有文章阅读量之和的数据\n\n**以下是我的处理方案：**\n\n编写PROCEDURE，内部利用游标循环处理数据，然后使用SqlServer代理，新建一个作业定时任务处理，这样就可以在后台实时统计了。\n\n```sql\nCREATE PROCEDURE Job_UpdateAuthor --创建PROCEDURE\nAS\n    BEGIN\n        DECLARE UpdateAuthorCursor CURSOR --定义游标\n        FOR\n            SELECT  COUNT(*) AS ArticleNumber ,\n                    SUM(ShowHits) AS ArticleHits ,\n                    Author\n            FROM    dbo.Gas_Article\n            WHERE   Author IN ( SELECT  Name\n                                FROM    dbo.Gas_ArticleAuthor\n                                WHERE   IsDelete = 0 )\n            GROUP BY Author --查出需要的数据至游标中\n\n        OPEN UpdateAuthorCursor --打开游标\n\n        DECLARE @Number INT, @Hits INT, @Author NVARCHAR(255)\n        FETCH NEXT FROM UpdateAuthorCursor INTO @Number, @Hits, @Author --读取第一行数据，赋值给变量\n\n        WHILE @@FETCH_STATUS = 0\n            BEGIN\n                UPDATE  dbo.Gas_ArticleAuthor\n                SET     ArticleNumber = @Number ,\n                        ArticleHits = @Hits\n                WHERE   Name = @Author -- 更新dbo.Gas_ArticleAuthor数据\n\n                FETCH NEXT FROM UpdateAuthorCursor INTO @Number, @Hits, @Author --读取下一行数据\n            END\n\n        CLOSE UpdateAuthorCursor --关闭游标\n\n        DEALLOCATE UpdateAuthorCursor --释放游标\n    END\nGO\n```\n\n",
    "category": "Database",
    "tag": [
      "SqlServer",
      "SQL",
      "cursor"
    ],
    "createdAt": "2018-06-20 08:45:20"
  },
  {
    "title": "HTML多图无缝循环翻页效果",
    "author": "阿星Plus",
    "url": "2018-08-24-loop-page",
    "markdown": "```markup\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>多图无缝循环翻页效果</title>\n    <style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n    .carousel {\n        width: 1000px;\n        height: 500px;\n        margin: 0 auto;\n        overflow: hidden;\n    }\n\n    .carousel ul li {\n        width: 1000px;\n        height: 500px;\n        list-style-type: none;\n        float: left;\n    }\n\n    .carousel ul li a img {\n        width: 100%;\n        height: 100%;\n        object-fit: contain;\n    }\n    </style>\n</head>\n\n<body>\n    <div class=\"carousel\">\n        <ul>\n            <li>\n                <a href=\"#\">\n                    <img src=\"https://api.meowv.com/girl\" alt=\"1\">\n                </a>\n            </li>\n            <li>\n                <a href=\"#\">\n                    <img src=\"https://api.meowv.com/girl\" alt=\"2\">\n                </a>\n            </li>\n            <li>\n                <a href=\"#\">\n                    <img src=\"https://api.meowv.com/girl\" alt=\"3\">\n                </a>\n            </li>\n        </ul>\n    </div>\n</body>\n\n</html>\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n<script>\nvar carousel = $('.carousel ul'),\n    li = $('.carousel ul li');\ncarousel.css('width', li.width() * li.length);\nsetInterval(function() {\n    carousel.animate({\n        'marginLeft': -li.width()\n    }, 500, function() {\n        $(this).animate({ 'marginLeft': 0 }, 0)\n            .find('li').eq(0).appendTo($(this));\n    });\n}, 3000);\n</script>\n```\n",
    "category": "Web",
    "tag": [
      "HTML",
      "翻页"
    ],
    "createdAt": "2018-08-24 14:11:24"
  },
  {
    "title": "HTML页面全屏和退出全屏",
    "author": "阿星Plus",
    "url": "2018-10-27-screenfull",
    "markdown": "```markup\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>页面全屏/退出全屏</title>\n</head>\n\n<body>\n    <a class=\"screen-full\" id=\"full\" href=\"javascript:;\">全屏</a>\n</body>\n\n</html>\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n<script>\n$('#full').click(function() {\n    var ele = document.documentElement;\n    var SCREEN_FULL_TEXT = \"全屏\";\n    var SCREEN_REST_TEXT = \"退出全屏\";\n    var SCREEN_FULL = 'screen-full';\n    var SCREEN_REST = 'screen-restore';\n    var iconElem = $(this);\n    if (iconElem.hasClass(SCREEN_FULL)) {\n        var reqFullScreen = ele.requestFullScreen || ele.webkitRequestFullScreen || ele.mozRequestFullScreen || ele.msRequestFullscreen;\n        if (typeof reqFullScreen !== 'undefined' && reqFullScreen) {\n            reqFullScreen.call(ele);\n        };\n        iconElem.addClass(SCREEN_REST).removeClass(SCREEN_FULL);\n        iconElem.text(SCREEN_REST_TEXT);\n    } else {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.mozCancelFullScreen) {\n            document.mozCancelFullScreen();\n        } else if (document.webkitCancelFullScreen) {\n            document.webkitCancelFullScreen();\n        } else if (document.msExitFullscreen) {\n            document.msExitFullscreen();\n        }\n        iconElem.addClass(SCREEN_FULL).removeClass(SCREEN_REST);\n        iconElem.text(SCREEN_FULL_TEXT);\n    }\n});\n</script>\n```\n",
    "category": "Web",
    "tag": [
      "HTML",
      "全屏"
    ],
    "createdAt": "2018-10-27 00:08:27"
  },
  {
    "title": "2018年终总结",
    "author": "阿星Plus",
    "url": "2019-01-14-2018-summary",
    "markdown": "不知不觉中，已经2019了，今天来写写我迟到的年终总结。\n\n时间真是个好东西啊，每个人每天都拥有短短的24小时，转眼间从毕业实习到正式工作都过去差不多两年了。如此多的24小时，真是值得回味呢！\n\n依稀记得，2018年2月19大年初四爸妈不舍的神情，因为路途遥远加上初七就要上班，不得不提前离开老家返程回到上海。路上我就在想，今年一定要努力工作，攒点钱孝敬孝敬父母，他们的年纪慢慢也大了，而我也老大不小了……\n\n今年，利于闲暇时间看完了以下6本书，以及在读的就不列出了。\n\n* 《马伯庸笑翻中国简史》 ——马伯庸\n* 《腾讯传》 ——吴晓波\n* 《白说》 ——白岩松\n* 《没事别随便思考人生》 ——鬼脚七\n* 《看见》 ——柴静\n* 《三体》 ——刘慈欣\n\n读书，是我一直想做却一直没时间没坚持下去的一件事。现在是利用晚上睡觉前的时间进行阅读。书中的内容总是让人放松，可以领略作者笔下的世界。\n\n我所在的公司还是老传统的WebForm开发模式，框架甚至还停留在 .NET Framework 4，所有的系统软件都只能运行在Windows上面。所以自己今年系统学习了一下微软开源框架 .NET Core的开发和使用，还利用周末，下班时间做了几个外包项目。了解并会简单使用开源监控软件Zabbix，利用Zabbix API二次开发获取数据与现有后台进行通信、结合百度开源图表神器ECharts，展示大屏报表数据、学会如何将开发的网站部署至Linux以及简单的Linux命令行学习、开发了一个具有多语言的内网穿透管理系统，充分体验了 .NET Core的优越和便利。by the way，希望在以后的工作中，可以找 .NET Core开发的相关工作。\n\n工作上，一个项目接着一个项目的做着，需求是源源不断的，你会发现当你做完一件事情，总会有另外一件事情等着你的，公司是不可能让你闲下来，毕竟不养闲人嘛。以往的我总是焦虑，烦躁。现在的我则不会了。因为懂得了一个道理，事情总是源源不断的，不必去纠结烦恼，没有什么事是解决不了的，只要你静下心去想一想，思考一下解决办法，时间总是会证明这一切都是可以解决。在做项目写代码的时候也是一样的道理，没有解决不了的bug，没有完成不了的任务。不断去学习、思考，可以解决一切麻烦事。\n\n在上海的一年又过去了，这一年没有回过一次家，所以向公司申请了四天年假买了1月28号的火车票想早一点回家多陪陪家人\\(请年假的这件事，期间出现了很多不愉快，之前V2EX社区闹得沸沸扬扬的帖子就是本人，详见：[https://www.v2ex.com/t/522131](https://www.v2ex.com/t/522131) ，好在最后请假顺利\\)。\n\n写着写着，脑海出现了两首歌，《这个年纪》、《像我这样的人》。不是因为歌好听而是觉得歌词写得像自己。\n\n所以，加油吧少年，美好未来在明天。",
    "category": "Summary",
    "tag": [
      "年终总结",
      "总结",
      "2018"
    ],
    "createdAt": "2019-01-14 15:20:14"
  },
  {
    "title": "HTTP协议",
    "author": "阿星Plus",
    "url": "2019-07-01-http",
    "markdown": "#### http和https\n\n* http协议：全称是 HyperText Transfer Protocol，意思是超文本传输协议，是一种发布和接收HTML页面的方法，服务器端口号是80。\n* https协议：是HTTP协议的加密版本，在HTTP下加入了SSL层，服务器端口号是443。\n\n**在浏览器中发送一个http请求的过程**\n\n* 当用户在浏览器地址栏钟输入一个URL访问之后，浏览器会向服务器发送HTTP请求，http请求主要分为 \"GET\" 和 \"POST\"。\n* 比如当我们在浏览器输入URL [http://baidu.com](http://baidu.com) 的时候，浏览器发一个Request请求去获取 [http://baidu.com](http://baidu.com) 的HTML文件，服务器把Response文件对象返回给浏览器。\n* 浏览器分析Response中的HTML，发现其中引用了很多其他文件，如图片、css、js等，浏览器会自动再次发送Request去获取这些文件。\n* 当所有文件都下载成功，网页会根据HTML语法结构，完整显示出来。\n\n#### URL组成\n\nURL是Uniform Resource Locator的简写，统一资源定位符。 一个URL由以下几部分组成：\n\n* schema：代表访问的协议，一般为http、https、ftp\n* host：主机名，域名，比如 www.baidu.com\n* post：端口号，当访问一个网站的时候，http默认使用80，https默认使用443\n* path：查找路径，比如 www.baidu.com/search/error.html , search/error.html就是path\n* query-string：查询字符串，比如 www.baidu.com/s?wd=python wd=python就是查询字符串\n* anchor：锚点，前端用来做页面定位用\n\n在浏览器中请求一个URL，浏览器会对这个url进行编码，除了英文字母、数字和不分符号外，其他全部使用百分号加十六进制值进行编码\n\n#### GET 和 POST\n\n在HTTP协议中定义了8种请求方法\n\n* GET：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会用GET请求\n* POST：向服务器发送数据、上传文件，会对服务器资源产生影响的时候会使用POST请求\n\n以上是网站开发中常用的两种方法，一般情况下都会遵循使用原则，但是有些网站和服务器为了做反爬虫机制，也经常不按常理出牌，要视情况而定。\n\n#### 请求头常见参数\n\n在HTTP协议中，向服务器发送一个请求，数据分为三个部分，第一个是把数据放在URL中，第二个是把数据放在body中\\(POST请求\\)，第三个就是把数据放在head中\n\n* User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到，请求一个网页的时候，服务器通过这个参数就可以知道当前请求是由哪种浏览器发送的，如果我们通过Python爬虫发送请求，那么User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易判断请求是爬虫。因为我们需要设置这个值为一些浏览器的值，来伪装爬虫。\n* Referer：表明当前这个请求是从哪个URL过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做响应的响应。\n* Cookie：HTTP协议是无状态的。同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人，因此需要用Cookie来做标识，一般如果想要做登录后才能访问的网站，那么就需要发送Cookie信息了。\n\n#### 常见响应状态码\n\n* 200 OK：客户端请求成功\n* 400 Bad Request：客户端请求有语法错误，不能被服务器所理解\n* 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n* 403 Forbidden：服务器收到请求，但是拒绝提供服务\n* 404 Not Found：请求资源不存在\n* 500 Internal Server Error：服务器发生不可预期的错误\n* 503 Server Unavailable：服务器当前不能出来客户端的请求，一段时间后可能恢复正常\n",
    "category": "Python",
    "tag": [
      "网络请求",
      "HTTP",
      "GET",
      "POST"
    ],
    "createdAt": "2019-07-01 19:13:01"
  },
  {
    "title": "urllib库",
    "author": "阿星Plus",
    "url": "2019-07-02-urllib",
    "markdown": "### urllib库\n\nurllib库是Python中一个最基本的网络请求库，可以模拟浏览器的行为，向指定服务器发送一个请求，并可以保存服务器返回的数据。\n\n#### urlopen函数\n\n在Python3的urllib库中，所有和网络相求相关的方法都被集成到 urlli.request 模块下了，urlopen函数基本使用方法\n\n```python\nfrom urllib import request\nresponse = request.urlopen('http://www.baidu.com')\nprint(response.read())\n```\n\n* url：请求的url\n* data：请求的data，如果设置了这个值，那么将变成POST请求\n* 返回值：返回值是一个 http.client.HTTPResponse 对象，这个对象是一个类文件句柄对象，有read\\(size\\)、readline、readlines、getcode 等方法\n\n实际上，使用浏览器访问百度，右键查看源代码，会发现和代码打印出来的数据是一模一样的。\n\n#### urlretrieve函数\n\n这个函数可以方便的将网页上的一个文件保存到本地\n\n```python\n// 以下代码可以将百度首页代码下载到本地\nfrom urllib import request\nrequest.urlretrieve('http://www.baidu.com', 'baidu.html')\n```\n\n#### urlencode函数\n\n用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动给我们进行编码。而如果使用代码发送请求，那么就必须手动进行编码，这时候就应该使用urlencode函数来实现。urlencode可以把字典数据转换为URL编码的数据\n\n```python\nfrom urllib import parse\ndata = ['name':'阿星Plus','age':25,]\nqs = parse.urlencode(data)\nprint(qs)\n```\n\n#### parse\\_qs函数\n\n可以将经过编码后的url参数进行解码\n\n```python\nform urllib import parse\nqs = 'name=%E9%98%BF%E6%98%9FPlus&age=25'\nprint(parse.parse_qs(qs))\n```\n\n#### urlparse和urlsplit\n\n拿到一个URL，想要对这个URL中的各个组成部分进行分割，那么这时候就可以使用urlparse或者urlsplit来进行分割\n\n```python\nform urllib import request,parse\n\nurl = 'https://www.baidu.com/s?wd=阿星Plus'\n\n# result = parse.urlsplit(url)\nresult = parse.urlparse(url)\n\nprint('scheme:',result.scheme)\nprint('netloc:',result.netloc)\nprint('path:',result.path)\nprint('query:',result.query)\n```\n\nurlparse和urlsplit基本上是一模一样的，唯一不一样的是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。\n\n#### request.Request类\n\n如果想要在请求的时候增加一些请求头，那么就必须使用 request.Request 类来实现，比如要增加一个 User-Agent\n\n```python\nfrom urllib import request\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\nreq = request.Request('http://www.baidu.com', headers=headers)\nresp = request.urlopen(req)\nprint(resp.read()\n```\n\n#### ProxyHandler处理器\\(设置代理\\)\n\n* 很多网站会检测某一段时间某个IP的访问次数\\(通过流量统计，系统日志等\\)，如果访问次数多的不像正常人，它会禁止这个IP的访问\n* 所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取\n* urllib中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理\n\n```python\nfrom urllib import request\n# 没有设置代理\nresp = request.urlopen('http://httpbin.org/get')\nprint(resp.read().decode(\"utf-8\"))\n\n# 设置代理\nhandler = request.ProxyHandler({\"http\":\"132.232.126.92\"})\nopener = request.build_opener(handler)\nreq = request.Request('http://httpbin.org/ip')\nresp = opener.open(req)\nprint(resp.read()\n```\n\n#### Cookie\n\n在网站中，HTTP请求是无状态的，也就是说即使第一次和服务器连接并登录成功后，第二次请求服务器依然不知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据\\(cookie\\)给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4kb，因此使用cookie只能存储一些小量的数据。\n\n**cookie的格式**\n\n```text\nSet-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE\n```\n\n* NAME：cookie的名字\n* VALUE：cookie的值\n* Expires：cookie的过期时间\n* Path：cookie的作用路径\n* Domain：cookie作用的域名\n* SECURE：是否只在https协议下起作用\n\n**使用cookielib库和HTTPCookieProcessor模拟登录**\n\n* Cookie是指网站服务器为了辨别用户身份和进行Session跟踪而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话\n* 这里以人人网为例，人人网中，要访问某个人的主页，必须先登录才能访问，登录就是需要有cookie信息。解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中\n\n```python\nfrom urllib import request\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36',\n    'Cookie': 'anonymid=jy8dyj742asuaj; depovince=SH; _r01_=1; JSESSIONID=abc_7R4FWXud3fWjCgeWw; ick_login=501ccd78-b0b4-4253-b815-9992020c05de; jebecookies=c50e000a-723a-4f2f-ad13-6371cf5b4a63|||||; _de=2A184C89A453DAE2ECD78F48F9B08787; p=8de679b3735cc2d3245b06d272bc08665; first_login_flag=1; ln_uact=13477996338; ln_hurl=http://head.xiaonei.com/photos/0/0/men_main.gif; t=28a3a7049b82d64a7ef87911c789ac0a5; societyguester=28a3a7049b82d64a7ef87911c789ac0a5; id=971368245; xnsid=fbe5d896; ver=7.0; loginfrom=null; jebe_key=cb9f1dc6-cf33-4933-87e6-3289dc7cf36a%7C8ddf4c90ebf64a7cc8163133aa871bf1%7C1563436919308%7C1%7C1563436918703; jebe_key=cb9f1dc6-cf33-4933-87e6-3289dc7cf36a%7C8ddf4c90ebf64a7cc8163133aa871bf1%7C1563436919308%7C1%7C1563436918708; wp_fold=0'\n}\n\nurl = 'http://www.renren.com/971368245/profile'\nreq = request.Request(url, headers=headers)\nresp = request.urlopen(req)\nwith open('renren.html', 'w') as fp:\n    fp.write(resp.read().decode('utf-8'))\n```\n\n但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python中处理cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器类一起使用。http.cookiejar模块主要作用是提供用于存储cookie的对象，而HTTPCookieProcessor处理器主要作用是处理这些cookie对象，并构建handler对象。\n\n**http.cookiejar模块**\n\n该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar\n\n* CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失\n* FileCookieJar\\(filename,delayload=None,policy=None\\)：从CookieJar派生而来，用来创建FileCookieJar实例，检索Cookie信息并将Cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问文件，既只有在需要时才读取文件或在文件中存储数据\n* MozillaCookieJar\\(filename,delayload=None,policy=None\\)：从FileCookieJar派生而来，创建于Mozilla浏览器 cookies.txt兼容的FileCookieJar实例\n* LWPCookieJar\\(filename,delayload=None,policy=None\\)：从FileCookieJar派生而来,创建于libwww-pert标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例\n\n**使用http.cookiejar和request.HTTPCookieProcessor模拟登录**\n\n```python\nfrom urllib import request,parse\nfrom http.cookiejar import CookieJar\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\ndef get_opener():\n    cookiejar = CookieJar()\n    handler = request.HTTPCookieProcessor(cookiejar)\n    opener = request.build_opener(handler)\n    return opener\n\ndef login_renren(opener):\n    data = {\"email\": \"\", \"password\": \"\"}\n    data = parse.urlencode(data).encode('utf-8')\n    login_url = \"http://www.renren.com/PLogin.do\"\n    req = request.Request(login_url, headers=headers, data=data)\n    opener.open(req)\n\ndef visit_profile(opener):\n    url = 'http://www.renren.com/971368245/profile'\n    req = request.Request(url,headers=headers)\n    resp = opener.open(req)\n    with open('renren.html','w') as fp:\n        fp.write(resp.read().decode(\"utf-8\"))\n\nif __name__ == '__main__':\n    opener = get_opener()\n    login_renren(opener)\n    visit_profile(opener)\n```\n\n**保存cookie到本地**\n\n保存cookie到本地，可以使用cookiejar的save方法，并且需要指定一个文件名\n\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\ncookiejar = MozillaCookieJar('cookie.txt')\nhandler = request.HTTPCookieProcessor(cookiejar)\nopener = request.build_opener(handler)\n\nreq = request.Request('http://httpbin.org/cookies',headers=headers)\nresp = opener.open(req)\nprint(resp.read())\ncookiejar.save(ignore_discard=True,ignore_expires=True)\n```\n\n**从本地加载cookie**\n\n从本地加载cookie，需要使用cookiejar的load方法，并且也需要指定方法\n\n```python\nfrom urllib import request\nfrom http.cookiejar import MozillaCookieJar\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\ncookiejar = MozillaCookieJar(\"cookie.txt\")\ncookiejar.load(ignore_expires=True,ignore_discard=True)\nhandler = request.HTTPCookieProcessor(cookiejar)\nopener = request.build_opener(handler)\n\nreq = request.Request('http://httpbin.org/cookies',headers=headers)\nresp = opener.open(req)\nprint(resp.read())\n```\n",
    "category": "Python",
    "tag": [
      "网络请求",
      "urllib",
      "ip代理",
      "cookie"
    ],
    "createdAt": "2019-07-02 20:20:02"
  },
  {
    "title": "requests库",
    "author": "阿星Plus",
    "url": "2019-07-03-requests",
    "markdown": "虽然Python的标准库中 urllib模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests宣传是 “HTTP for Humans”，说明使用更简洁方便。\n\n### 安装和文档地址\n\n```text\npip install requests\n```\n\n* 中文文档：[http://docs.python-requests.org/zh\\_CN/latest/index.html](http://docs.python-requests.org/zh_CN/latest/index.html)\n* github地址：[https://github.com/requests/requests](https://github.com/requests/requests)\n\n### 发送GET请求\n\n* 最简单的发送get请求就是通过request.get来调用\n\n  ```python\n  response = request.get('http://www.baidu.com/')\n  ```\n\n* 添加header和查询参数，如果想要添加headers，可以传入headers参数来增加请求头中的headers信息，如果要将参数放在url中传递，可以利用params参数\n\n```python\nimport requests\nkw = {'wd': '中国'}\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\n# params 接受一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()\nresponse = request.get('http://www.baidu.com/s', params=kw, headers=headers)\n\n# 查看响应内容，response.text 返回的是Unicode格式的数据\nprint(response.text)\n\n# 查看响应内容，response.content 返回的是字节流数据\nprint(response.content)\n\n# 查看完整url地址\nprint(response.url)\n\n# 查看响应头部字符编码\nprint(response.encoding)\n\n# 查看响应码\nprint(response.status_code)\n```\n\n### 发送POST请求\n\n* 最基本的post请求可以使用post方法\n\n  ```python\n  response = request.post('http://www.baidu,com', data=data)\n  ```\n\n* 传入data数据，这时候就不需要urlencode进行编码了，直接传入一个字典进去就可以了\n\n  ```python\n  import requests\n  url = 'https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&needAddtionalResult=false&isSchoolJob=0'\n  headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36',\n    'Referer': 'https://www.lagou.com/jobs/list_python?labelWords=&fromSearch=true&suginput='\n  }\n  data = {\n    'first': 'true',\n    'pn': 1,\n    'kd': 'python'\n  }\n  resp = requests.post(url, headers=headers, data=data)\n  # 如果是json数据，直接可以调用json方法\n  print(resp.json())\n  ```\n\n### 使用代理\n\n使用requests添加代理，只需要在请求的方法中传递proxies参数就可以了\n\n```python\nimport requests\nurl = 'http://httpbin.org/get'\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\nproxy = {\n    'http': '132.232.126.92'\n}\n\nresp = requests.get(url, headers=headers, proxies=proxy)\nwith open('http.html', 'w', encoding='utf-8') as fp:\n    fp.write(resp.text)\n```\n\n### cookie\n\n如果在一个响应中包含了cookie，那么可以利用cookie属性拿到这个返回的cookie值\n\n```python\nimport requests\n\nresp = requests.get('http://www.baidu.com/')\nprint(resp.cookies)\nprint(resp.cookies.get_dict())\n```\n\n### session\n\n* urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享cookie的。\n* 使用requests，也要达到共享cookie的目的，可以用requests库提供的session对象。这里的session不是web开发中的session，这里只是一个会话的对象。\n\n```python\nimport requests\n\nurl = 'http://www.renren.com/PLogin.do'\ndata = {'email':'','password':''}\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36'\n}\n\n# 登录\nsession = requests.session()\nsession.post(url, data=data, headers=headers)\n\n# 访问个人主页\nresp = session.get('http://www.renren.com/971368245/profile')\nprint(resp.text)\n```\n\n### 处理不受信任的SSL证书\n\n对于那些已经被信任的SSL整数的网站，比如 [https://www.baidu.com/](https://www.baidu.com/) ，那么使用requests直接就可以正常的返回响应，对于不受信任的网站，添加 verify=False 参数\n\n```python\nurl = 'https://xxx.com'\nresp = requests.get(url,verify=False)\nprint(resp.content.decode('utf-8'))\n```\n",
    "category": "Python",
    "tag": [
      "网络请求",
      "GET",
      "POST",
      "cookie",
      "requests",
      "session"
    ],
    "createdAt": "2019-07-03 21:15:03"
  },
  {
    "title": "XPath语法",
    "author": "阿星Plus",
    "url": "2019-07-04-xpath",
    "markdown": "## 什么是Xpath?\n\nXPath\\(XML Path Language\\) 是一门在XML和HTML文档中查找信息的语言，可以用来在XML和HTML文档中对元素和属性进行遍历\n\n## XPath工具\n\n* Chrome插件 [XPath Helper](https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl)\n* Firefox插件 [Try XPath](https://addons.mozilla.org/en-US/firefox/addon/try-xpath/)\n\n## XPath语法\n\n### 选取节点\n\nXPath使用路径表达式来选取XML文档中的节点或者节点集，这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似\n\n| 表达式 | 描述 | 示例 | 结果 |\n| :--- | :--- | :--- | :--- |\n| nodename | 选取此节点的所有子节点 | `bookstore` | 选取bookstore下所有的子节点 |\n| / | 如果是在最前面，代表从根节点选取，否则选择某节点下的某个节点 | `/bookstore` | 选取根元素下所有的bookstore节点 |\n| // | 从全局节点中选择节点，随意在哪个位置 | `//book` | 从全局节点中找到所有的book节点 |\n| @ | 选取某个节点的属性 | `//book[@price]` | 选择所有拥有price属性的book节点 |\n| . | 当前节点 | `./a` | 选取当前节点下的a标签 |\n\n### 谓语\n\n谓语用来查找某个特定的节点或者包含某个指定的值的及诶按，被嵌在括号中使用\n\n| 路径表达式 | 描述 |\n| :--- | :--- |\n| `//bookstore/book[1]` | 选取bookstore下的第一个book子元素 |\n| `//bookstore/book[last()]` | 选取bookstore下最后一个book子元素 |\n| `//bookstore/book[position()<3]` | 选取bookstore下前面两个book子元素 |\n| `//book[@price]` | 选取拥有price属性的book元素 |\n| `//book[@price=10]` | 选取拥有price属性并且等于10的book元素 |\n\n### 通配符\n\n在XPath中用 `*` 来表示通配符\n\n| 通配符 | 描述 | 示例 | 结果 |\n| :--- | :--- | :--- | :--- |\n| `*` | 匹配任意节点 | `/bookstore/*` | 选取bookstore下的所有子元素 |\n| `@*` | 匹配节点中的任意属性 | `//book[@*]` | 选取所有带属性的book元素 |\n\n### 选取多个路径\n\n通过在路径表达式中使用 `|` 运算符，可以选取若干个路径，比如选取所有book元素已经book元素下所有的title元素 `//bookstore/book | //book/title`\n",
    "category": "Python",
    "tag": [
      "数据提取",
      "xpath"
    ],
    "createdAt": "2019-07-04 22:33:04"
  },
  {
    "title": "lxml库",
    "author": "阿星Plus",
    "url": "2019-07-05-lxml",
    "markdown": "### lxml 介绍\n\n* lxml 是一个 HTML/XML 的解析器，主要的功能是如何解析和提取 HTML/XML 数据\n* lxml 和正则一样，用 C 语言实现的，是一款高性能的 Python HTML/XML 解析器，可以利用 XPath 语法，快速定位元素以及节点的信息\n* lxml Python 官方文档：[https://lxml.de/index.html](https://lxml.de/index.html)\n* 安装命令：`pip install lxml`\n\n### 基本使用\n\n可以利用 lxml 解析 HTML 代码，并且在解析 HTML 代码的时候，如果 HTML 代码不规范，缺少标签，lxml 会帮我们自动的进行补全\n\n```python\n# 使用lxml的etree库\nfrom lxml import etree\n\ntext = \"\"\"\n    <div>\n        <ul>\n            <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n            <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n            <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n            <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n            <li class=\"item-0\"><a href=\"link5.html\">fifth item</a>\n            # 注意，此处缺少一个 </li> 闭合标签\n        </ul>\n    </div\n\"\"\"\n\n# 利用etree.HTML，将字符串解析为HTML文档\nhtml = etree.HTML(text)\n\n# 按字符串序列化HTML文档\nresult = etree.tostring(html)\n\nprint(result)\n```\n\n输出结果如下，可以看到 lxml 会自动修改 HTML 代码，不仅补全了 li 标签，还添加了 body,html 标签\n\n```markup\n<html>\n  <body>\n    <div>\n      <ul>\n        <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n        <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n        <li class=\"item-inactive\"><a href=\"link3.html\">third item</a></li>\n        <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n        <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n      </ul>\n    </div>\n  </body>\n</html>\n```\n\n### 从文件中读取 HTML 代码\n\n除了直接使用字符串进行解析，lxml 还支持冲文件中读取内容，新建一个 hello.html 文件，内容如下，然后利用 `etree.parse()` 方法来读取文件\n\n```markup\n<div>\n  <ul>\n    <li class=\"item-0\"><a href=\"link1.html\">first item</a></li>\n    <li class=\"item-1\"><a href=\"link2.html\">second item</a></li>\n    <li class=\"item-inactive\">\n      <a href=\"link3.html\"><span class=\"bold\">third item</span></a>\n    </li>\n    <li class=\"item-1\"><a href=\"link4.html\">fourth item</a></li>\n    <li class=\"item-0\"><a href=\"link5.html\">fifth item</a></li>\n  </ul>\n</div>\n```\n\n```python\nfrom lxml import etree\n\n# 读取HTML文件\nhtml = etree.parse('hello.html')\nresult = etree.tostring(html, pretty_print=True)\n\n# 输出结果和之前相同\nprint(result)\n```\n\n### 在lxml中使用XPath语法\n\n* 获取所有li标签\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\nprint(type(html)) # 显示 etree.parse() 返回类型\n\nresult = html.xpath('//li')\n\nprint(result) # 打印 <li> 标签的元素集合\n```\n\n* 获取所有li元素下的所有class属性的值\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li/@class')\n\nprint(result)\n```\n\n* 获取所有li标签下href为link1.html的a标签\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li/a[@href=\"link1.html\"]')\n\nprint(result)\n```\n\n* 获取li标签下所有span标签\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li//span')\n# //li/span 是不对的，因为 / 是用来获取子元素的，span 并不是 li 的子元素，所有要用双斜杠\n\nprint(result)\n```\n\n* 获取li标签下的a标签里的所有class\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li/a//@class')\n\nprint(result)\n```\n\n* 获取最后一个li的a的href属性对应的值\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li[last()]/a/@href')\n\nprint(result)\n```\n\n* 获取倒数第二个li元素的内容\n\n```python\nfrom lxml import etree\n\nhtml = etree.parse('hello.html')\n\nresult = html.xpath('//li[last()-1]/a')\n# result = html.xpath('//li[last()-1]/a/text()')\n\nprint(result)\n```\n\n#### 案例：使用requests和xpath爬取电影天堂\n\n```python\nfrom lxml import etree\nimport requests\n\nBASE_DOMAIN = 'https://www.dytt8.net'\n\nHEADERS = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n}\n\ndef get_detail_urls(url):\n    response = requests.get(url, headers=HEADERS)\n\n    text = response.text\n    html = etree.HTML(text)\n\n    detail_urls = html.xpath(\"//table[@class='tbspan']//a/@href\")\n    detail_urls = map(lambda url: BASE_DOMAIN + url, detail_urls)\n\n    return detail_urls\n\ndef parse_detail_page(url):\n    movie = {}\n\n    response = requests.get(url, headers=HEADERS)\n    text = response.content.decode('gbk')\n\n    html = etree.HTML(text)\n\n    def parse_info(info, rule):\n        return info.replace(rule, \"\").strip()\n\n    title = html.xpath(\"//div[@class='title_all']//font[@color='#07519a']/text()\")[0]\n    movie['title'] = title\n\n    zoomE = html.xpath(\"//div[@id='Zoom']\")[0]\n    imgs = zoomE.xpath(\".//img/@src\")\n    cover = imgs[0]\n    screenshot = imgs[1]\n    movie['cover'] = cover\n    movie['screenshot'] = screenshot\n\n    infos = zoomE.xpath(\".//text()\")\n    for index, info in enumerate(infos):\n        if info.startswith('◎年　　代'):\n            info = parse_info(info, '◎年　　代')\n            movie[\"year\"] = info\n        elif info.startswith('◎产　　地'):\n            info = parse_info(info, '◎产　　地')\n            movie[\"country\"] = info\n        elif info.startswith('◎类　　别'):\n            info = parse_info(info, '◎类　　别')\n            movie[\"category\"] = info\n        elif info.startswith('◎豆瓣评分'):\n            info = parse_info(info, '◎豆瓣评分')\n            movie[\"rating\"] = info\n        elif info.startswith('◎片　　长'):\n            info = parse_info(info, '◎片　　长')\n            movie[\"duration\"] = info\n        elif info.startswith('◎导　　演'):\n            info = parse_info(info, '◎导　　演')\n            movie[\"director\"] = info\n        elif info.startswith('◎主　　演'):\n            info = parse_info(info, '◎主　　演')\n            actors = [info]\n            for x in range(index+1, len(infos)):\n                actor = infos[x].strip()\n                if actor.startswith('◎'):\n                    break\n                actors.append(actor)\n            movie[\"actors\"] = actors\n        elif info.startswith('◎简　　介 '):\n            info = parse_info(info, '◎简　　介')\n            for x in range(index+1, len(infos)):\n                profile = infos[x].strip()\n                movie[\"profile\"] = profile\n\n    download_url = html.xpath(\"//td[@bgcolor='#fdfddf']/a/@href\")[0]\n    movie[\"download_url\"] = download_url\n    return movie\n\ndef spider():\n    base_url = 'https://www.dytt8.net/html/gndy/dyzz/list_23_{}.html'\n    for x in range(1, 3):\n        url = base_url.format(x)\n        detail_urls = get_detail_urls(url)\n        for detial_url in detail_urls:\n            movie = parse_detail_page(detial_url)\n            print(movie)\n\nif __name__ == \"__main__\":\n    spider()\n```\n",
    "category": "Python",
    "tag": [
      "requests",
      "数据提取",
      "lxml",
      "etree"
    ],
    "createdAt": "2019-07-05 23:18:05"
  },
  {
    "title": "BeautifulSoup库",
    "author": "阿星Plus",
    "url": "2019-07-06-beautifulsoup",
    "markdown": "### BeautifulSoup\n\n- 和 lxml 一样，Beautiful Soup 也是一个 HTML/XML 的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。\n- lxml 只会局部遍历，而 Beautiful Soup 是基于 HTML DOM（Document Object Model）的，会载入整个文档，解析整个 DOM 树，因此时间和内存开销都会大很多，所以- 性能要低于 lxml。\n- BeautifulSoup 用来解析 HTML 比较简单，API 非常人性化，支持 CSS 选择器、Python 标准库中的 HTML 解析器，也支持 lxml 的 XML 解析器。\n- Beautiful Soup 3 目前已经停止开发，推荐现在的项目使用 Beautiful Soup 4。\n- 安装命令：pip install pip install bs4\n- 中文文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\n\n### Python 中的解析工具\n\n| 解析工具      | 解析速度 | 使用难度 |\n| :------------ | :------- | :------- |\n| BeautifulSoup | 最慢     | 最简单   |\n| lxml          | 快       | 简单     |\n| 正则表达式    | 最快     | 最难     |\n\n### 简单使用\n\n```python\nfrom bs4 import BeautifulSoup\n\nhtml = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n\"\"\"\n\n# 创建 BeautifulSoup 对象，使用lxml解析\nsoup = BeautifulSoup(html,'lxml')\n\nprint(soup.prettify())\n```\n\n### 四个常用的对象\n\nBeautifulSoup将复杂的HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：Tag、NavigatableString、BeautifulSoup、Comment\n\n#### Tag\n\nTag其实就是HTML中的标签\n\n```python\nfrom bs4 import BeautifulSoup\n\nhtml = \"\"\"\n    <html><head><title>The Dormouse's story</title></head>\n    <body>\n    <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n    <p class=\"story\">Once upon a time there were three little sisters; and their names were\n    <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n    <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n    <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n    and they lived at the bottom of a well.</p>\n    <p class=\"story\">...</p>\n\"\"\"\n\n# 创建 BeautifulSoup 对象\nsoup = BeautifulSoup(html, 'lxml')\n\nprint(soup.title)\n# <title>The Dormouse's story</title>\n\nprint(soup.head)\n# <head><title>The Dormouse's story</title></head>\n\nprint(soup.a)\n# <a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"><!-- Elsie --></a>\n\nprint(soup.p)\n# <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n\nprint(type(soup.p))\n# <class 'bs4.element.Tag'>\n```\n\n可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是 bs4.element.Tag，查找的是所有内容中的第一个符合要求的标签。对于Tag，他有两个重要的属性，分别是 name 和 attrs\n\n```python\nprint(soup.name)\n# [document]\n#soup 对象本身比较特殊，它的 name 即为 [document]\n\nprint(soup.head.name)\n# head\n#对于其他内部标签，输出的值便为标签本身的名称\n\nprint(soup.p.attrs)\n# {'class': ['title'], 'name': 'dromouse'}\n# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。\n\nprint(soup.p['class'])\nprint(soup.p.get('class'))\n# ['title']\n#还可以利用get方法，传入属性的名称，二者是等价的\n\n# 可以对这些属性和内容等等进行修改\nsoup.p['class'] = \"newClass\"\nprint(soup.p ) # <p class=\"newClass\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n```\n\n#### NavigableString\n\n如果拿到标签后，还想获取标签中的的内容，那么可以通过 tag.string 获取标签中的文本内容\n\n```python\nprint(soup.p.string)\n# The Dormouse's story\n\nprint(type(soup.p.string))\n# <class 'bs4.element.NavigableString'>\n```\n\n#### BeautifulSoup\n\nBeautifulSoup 对象表示的是一个文档的全部内容，大部分时候可以把它当做Tag对象，它支持 遍历文档数 和 搜索文档数 中描述的大部分方法。\n\n因为BeautifulSoup 对象并不是真正的HTML或XML的Tag，所以他没有name和attribute属性，但查看它的 ```.name``` 属性是很方便的，BeautifulSoup 对象包含了一个值为 ```[document]``` 的特殊属性 ```.name```\n\n```python\nprint(soup.name)\n# '[document]'\n```\n\n#### Comment\n\nTag , NavigableString , BeautifulSoup 几乎覆盖了HTML和XML中的所有内容，但是还有一些特殊对象，注释。\n\n```python\nmarkup = \"<b><!--Hey, buddy. Want to buy a used parser?--></b>\"\nsoup = BeautifulSoup(markup)\ncomment = soup.b.string\ntype(comment)\n# <class 'bs4.element.Comment'>\n```\n\nComment 对象是一个特殊类型的 NavigableString 对象\n\n```python\ncomment\n# 'Hey, buddy. Want to buy a used parser'\n```\n\n### 遍历文档树\n\n#### contents和children\n\n```python\nfrom bs4 import BeautifulSoup\nhtml_doc = \"\"\"\n<html><head><title>The Dormouse's story</title></head>\n\n<p class=\"title\"><b>The Dormouse's story</b></p>\n\n<p class=\"story\">Once upon a time there were three little sisters; and their names were\n<a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie</a>,\n<a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n<a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class=\"story\">...</p>\n\"\"\"\nsoup = BeautifulSoup(html_doc, 'lxml')\n\nhead_tag = soup.head\n\n# <head><title>The Dormouse's story</title></head>\nprint(head_tag)\n\n# 返回所有子节点的迭代器\nfor child in head_tag.children:\n    print(child)\n```\n\n#### strings和stripped_strings\n\n如果tag中包含多个字符串，可以使用 strings 来循环获取\n\n```python\nfor string in soup.strings:\n    print(repr(string))\n    # \"The Dormouse's story\"\n    # '\\n'\n    # \"The Dormouse's story\"\n    # '\\n'\n    # 'Once upon a time there were three little sisters; and their names were\\n'\n    # 'Elsie'\n    # ',\\n'\n    # 'Lacie'\n    # ' and\\n'\n    # 'Tillie'\n    # ';\\nand they lived at the bottom of a well.'\n    # '\\n'\n    # '...'\n    # '\\n'\n```\n\n输出的字符串中可能包含了很多空格和空白字符，使用 ```stripped_strings``` 可以去除多余空白内容\n\n```python\nfor string in soup.stripped_strings:\n    print(repr(string))\n    # \"The Dormouse's story\"\n    # \"The Dormouse's story\"\n    # 'Once upon a time there were three little sisters; and their names were'\n    # 'Elsie'\n    # ','\n    # 'Lacie'\n    # 'and'\n    # 'Tillie'\n    # ';\\nand they lived at the bottom of a well.'\n    # '...'\n```\n\n### 搜索文档树\n\n#### find和find_all\n\n- 搜索文档树，用的比较多的是 ```find``` 和 ```find_all```\n- ```find``` 方法是找到第一个满足条件的标签后就立即返回，只返回一个元素\n- ```find_all``` 方法是把所有满足条件的标签都返回\n\n```python\nsoup.find_all('a', attrs={'id': 'link2'})\n```\n\n或者是直接传入属性的名字作为关键字参数\n\n```python\nsoup.find_all('a', id='link2')\n```\n\n#### select\n\n使用以上方法可以方便的找出元素，但有时候使用css选择器的方式可以更加的方便，应该使用select方法。\n\n##### 通过标签名查找\n\n```python\nprint(soup.select('a'))\n```\n\n##### 通过类名查找\n\n通过类名，应该在类的前面加一个 ```.``` ，比如要查找 class='sister' 的标签\n\n```python\nprint(soup.select('.sister'))\n```\n\n##### 通过id查找\n\n通过id查找，应该在id的名字前面加一个 ```#```\n\n```python\nprint(soup.select('#link1'))\n```\n\n##### 组合查找\n\n组合查找即和写class文件时，标签名与类名、id名进行组合原理是一样的，例如查找p标签中，id='link1'的内容\n\n```python\nprint(soup.select('p #link1'))\n\n```\n\n直接子标签查找，则使用 ```>``` 分割\n\n```python\nprint(soup.select('head > title'))\n```\n\n##### 通过属性查找\n\n查找时还可以加入属性元素，属性需要用中括号括起来，属性和标签属于同一个节点，所以中间不能加空格，否则会无法匹配到\n\n```python\nprint(soup.select('a[href=\"http://example.com/elsie\"]'))\n```\n\n##### 获取内容\n\n以上的select方法返回的结果都是列表形式，可以用遍历的形式输出，然后用 ```get_text()``` 方法来获取它的内容\n\n```python\nsoup = BeautifulSoup(html, 'lxml')\nprint(type(soup.select('title')))\nprint(soup.select('title')[0].get_text())\n\nfor title in soup.select('title'):\n    print(title.get_text())\n```\n",
    "category": "Python",
    "tag": [
      "数据提取",
      "BeautifulSoup"
    ],
    "createdAt": "2019-07-06 19:20:06"
  },
  {
    "title": "Python中的正则表达式",
    "author": "阿星Plus",
    "url": "2019-07-07-regex",
    "markdown": "### 什么是正则表达式\n\n> 世界上分为两种人，一种是懂正则表达式的，一种是不懂正则表达式的\n\n按照一定的规则，从某个字符串中匹配出想要的数据，这个规则就是正则表达式\n\n### 正则表达式常用的匹配规则\n\n#### 匹配某个字符串\n\n```python\ntext = 'hello'\nret = re.match('he', text)\nprint(ret.group())\n# >> he\n```\n\n#### 点(```.```) 匹配任意的字符串\n\n```python\ntext = 'ab'\nret = re.match('.', text)\nprint(ret.group())\n# >> a\n```\n\n#### ```\\d``` 匹配任意的数字\n\n```python\ntext = '123'\nret = re.match('\\d', text)\nprint(ret.group())\n# >> 1\n```\n\n#### ```\\D``` 匹配任意的非数字\n\n```python\ntext = \"a\"\nret = re.match('\\D',text)\nprint(ret.group())\n# >> a\n```\n\n如果text为一个数字，那么就匹配不成功了\n\n```python\ntext = \"1\"\nret = re.match('\\D',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute 'group'\n```\n\n#### ```\\s``` 匹配的是空白字符串(包括：\\n，\\t，\\r，空格)\n\n```python\ntext = \"\\t\"\nret = re.match('\\s',text)\nprint(ret.group())\n# >> 此处是一个空白\n```\n\n#### ```\\w``` 匹配的是 a-z 和 A-Z 以及数字和下划线\n\n```python\ntext = \"_\"\nret = re.match('\\w',text)\nprint(ret.group())\n# >> _\n```\n\n如果要匹配一个其他的字符，那么就匹配不到\n\n```python\ntext = \"+\"\nret = re.match('\\w',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n#### ```\\W``` 匹配的是和 ```\\w``` 相反的\n\n```python\ntext = \"+\"\nret = re.match('\\W',text)\nprint(ret.group())\n# >> +\n```\n\n如果你的text是一个下划线或者英文字符，那么就匹配不到了\n\n```python\ntext = \"_\"\nret = re.match('\\W',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n#### ```[]``` 组合的方式，只要满足中括号中的某一项都算匹配成功\n\n```python\ntext = \"027-88888888\"\nret = re.match('[\\d\\-]+',text)\nprint(ret.group())\n# >> 027-88888888\n```\n\n其实可以使用中括号代替几种默认的匹配规则\n\n- ```\\d``` ：[0-9]\n- ```\\D``` ：0-9\n- ```\\w``` ：[0-9a-zA-Z_]\n- ```\\W``` ：[^0-9a-zA-Z_]\n\n#### 匹配多个字符\n\n##### ```*```：可以匹配0或者任意多个字符\n\n```python\ntext = '8888'\nret = re.match('\\d*',text)\nprint(ret.group())\n# >> 8888\n```\n\n以上因为匹配的要求是 ```\\d``` ，那么就要求是数字，后面跟了一个星号，就可以匹配到8888这四个字符\n\n##### ```+```：可以匹配1个或者多个字符，最少一个\n\n```python\ntext = \"abc\"\nret = re.match('\\w+',text)\nprint(ret.group())\n# >> abc\n```\n\n因为匹配的是```\\w``` ，那么就要求是英文字符，后面跟了一个加号，意味着最少要有一个满足 ```\\w``` 的字符才能够匹配到。如果text是一个空白字符或者是一个不满足```\\w```的字符，就会报错\n\n```python\ntext = \"\"\nret = re.match('\\w+',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n##### ```?```：匹配的字符可以出现一次或者不出现(0或者1)\n\n```python\ntext = \"123\"\nret = re.match('\\d?',text)\nprint(ret.group())\n# >> 1\n```\n\n##### ```{m}```：匹配m个字符\n\n```python\ntext = \"123\"\nret = re.match('\\d{2}',text)\nprint(ret.group())\n# >> 12\n```\n\n##### ```{m,n}```：匹配 m-n 个字符，在这中间的字符都可以匹配到\n\n```python\ntext = \"123\"\nret = re.match('\\d{1,2}',text)\nprit(ret.group())\n# >> 12\n```\n\n如果text只有一个字符，也可以匹配出来\n\n```python\ntext = \"1\"\nret = re.match('\\d{1,2}',text)\nprit(ret.group())\n# >> 1\n```\n\n\n#### 几个实际的案例(以给出的文本为例)\n\n- 验证手机号码：手机号码的规则是以1开头，第二位可以是34587，后面那9位就可以随意了\n\n```python\ntext = \"18570631587\"\nret = re.match('1[34587]\\d{9}',text)\nprint(ret.group())\n# >> 18570631587\n```\n\n- 如果是个不满足条件的手机号码。那么就匹配不到了\n\n```python\ntext = \"1857063158\"\nret = re.match('1[34587]\\d{9}',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute\n```\n\n- 验证邮箱：邮箱的规则是邮箱名称是用数字、数字、下划线组成的，然后是@符号，后面就是域名了\n\n```python\ntext = \"hynever@163.com\"\nret = re.match('\\w+@\\w+\\.[a-zA-Z\\.]+',text)\nprint(ret.group())\n```\n\n- 验证URL：URL的规则是前面是http或者https或者是ftp然后再加上一个冒号，再加上一个斜杠，再后面就是可以出现任意非空白字符了\n\n```python\ntext = \"http://www.baidu.com/\"\nret = re.match('(http|https|ftp)://[^\\s]+',text)\nprint(ret.group())\n```\n\n- 验证身份证：身份证的规则是，总共有18位，前面17位都是数字，后面一位可以是数字，也可以是小写的x，也可以是大写的X\n\n```python\ntext = \"3113111890812323X\"\nret = re.match('\\d{17}[\\dxX]',text)\nprint(ret.group())\n```\n\n#### ```^```：表示以...开始\n\n```python\ntext = \"hello\"\nret = re.match('^h',text)\nprint(ret.group())\n```\n\n如果是在中括号中，代表的是取反操作\n\n#### ```$```：表示以...结束\n\n```python\n# 匹配163.com的邮箱\ntext = \"xxx@163.com\"\nret = re.search('\\w+@163\\.com$',text)\nprint(ret.group())\n# >> xxx@163.com\n```\n\n#### ```|```：匹配多个表达式或者字符串\n\n```python\ntext = \"hello|world\"\nret = re.search('hello',text)\nprint(ret.group())\n# >> hello\n```\n\n#### 贪婪模式和非贪婪模式\n\n- 贪婪模式：正则表达式会匹配尽量多的字符，默认是贪婪模式。\n- 非贪婪模式：正则表达式会尽量少的匹配字符。\n\n```python\ntext = \"0123456\"\nret = re.match('\\d+',text)\nprint(ret.group())\n# 因为默认采用贪婪模式，所以会输出0123456\n```\n\n可以改成非贪婪模式，就只会匹配到0\n\n```python\ntext = \"0123456\"\nret = re.match('\\d+?',text)\nprint(ret.group())\n```\n\n#### 匹配0-100之间的数字\n\n```python\ntext = '99'\nret = re.match('[1-9]?\\d$|100$',text)\nprint(ret.group())\n```\n\n如果text=101，就会抛出一个异常\n\n```python\ntext = '101'\nret = re.match('[1-9]?\\d$|100$',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute 'group'\n```\n\n#### 转义字符和原生字符\n\n在正则表达式中，有些字符是有特殊意义的字符，在 Python 中 ```\\``` 也是用来转义的，因此如果想要在普通的字符串中匹配 ```\\``` ，那么就要给出 四个 ```\\```\n\n```python\ntext = \"apple \\c\"\nret = re.search('\\\\\\\\c',text)\nprint(ret.group())\n```\n\n所以要使用原生字符就可以解决这个问题\n\n```python\ntext = \"apple \\c\"\nret = re.search(r'\\\\c',text)\nprint(ret.group())\n```\n",
    "category": "Python",
    "tag": [
      "数据提取",
      "Regex"
    ],
    "createdAt": "2019-07-07 20:21:07"
  },
  {
    "title": "re模块",
    "author": "阿星Plus",
    "url": "2019-07-08-python-re",
    "markdown": "### match\n\n从开始的位置进行匹配，如果开始的位置没有匹配到，就直接匹配失败\n\n```python\ntext = 'hello'\nret = re.match('h', text)\nprint(ret.group())\n# >> h\n```\n\n如果第一个字母不是h，那么就会失败\n\n```python\ntext = 'ahello'\nret = re.match('h',text)\nprint(ret.group())\n# >> AttributeError: 'NoneType' object has no attribute 'group'\n```\n\n如果想要匹配换行的数据，那么就要传入一个 ```flag=re.DOTALL``` ，就可以匹配换行符了\n\n```python\ntext = \"abc\\nabc\"\nret = re.match('abc.*abc',text,re.DOTALL)\nprint(ret.group())\n```\n\n### search\n\n在字符串中找满足条件的字符，如果找到，就返回，就是只会找到第一个满足条件的\n\n```python\ntext = 'apple price $99 orange price $88'\nret = re.search('\\d+',text)\nprint(ret.group())\n# >> 99\n```\n\n### group\n\n在正则表达式中，可以对过滤到的字符串进行分组，分组要使用圆括号的方式\n\n- group：和 group(0) 是等价的，返回的是整个满足条件的字符串\n- groups：返回的是里面的子组，索引从1开始\n- group(1)：返回的是第一个子组，可以传入多个\n\n```python\ntext = \"apple price is $99,orange price is $10\"\nret = re.search(r\".*(\\$\\d+).*(\\$\\d+)\",text)\nprint(ret.group())\nprint(ret.group(0))\nprint(ret.group(1))\nprint(ret.group(2))\nprint(ret.groups())\n```\n\n### findall\n\n找到所有满足条件的，返回的是一个列表\n\n```python\ntext = 'apple price $99 orange price $88'\nret = re.findall('\\d+',text)\nprint(ret)\n# >> ['99', '88']\n```\n\n### sub\n\n用来替换字符串，将匹配到的字符串替换为其他字符串\n\n```python\ntext = 'apple price $99 orange price $88'\nret = re.sub('\\d+','0',text)\nprint(ret)\n# >> apple price $0 orange price $0\n```\n\n### split\n\n使用正则表达式来分割字符串\n\n```python\ntext = \"hello world ni hao\"\nret = re.split('\\W',text)\nprint(ret)\n# >> [\"hello\",\"world\",\"ni\",\"hao\"]\n```\n\n### compile\n\n对于一些经常要用到的正则表达式，可以使用 compile 进行编译，后期再使用的时候可以直接拿来使用，执行效率会更快。而且compile还可以指定 ```flag=re.VERBOSE``` ，在写正则表达式的时候可以做好注释\n\n```python\ntext = \"the number is 20.50\"\nr = re.compile(r\"\"\"\n                \\d+ # 小数点前面的数字\n                \\.? # 小数点\n                \\d* # 小数点后面的数字\n                \"\"\",re.VERBOSE)\nret = re.search(r,text)\nprint(ret.group())\n```\n",
    "category": "Python",
    "tag": [
      "数据提取",
      "Regex"
    ],
    "createdAt": "2019-07-08 21:33:08"
  },
  {
    "title": "json文件处理",
    "author": "阿星Plus",
    "url": "2019-07-09-json",
    "markdown": "### 什么是json\n\nJSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n### json支持的数据格式\n\n- 对象(字典)，使用花括号\n- 数组(列表)，使用方括号\n- 整型、浮点型、布尔型、NULL类型\n- 字符串类型(字符串必须要用双引号，不能用单引号)\n- 多个数据之间使用逗号分开\n- json本质上还是一个字符串\n\n### 字典和列表转json\n\n```python\nimport json\n\nbooks = {\n    {\n        'title': '钢铁是怎样练成的',\n        'price': 9.8\n    },\n    {\n        'title': '红楼梦',\n        'price': 9.9\n    }\n}\n\njson_str = json.dumps(books, ensure_ascii=False)\nprint(json_str)\n```\n\n- 因为json在dump的时候，只能存放ascii的字符，因为会将中文进行转义，这时候我们可以使用 ```ensure_ascii=False``` 关闭这个特性。\n- 在python中，只有基本数据类型才能转换成json格式的字符串，int、float、str、list、dict、tuple\n\n### 将json数据直接dump到文件中\n\njson模块中除了dumps函数，还有一个dump函数，这个函数可以传入一个文件指针，直接将字符串dump到文件中\n\n```python\nimport json\n\nbooks = {\n    {\n        'title': '钢铁是怎样练成的',\n        'price': 9.8\n    },\n    {\n        'title': '红楼梦',\n        'price': 9.9\n    }\n}\n\nwith open('books.json', 'w') as fp:\n    json.dump(books, fp)\n```\n\n### 将一个json字符串load成python对象\n\n```python\nimport json\n\njson_str = '[{\"title\": \"钢铁是怎样练成的\", \"price\": 9.8}, {\"title\": \"红楼梦\", \"price\": 9.9}]'\n\nbooks = json.loads(json_str, encoding='utf-8')\nprint(type(books)) # <class 'list'>\nprint(books)\n```\n\n### 直接从文件中读取json数据\n\n```python\nimport json\n\nwith open('books.json','r',encoding='utf-8') as fp:\n    json_str = json.load(fp)\n    print(json_str)\n```\n",
    "category": "Python",
    "tag": [
      "数据存储",
      "json"
    ],
    "createdAt": "2019-07-09 22:44:09"
  },
  {
    "title": "csv文件处理",
    "author": "阿星Plus",
    "url": "2019-07-10-csv",
    "markdown": "### 读取csv文件\n\n```python\nimport csv\n\nwith open('demo.csv', 'r') as fp:\n    reader = csv.reader(fp)\n    titles = next(reader)\n    for x in reader:\n        print(x)\n```\n\n这样操作以后获取数据的时候，就要通过下标来获取数据。如果想要在获取数据的时候通过标题来获取，那么就可以使用 DictReader\n\n```python\nimport csv\n\nwith open('demo.csv', 'r') as fp:\n    reader = csv.DictReader(fp)\n    for x in reader:\n        print(x['title'])\n```\n\n### 写入数据到csv文件\n\n写入数据到csv文件，需要创建一个write对象，主要用到两个方法，一个是writerow写入一行，一个是writerows写入多行\n\n```python\nimport csv\n\nheaders = ['name','age','classroom']\nvalues = [\n    ('aaa',18,'111'),\n    ('bbb',19,'222'),\n    ('ccc',20,'333')\n]\n\nwith open('class.csv', 'w', newline='') as fp:\n    writer = csv.writer(fp)\n    writer.writerow(headers)\n    writer.writerows(values)\n```\n\n也可以使用字典的方式把数据写入进去，这是需要使用DictWriter\n\n```python\nimport csv\n\nheaders = ['name','age','classroom']\nvalues = [\n    {'name':'aaa','age':18,'classroom':'111'},\n    {'name':'bbb','age':19,'classroom':'222'}\n]\n\nwith open('class.csv', 'w', newline='') as fp:\n    writer = csv.DictWriter(fp,headers)\n    writer = csv.writeheader()\n    writer.writerow({'name':'ccc','age':20,'classroom':'333'})\n    writer.writerows(values)\n```\n",
    "category": "Python",
    "tag": [
      "数据存储",
      "csv"
    ],
    "createdAt": "2019-07-10 23:10:10"
  },
  {
    "title": "Python操作MySQL数据库",
    "author": "阿星Plus",
    "url": "2019-07-11-pymysql",
    "markdown": "### Windows下安装MySQL\n\n详细可参考 [Windows下MySQL安装流程，8.0以上版本ROOT密码报错及修改](/mysql/mysql-install.md)\n\n### 安装驱动程序\n\npython想要操作MySQL，必须要有一个中间件，或者叫做驱动程序，驱动程序有很多，mysqlclient、mysqldb、pymysql。我选择用pymysql，安装命令：```pip install pymysql```\n\n### 连接数据库\n\n```python\nimport pymysql\n\ndb = pymysql.connect(\n    host=\"127.0.0.1\",\n    user='root',\n    password='123456',\n    database='pymysql_test',\n    port=3306\n)\n\ncursor = db.cursor()\ncursor.execute('select 1')\n\ndata = cursor.fetchone()\nprint(data)\n\ndb.close()\n```\n\n### 插入数据\n\n```python\nimport pymysql\n\ndb = pymysql.connect(\n    host=\"127.0.0.1\",\n    user='root',\n    password='123456',\n    database='pymysql_test',\n    port=3306\n)\n\ncursor = db.cursor()\n\nsql = \"\"\"\n    insert into user(id,username,gender,age,password) values(null,'abc',1,18,'111111');\n\"\"\"\n\ncursor.execute(sql)\ndb.commit()\ndb.close()\n```\n\n将数据作为参数的方式插入到数据库\n\n```python\nsql = \"\"\"\n    insert into user(id,username,gender,age,password) values(null,%s,%s,%s,%s);\n\"\"\"\n\ncursor.execute(sql,('spider',1,20,'222222'))\n```\n\n### 查找数据\n\n使用pymysql查询数据，可以使用 fetch 方法\n\n- fetchone()：这个方法每次只获取一条数据\n- fetchall()：这个方法接收全部的返回结果\n- fetchmany(size)：这个方法可以获取指定条数的数据\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    select * from user\n\"\"\"\n\ncursor.execute(sql)\nwhile True:\n    result = cursor.fetchone()\n    if not result:\n        break\n    print(result)\n\ndb.close()\n```\n\n直接使用fetchall，一次性可以把所有满足条件的数据都取出来\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    select * from user\n\"\"\"\n\ncursor.execute(sql)\nresults = cursor.fetchall()\nfor result in results:\n    print(result)\n\ndb.close()\n```\n\n使用fetchmany，指定获取多少条数据\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    select * from user\n\"\"\"\n\ncursor.execute(sql)\nresults = cursor.fetchmany(1)\nfor result in results:\n    print(result)\n\ndb.close()\n```\n\n### 删除数据\n\n```python\ncursor = db.cursor()\n\nsql = \"\"\"\n    delete from user where id=1\n\"\"\"\n\ncursor.execute(sql)\ndb.commit()\n\ndb.close()\n```\n\n### 更新数据\n\n```python\nconn = pymysql.connect(\n    host=\"127.0.0.1\",\n    user='root',\n    password='123456',\n    database='pymysql_test',\n    port=3306\n)\n\nsql = \"\"\"\n    update user set username='aaa' where id=1\n\"\"\"\ncursor.execute(sql)\nconn.commit()\n\nconn.close()\n```\n",
    "category": "Python",
    "tag": [
      "数据存储",
      "MySQL"
    ],
    "createdAt": "2019-07-11 19:30:11"
  },
  {
    "title": "Python操作MongoDB数据库",
    "author": "阿星Plus",
    "url": "2019-07-12-pymongo",
    "markdown": "### MongoDB 原生语句\n\n[MongoDB Shell 命令](/mongodb/mongodb.md)\n\n### 安装pymongo\n\n```pip install pymongo```\n\n### Python连接MongoDB\n\n```python\nimport pymongo\n\n# mobgodb连接对象\nclient = pymongo.MongoClient('localhost', port=27017)\n\n# 获取数据库, 可以不用创建数据库\ndb = client.zhihu\n\n# 获取数据库中的集合\ncollection = db.qa\n\n# insert_one 写入数据\ncollection.insert_one({\n    \"username\":\"aaa\",\n    \"password\":'123456'\n})\n\n# insert_many 写入多条数据\ncollection.insert_many([\n    {\n        \"username\":\"aaa\",\n        \"age\":18\n    },\n    {\n        \"username\":\"bbb\",\n        \"age\":20\n    }\n])\n\n# find 查找所有数据\ncursor = collection.find()\nfor x in cursor:\n    print(x)\n\n# find_one 获取一条数据\nresult = collection.find_one()\nprint(result)\n# 添加查询条件\nresult = collection.find_one({\"age\":18})\nprint(result)\n\n# 更新数据\ncollection.update_one({\"username\":\"bbb\"},{\"$set\":{\"username\":\"spider\"}})\n\n# 更新多条数据\ncollection.update_many({\"username\":\"aaa\"},{\"$set\":{\"username\":\"spider\"}})\n\n# 删除一条数据\ncollection.delete_one({\"age\":18})\n\n# 删除多条数据\ncollection.delete_many({\"username\":'spider'})\n```\n",
    "category": "Python",
    "tag": [
      "数据存储",
      "MongoDB"
    ],
    "createdAt": "2019-07-12 20:40:12"
  },
  {
    "title": "多线程爬虫",
    "author": "阿星Plus",
    "url": "2019-07-13-multithreading",
    "markdown": "有些时候，比如下载图片，是一个比较耗时的操作，如果采用同步的方式去下载，效率肯定会特别慢，这时候我们就可以考虑使用多线程的方式来下载图片\n\n### 多线程介绍\n\n- 多线程是为了同步完成多项任务，通过提高资源使用效率来进一步提高系统的效率\n- 线程是在同一时间需要完成多项任务的时候实现的\n- 最简单的比喻，多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，火车可以有多节车厢\n- 多线程的出现就是为了提高效率……\n\n### threading模块\n\nthreading模块是python中专门提供用来做多线程编程的模块，threading模块中最常用的类是Thread\n\n```python\nimport threading\nimport time\n\ndef coding():\n    for x in range(3):\n        print(\"coding %s\" % x)\n        time.sleep(1)\n\ndef drawing():\n    for x in range(3):\n        print(\"drawing %s\" % x)\n        time.sleep(1)\n\ndef single_thread():\n    coding()\n    drawing()\n\ndef multi_thread():\n    t1 = threading.Thread(target=coding)\n    t2 = threading.Thread(target=drawing)\n\n    t1.start()\n    t2.start()\n\nif __name__ == \"__main__\":\n    multi_thread()\n```\n\n### 查看线程函数\n\n使用 ```threading.enumerate()``` 函数可以看到当前线程的数量\n\n### 查看当前线程的名字\n\n使用 ```threading.current_thread()``` 可以看到当前线程的信息\n\n### 继承自 threading.Thread 类\n\n为了让线程代码更好的封装，可以使用 threading 模块下的 Thread 类，继承自这个类然后实现 run  方法，线程就会自动运行 run 方法中的代码\n\n```python\nimport threading\nimport time\n\nclass CodingThread(threading.Thread):\n    def run(self):\n        for x in range(3):\n            print(\"coding %s\" % threading.current_thread())\n            time.sleep(1)\n\nclass DrawingThread(threading.Thread):\n    def run(self):\n        for x in range(3):\n            print(\"drawing %s\" % threading.current_thread())\n            time.sleep(1)\n\ndef multi_thread():\n    t1 = CodingThread()\n    t2 = DrawingThread()\n\n    t1.start()\n    t2.start()\n\nif __name__ == \"__main__\":\n    multi_thread()\n```\n\n### 多线程共享全局变量的问题\n\n多线程都是在同一个进程中运行的，因此在进程中的全局变量所有线程都是可以共享的，这就会造成一个问题，因为线程执行的顺序是无序的，有可能就会导致数据错误，比如下面代码\n\n```python\nimport threading\n\nVALUE = 0\n\ndef add_value():\n    global VALUE\n    for x in range(1000000):\n        VALUE += 1\n    print(VALUE)\n\ndef main():\n    for x in range(2):\n        t = threading.Thread(target=add_value)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n以上代码结果正常来讲应该是2000000，但是因为多线程运行的不确定性，因此最后的结果可能是随机的，于是我们可以使用锁机制解决这个问题\n\n### 锁机制\n\n为了解决以上使用共享全局变量的问题，threading 提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，知道当前线程处理完成后，把锁释放，其他线程才能进来处理\n\n```python\nimport threading\n\nVALUE = 0\n\nlock =  threading.Lock()\n\ndef add_value():\n    global VALUE\n    lock.acquire()\n    for x in range(1000000):\n        VALUE += 1\n    lock.release()\n    \n    print(VALUE)\n\ndef main():\n    for x in range(2):\n        t = threading.Thread(target=add_value)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Lock 版生产者和消费者模式\n\n生产者和消费者模式是多线程开发中经常遇见的一种模式，生产者的线程专门用来生产数据，然后放到中间变量中，消费者再从这个中间的变量中取出数据进行消费，但是因为要使用中间变量，中间变量经常是全局变量，因为需要用锁来保证数据的完整性。\n\n使用 ```threading.Lock``` 锁实现 生产者和消费者模式例子\n\n```python\nimport threading\nimport time\nimport random\n\ngMoney = 1000\ngLock = threading.Lock()\ngTotalTimes = 10\ngTimes = 0\n\nclass Producer(threading.Thread):\n    def run(self):\n        global gMoney\n        global gTimes\n        while True:\n            money = random.randint(100, 1000)\n            gLock.acquire()\n            if gTimes >= gTotalTimes:\n                gLock.release()\n                break\n            gMoney += money\n            print('%s 生产了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            gTimes += 1\n            gLock.release()\n            time.sleep(0.5)\n\nclass Consumer(threading.Thread):\n    def run(self):\n        global gMoney\n        while True:\n            money = random.randint(100, 1000)\n            gLock.acquire()\n            if gMoney >= money:\n                gMoney -= money\n                print('%s消费者消费了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            else:\n                if gTimes >= gTotalTimes:\n                    gLock.release()\n                    break\n                print('%s消费者准备消费%d元钱，剩余%d元钱，不足！' % (threading.current_thread(), money, gMoney))\n            gLock.release()\n            time.sleep(0.5)\n\ndef main():\n    for x in range(3):\n        t = Consumer(name='消费者线程%d' % x)\n        t.start()\n\n    for x in range(5):\n        t = Producer(name='生产者线程%d' % x)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Condition 版生产者与消费者模式\n\n就上面的例子，Lock版本的生产者与消费者模式可以正常的运行，但是存在一些不足，在消费者中总是通过 while-True 死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源行为，因为这种方式不是最好的解决方法，还有一种更好的方式就是使用 ```threading.Condition``` 来实现\n\n```threading.Condition``` 可以在没有数据的时候处于阻塞等待状态，一旦有合适的数据了，还可以使用 ```notify``` 相关的函数来通知其他处于等待的线程，这样就可以不用做一些无用的上锁和解锁操作，从而可以提高程序的性能\n\n```threading.Condition``` 类是 ```threading.Lock``` ，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁\n\n- acquire：上锁\n- release：解锁\n- wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码\n- notify：通知某个正在等待的线程，默认是第一个等待的线程\n- notify_all：通知所有正在等待的线程，notify和notify_all不会释放锁。并且需要在release之前调用\n\n使用 ```threading.Condition``` 实现生产者和消费者模式例子\n\n```python\nimport threading\nimport time\nimport random\n\ngMoney = 1000\ngCondition = threading.Condition()\ngTotalTimes = 10\ngTimes = 0\n\nclass Producer(threading.Thread):\n    def run(self):\n        global gMoney\n        global gTimes\n        while True:\n            money = random.randint(100, 1000)\n            gCondition.acquire()\n            if gTimes >= gTotalTimes:\n                gCondition.release()\n                break\n            gMoney += money\n            print('%s 生产了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            gTimes += 1\n            gCondition.notify_all()\n            gCondition.release()\n            time.sleep(0.5)\n\nclass Consumer(threading.Thread):\n    def run(self):\n        global gMoney\n        while True:\n            money = random.randint(100, 1000)\n            gCondition.acquire()\n            while gMoney < money:\n                if gTimes >= gTotalTimes:\n                    gCondition.release()\n                    return\n                else:\n                    print('%s消费者准备消费%d元钱，剩余%d元钱，不足！' % (threading.current_thread(), money, gMoney))\n                gCondition.wait()\n            gMoney -= money\n            print('%s消费了%d元钱，剩余%d元钱' % (threading.current_thread(), money, gMoney))\n            gCondition.release()\n            time.sleep(0.5)\n\ndef main():\n    for x in range(3):\n        t = Consumer(name='消费者线程%d' % x)\n        t.start()\n\n    for x in range(5):\n        t = Producer(name='生产者线程%d' % x)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Queue线程安全队列\n\n在线程中，访问一些全局变量，加锁是一个经常的过程，如果先把一些数据存储在某个队列中，那么python内置了一个线程安全的模块叫做queue模块，python中的queue模块提供了同步的、线程安全的队列类，包括FIFO(先进先出)队列Queue，LIFO(后入先出)队列LifeQueue。这些队列都实现了锁原语(可以理解为原子操作，要么不做，要么都做完)，能够在多线程中直接使用，可以使用队列来实现线程间的同步\n\n- 初始化Queue(maxsize)：创建一个先进先出的队列\n- qsize()：返回队列的大小\n- empty()：判断队列是否为空\n- full()：判断队列是否满了\n- get()：从队列中取最后一个数据\n- put()：将一个数据放到队列中\n\n### 使用生产者与消费者模式多线程下载 斗图啦 表情包\n\n```python\nimport os\nimport re\nimport threading\nfrom queue import Queue\nfrom urllib import request\n\nimport requests\nfrom lxml import etree\n\nclass Procuder(threading.Thread):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n    }\n\n    def __init__(self, page_queue, img_queue, *args, **kwargs):\n        super(Procuder,self).__init__(*args, **kwargs)\n        self.page_queue = page_queue\n        self.img_queue = img_queue\n\n    def run(self):\n        while True:\n            if self.page_queue.empty():\n                break\n            url = self.page_queue.get()\n            self.parse_page(url)\n\n    def parse_page(self, url):\n        response = requests.get(url,headers=self.headers)\n        text = response.text\n        html = etree.HTML(text)\n\n        imgs = html.xpath('//div[@class=\"page-content text-center\"]//img[@class!=\"gif\"]')\n        for img in imgs:\n            img_url = img.get('data-original')\n            img_name = img.get('alt')\n            img_name = re.sub(r'[\\?？\\.，。！!；;\\*]', '', img_name)\n\n            img_suffix = os.path.splitext(img_url)[1]\n            filename = img_name + img_suffix\n            self.img_queue.put((img_url, filename))\n\nclass Consumer(threading.Thread):\n    def __init__(self, page_queue, img_queue, *args, **kwargs):\n        super(Consumer,self).__init__(*args, **kwargs)\n        self.page_queue = page_queue\n        self.img_queue = img_queue\n\n    def run(self):\n        while True:\n            if self.img_queue.empty() and self.page_queue.empty():\n                break\n            img_url, filename = self.img_queue.get()\n            request.urlretrieve(img_url, 'images/' + filename)\n            print(filename + ' 下载完成!')\n\ndef main():\n    page_queue = Queue(100)\n    img_queue = Queue(1000)\n\n    for x in range(1, 101):\n        url = 'https://www.doutula.com/photo/list/?page=%d' % x\n        page_queue.put(url)\n\n    for x in range(5):\n        t = Procuder(page_queue, img_queue)\n        t.start()\n    for x in range(5):\n        t = Consumer(page_queue, img_queue)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### GIL全局解释器锁\n\nPython自带的解释器是CPython，CPython解释器的多线程实际上并非真正的多线程(在多核CPU中，只能利用一核，不能利用多核)。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中有一个东西叫做 GIL(Global Intepreter Lock)，叫做全局解释器，这个解释器锁是有必要的，因为CPython解释器的内存管理不是线程安全的，当然除了CPython解释器，还有其他解释器，有些解释器是没有GIL锁的\n\n- Jython：用Java实现的Python解释器。不存在GIL锁\n- IronPython：用.net实现的Python解释器。不存在GIL锁\n- PyPy：用Python实现的Python解释器。存在GIL锁\n\nGIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程\n\n### 多线程爬取百思不得姐段子数据\n\n```python\nimport csv\nimport threading\nfrom queue import Queue\n\nimport requests\nfrom lxml import etree\n\n\nclass budejieSpider(threading.Thread):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n    }\n    def __init__(self, page_queue, joke_queue, *args,  **kwargs):\n        super(budejieSpider, self).__init__(*args,  **kwargs)\n        self.base_domain = \"http://www.budejie.com\"\n        self.page_queue = page_queue\n        self.joke_queue = joke_queue\n\n    def run(self):\n        while True:\n            if self.page_queue.empty():\n                break\n            url = self.page_queue.get()\n            response = requests.get(url, headers=self.headers)\n            text = response.text\n            html = etree.HTML(text)\n            descs = html.xpath(\"//div[@class='j-r-list-c-desc']\")\n            for desc in descs:\n                jokes = desc.xpath(\".//text()\")\n                joke = \"\\n\".join(jokes).strip()\n                link = self.base_domain+desc.xpath(\".//a/@href\")[0]\n                self.joke_queue.put((joke, link))\n            print('第%s页下载完成！' % url.split('/')[-1])\n\nclass budejieWriter(threading.Thread):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36'\n    }\n\n    def __init__(self, joke_queue, writer, gLock, *args,  **kwargs):\n        super(budejieWriter, self).__init__(*args,  **kwargs)\n        self.joke_queue = joke_queue\n        self.writer = writer\n        self.lock = gLock\n\n    def run(self):\n        while True:\n            try:\n                joke_info = self.joke_queue.get(timeout=40)\n                joke, link = joke_info\n                self.lock.acquire()\n                self.writer.writerow((joke, link))\n                self.lock.release()\n                print('保存一条.')\n            except:\n                pass\n\ndef main():\n    page_queue = Queue(10)\n    joke_queue = Queue(500)\n    gLock = threading.Lock()\n    fp = open('budejie.csv', 'a', newline='', encoding='utf-8')\n    writer = csv.writer(fp)\n    writer.writerow(('content', 'link'))\n\n    for x in range(1, 11):\n        url = 'http://www.budejie.com/text/%d' % x\n        page_queue.put(url)\n\n    for x in range(5):\n        t = budejieSpider(page_queue, joke_queue)\n        t.start()\n\n    for x  in range(5):\n        t = budejieWriter(joke_queue, writer, gLock)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```\n",
    "category": "Python",
    "tag": [
      "爬虫进阶",
      "多线程",
      "threading"
    ],
    "createdAt": "2019-07-13 21:50:13"
  },
  {
    "title": "动态网页爬虫",
    "author": "阿星Plus",
    "url": "2019-07-14-selenium",
    "markdown": "### Ajax是什么\n\nAJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是XML语法。因此叫做AJAX，其实现在数据交互基本上都是使用JSON。使用AJAX加载的数据，即使使用了JS，将数据渲染到了浏览器中，在右键->查看网页源代码还是不能看到通过ajax加载的数据，只能看到使用这个url加载的html代码\n\n### 获取Ajax数据的方式\n\n- 直接分析ajax调用的接口。然后通过代码请求这个接口\n- 使用 ```selenium``` + ```chromedriver``` 模拟浏览器行为获取数据\n\n\n| 方式 | 优点 | 缺点 |\n| :--- | :--- | :--- |\n| 分析接口 | 直接可以请求到数据，不需要做任何解析工作，代码量少，性能高 | 分析接口比较复杂，特别是一些通过js混淆的接口，容易被发现是爬虫 |\n| selenium | 直接模拟浏览器的行为，浏览器可以请求到的，使用 selenium 也能请求到，比较稳定 | 代码量多，性能低 |\n\n### ```selenium``` + ```chromedriver``` 获取动态数据\n\nselenium相当于是一个机器人，可以模拟人在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除cookie等\n\nchromedriver是一个驱动chrome浏览器的驱动程序，使用他才可以驱动浏览器，针对不同的浏览器有不同的driver\n\n- Chrome：https://sites.google.com/a/chromium.org/chromedriver/downloads\n- Firefox：https://github.com/mozilla/geckodriver/releases\n- Edge：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/\n- Safari：https://webkit.org/blog/6900/webdriver-support-in-safari-10/\n\n### 安装 ```selenium``` + ```chromedriver```\n\n- 安装selenium：selenium有很多语言的版本，有java、ruby、python等 ``` pip install selenium```\n- 安装chromedriver：下载和自己浏览器版本对应的文件，放到不需要权限的纯英文目录下就可以了\n\n### 简单使用\n\n以一个简单的获取百度首页的例子使用 selenium和chromedriver\n\n```python\nfrom selenium import webdriver\n\n# chromedriver的绝对路径\ndriver_path = r'D:\\Program Files\\chromedriver\\chromedriver.exe'\n\n# 初始化一个driver，并且指定chromedriver的路径\ndriver = webdriver.Chrome(executable_path=driver_path)\n\n# 请求网页\ndriver.get('https://www.meowv.com/')\n\n# 通过page_source获取网页源代码\nprint(driver.page_source)\n```\n\n### selenium 常用的操作\n\n官方文档：https://selenium-python.readthedocs.io/installation.html#introduction\n\n#### 关闭页面\n\n- ```driver.close()```：关闭当前页面\n- ```driver.quit()```：退出整个浏览器\n\n#### 定位元素\n\n- ```find_element_by_id```：根据id来查找某个元素\n\n```python\nsubmitTag = driver.find_element_by_id('su')\nsubmitTag1 = driver.find_element(By.ID,'su')\n```\n\n- ```find_element_by_class_name```：根据类名查找元素\n\n```python\nsubmitTag = driver.find_element_by_class_name('su')\nsubmitTag1 = driver.find_element(By.CLASS_NAME,'su')\n```\n\n- ```find_element_by_name```：根据name属性的值来查找元素\n\n```python\nsubmitTag = driver.find_element_by_name('email')\nsubmitTag1 = driver.find_element(By.NAME,'email')\n```\n\n- ```find_element_by_tag_name```：根据标签名来查找元素\n\n```python\nsubmitTag = driver.find_element_by_tag_name('div')\nsubmitTag1 = driver.find_element(By.TAG_NAME,'div')\n```\n\n- ```find_element_by_xpath```：根据xpath语法来获取元素\n\n```python\nsubmitTag = driver.find_element_by_xpath('//div')\nsubmitTag1 = driver.find_element(By.XPATH,'//div')\n```\n\n- ```find_element_by_css_selector```：根据css选择器选择元素\n\n```python\nsubmitTag = driver.find_element_by_css_selector('//div')\nsubmitTag1 = driver.find_element(By.CSS_SELECTOR,'//div')\n```\n\n- ```find_element``` 是获取第一个满足条件的元素\n- ```find_elements``` 是获取所有满足条件的元素\n\n#### 操作表单元素\n\n- 操作输入框：分为两步。第一步：找到这个元素。第二步：使用```send_keys(value)```，将数据填充进去\n\n```python\ninputTag = driver.find_element_by_id('kw')\ninputTag.send_keys('python')\n```\n\n使用```clear```方法可以清除输入框中的内容 ```inputTag.clear()```\n\n- 操作checkbox：因为要选中checkbox标签，在网页中是通过鼠标点击的。因此想要选中checkbox标签，那么先选中这个标签，然后执行click事件\n\n```python\nrememberTag = driver.find_element_by_name(\"rememberMe\")\nrememberTag.click()\n```\n\n- 选择select：select元素不能直接点击。因为点击后还需要选中元素。这时候selenium就专门为select标签提供了一个类selenium.webdriver.support.ui.Select。将获取到的元素当成参数传到这个类中，创建这个对象。以后就可以使用这个对象进行选择了\n\n```python\nfrom selenium.webdriver.support.ui import Select\n# 选中这个标签，然后使用Select创建对象\nselectTag = Select(driver.find_element_by_id(\"city-select\"))\n# 根据索引选择\nselectTag.select_by_index(1)\n# 根据值选择\nselectTag.select_by_value(\"https://news.hao123.com/wangzhi\")\n# 根据可视的文本选择\nselectTag.select_by_visible_text(\"上海\")\n# 取消选中所有选项\nselectTag.deselect_all()\n```\n\n- 操作按钮：操作按钮有很多种方式。比如单击、右击、双击等。这里讲一个最常用的。就是点击。直接调用click函数就可以了\n\n```python\ninputTag = driver.find_element_by_id('su')\ninputTag.click()\n```\n\n#### 行为链\n\n有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类ActionChains来完成。比如现在要将鼠标移动到某个元素上并执行点击事件\n\n```python\ninputTag = driver.find_element_by_id('kw')\nsubmitTag = driver.find_element_by_id('su')\n\nactions = ActionChains(driver)\nactions.move_to_element(inputTag)\nactions.send_keys_to_element(inputTag,'python')\nactions.move_to_element(submitTag)\nactions.click(submitTag)\nactions.perform()\n```\n\n还有更多的鼠标相关的操作\n\n- ```click_and_hold(element)```：点击但不松开鼠标\n- ```context_click(element)```：右键点击\n- ```double_click(element)```：双击\n- 更多方法请参考：http://selenium-python.readthedocs.io/api.html\n\n#### Cookie操作\n\n- 获取所有的cookie\n\n```python\nfor cookie in driver.get_cookies():\n    print(cookie)\n```\n\n-根据cookie的key获取value\n\n```python\nvalue = driver.get_cookie(key)\n```\n\n- 删除所有的cookie：\n\n```python\ndriver.delete_all_cookies()\n```\n\n- 删除某个cookie：\n\n```python\ndriver.delete_cookie(key)\n```\n\n#### 页面等待\n\n现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。为了解决这个问题。所以 selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。\n\n- 隐式等待：调用driver.implicitly_wait。那么在获取不可用的元素之前，会先等待10秒中的时间。\n\n```python\ndriver = webdriver.Chrome(executable_path=driver_path)\ndriver.implicitly_wait(10)\n# 请求网页\ndriver.get(\"https://www.douban.com/\")\n```\n\n- 显示等待：显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用selenium.webdriver.support.excepted_conditions期望的条件和selenium.webdriver.support.ui.WebDriverWait来配合完成.\n\n```python\nfrom selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\ndriver_path = r'D:\\Program Files\\chromedriver\\chromedriver.exe'\ndriver = webdriver.Chrome(executable_path=driver_path)\n\ndriver.get('https://www.douban.com/')\ndriver.implicitly_wait(20)\n\nelement = WebDriverWait(driver, 10).until(\n    EC.presence_of_element_located((By.NAME, 'phone'))\n)\nprint(element)\n```\n\n- 一些其他的等待条件\n    - ```presence_of_element_located```：某个元素已经加载完毕了\n    - ```presence_of_all_emement_located```：网页中所有满足条件的元素都加载完毕了\n    - ```element_to_be_cliable```：某个元素是可以点击了\n    - 更多条件请参考：http://selenium-python.readthedocs.io/waits.html\n\n#### 切换页面\n\n有时候窗口中有很多子tab页面。这时候肯定是需要进行切换的。selenium提供了一个叫做switch_to_window来进行切换，具体切换到哪个页面，可以从driver.window_handles中找到。\n\n```python\n# 打开一个新的页面\nself.driver.execute_script(\"window.open('\"+url+\"')\")\n# 切换到这个新的页面中\nself.driver.switch_to_window(self.driver.window_handles[1])\n```\n\n#### 设置代理ip\n\n有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以Chrome浏览器为例\n\n```python\nfrom selenium import webdriver\n\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"--proxy-server=http://132.232.126.92:8888\")\ndriver_path = r\"D:\\Program Files\\chromedriver\\chromedriver.exe\"\ndriver = webdriver.Chrome(executable_path=driver_path,chrome_options=options)\n\ndriver.get('http://httpbin.org/ip')\n```\n\n#### WebElement元素\n\nfrom selenium.webdriver.remote.webelement import WebElement类是每个获取出来的元素的所属类，它有一些常用的属性\n\n- get_attribute：这个标签的某个属性的值\n- screentshot：获取当前页面的截图，这个方法只能在driver上使用，driver的对象类，是继承自WebElement\n",
    "category": "Python",
    "tag": [
      "ip代理",
      "cookie",
      "爬虫进阶",
      "ajax",
      "selenium",
      "ChromeDriver"
    ],
    "createdAt": "2019-07-14 22:33:14"
  },
  {
    "title": "图形验证码识别",
    "author": "阿星Plus",
    "url": "2019-07-15-pytesseract",
    "markdown": "### 图形验证码识别技术\n\n阻碍我们爬虫的。有时候正是在登录或者请求一些数据时候的图形验证码。因此这里我们讲解一种能将图片翻译成文字的技术。将图片翻译成文字一般被成为光学文字识别（Optical Character Recognition），简写为OCR。实现OCR的库不是很多，特别是开源的。因为这块存在一定的技术壁垒（需要大量的数据、算法、机器学习、深度学习知识等），并且如果做好了具有很高的商业价值。因此开源的比较少。这里介绍一个比较优秀的图像识别开源库：Tesseract。\n\n### Tesseract\n\nTesseract是一个OCR库，目前由谷歌赞助。Tesseract是目前公认最优秀、最准确的开源OCR库。Tesseract具有很高的识别度，也具有很高的灵活性，他可以通过训练识别任何字体。\n\n### 安装\n\n#### Windows\n\n在 https://github.com/tesseract-ocr/ 下载可执行文件，然后一顿点击下一步安装即可，放在不需要权限的纯英文路径下\n\n#### Linux\n\n可以在 https://github.com/tesseract-ocr/tesseract/wiki/Compiling 下载源码自行编译，或者(ubuntu下)通过以下命令进行安装 ```sudo apt install tesseract-ocr```\n\n#### Mac\n\n用Homebrew即可方便安装，```brew install tesseract```\n\n### 设置环境变量\n\n安装完成后，如果想要在命令行中使用Tesseract，那么应该设置环境变量。Mac和Linux在安装的时候就默认已经设置好了。在Windows下把tesseract.exe所在的路径添加到PATH环境变量中。\n\n还有一个环境变量需要设置的是，要把训练的数据文件路径也放到环境变量中\n\n在环境变量中，添加一个 TESSDATA_PREFIX=~~~\\teseractdata\n\n### 在命令行中使用tesseract识别图像\n\n如果想要在cmd下能够使用tesseract命令，那么需要把tesseract.exe所在的目录放到PATH环境变量中。然后使用命令：tesseract 图片路径 文件路径。\n\n```tesseract a.png a```\n\n那么就会识别出a.png中的图片，并且把文字写入到a.txt中。如果不想写入文件直接想显示在终端，那么不要加文件名就可以了。\n\n### 在代码中使用tesseract识别图像\n\n在Python代码中操作tesseract。需要安装一个库，叫做pytesseract。通过pip的方式即可安装：\n\n```pip install pytesseract```\n\n并且，需要读取图片，需要借助一个第三方库叫做PIL。通过pip list看下是否安装。如果没有安装，通过pip的方式安装：\n\n```pip install PIL```\n\n使用pytesseract将图片上的文字转换为文本文字\n\n```python\n# 导入pytesseract库\nimport pytesseract\n# 导入Image库\nfrom PIL import Image\n\n# 指定tesseract.exe所在的路径\npytesseract.pytesseract.tesseract_cmd = r'D:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n\n# 打开图片\nimage = Image.open(\"a.png\")\n# 调用image_to_string将图片转换为文字\ntext = pytesseract.image_to_string(image, lang='chi_sim')\nprint(text)\n```\n\n### 用pytesseract自动识别图形验证码\n\n```python\nimport time\nfrom urllib import request\n\nimport pytesseract\nfrom PIL import Image\n\ndef main():\n    pytesseract.pytesseract.tesseract_cmd = r'D:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n    while True:\n        url = 'https://e.coding.net/api/getCaptcha'\n        request.urlretrieve(url, 'captcha.png')\n        image = Image.open('captcha.png')\n        text = pytesseract.image_to_string(image)\n        print(text)\n        time.sleep(2)\n\nif __name__ == \"__main__\":\n    main()\n```\n",
    "category": "Python",
    "tag": [
      "爬虫进阶",
      "验证码",
      "tesseract",
      "pytesseract"
    ],
    "createdAt": "2019-07-15 23:21:15"
  },
  {
    "title": "Scrapy框架",
    "author": "阿星Plus",
    "url": "2019-07-16-scrapy",
    "markdown": "### Scrapy框架介绍\n\n写一个爬虫，需要做很多的事情，比如：发送网络请求、数据解析、数据存储、反反爬虫机制(ip代理，设置请求头等)、异步请求等等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此scrapy把一些基础的东西都封装好了，在scrapy框架上开发爬虫可以变得更加的高效，爬取效率和开发效率得到提升。\n\n### Scrapy框架模块功能\n\n- Scrapy Engine（引擎）：Scrapy框架的核心部分。负责在Spider和ItemPipeline、Downloader、Scheduler中间通信、传递数据等。\n- Spider（爬虫）：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是我们需要的，都是由程序员自己决定。\n- Scheduler（调度器）：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。\n- Downloader（下载器）：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。\n- Item Pipeline（管道）：负责将Spider（爬虫）传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。\n- Downloader Middlewares（下载中间件）：可以扩展下载器和引擎之间通信功能的中间件。\n- Spider Middlewares（Spider中间件）：可以扩展引擎和爬虫之间通信功能的中间件。\n\n### Scrapy安装和文档\n\n- 安装：通过 ```pip install scrapy``` 即可安装。\n    - 在ubuntu上安装scrapy之前，需要先安装以下依赖：```sudo apt-get install python3-dev build-essential python3-pip libxml2-dev libxslt1-dev zlib1g-dev libffi-dev libssl-dev```，然后再通过 ```pip install scrapy``` 安装。\n    - 如果在windows系统下，提示这个错误ModuleNotFoundError: No module named 'win32api'，那么使用以下命令可以解决：```pip install pypiwin32```。\n- Scrapy官方文档：http://doc.scrapy.org/en/latest\n- Scrapy中文文档：http://scrapy-chs.readthedocs.io/zh_CN/latest/index.html\n\n### Scrapy快速入门\n\n#### 创建项目\n\n要使用Scrapy框架创建项目，需要通过命令来创建。首先进入到你想把这个项目存放的目录。然后使用以下命令创建：\n\n```scrapy startproject [项目名称]```\n\n#### 目录结构介绍\n\n- items.py：用来存放爬虫爬取下来数据的模型。\n- middlewares.py：用来存放各种中间件的文件。\n- pipelines.py：用来将items的模型存储到本地磁盘中。\n- settings.py：本爬虫的一些配置信息（比如请求头、多久发送一次请求、ip代理池等）。\n- scrapy.cfg：项目的配置文件。\n- spiders包：以后所有的爬虫，都是存放到这个里面。\n\n#### 使用Scrapy框架爬取糗事百科段子例子\n\n##### 使用命令创建一个爬虫\n\n```scrapy gensipder qsbk \"qiushibaike.com\"```\n\n创建了一个名字叫做 qsbk 的爬虫，并且能爬取的网页只会限制在 qiushibaike.com 这个域名下。\n\n##### 爬虫代码解析\n\n```python\nimport scrapy\n\nclass QsbkSpider(scrapy.Spider):\n    name = 'qsbk'\n    allowed_domains = ['qiushibaike.com']\n    start_urls = ['http://qiushibaike.com/']\n\n    def parse(self, response):\n        pass\n```\n\n其实这些代码我们完全可以自己手动去写，而不用命令。只不过是不用命令，自己写这些代码比较麻烦。\n\n要创建一个Spider，那么必须自定义一个类，继承自scrapy.Spider，然后在这个类中定义三个属性和一个方法。\n\n- name：这个爬虫的名字，名字必须是唯一的。\n- allow_domains：允许的域名。爬虫只会爬取这个域名下的网页，其他不是这个域名下的网页会被自动忽略。\n- start_urls：爬虫从这个变量中的url开始。\n- parse：引擎会把下载器下载回来的数据扔给爬虫解析，爬虫再把数据传给这个parse方法。这个是个固定的写法。这个方法的作用有两个，第一个是提取想要的数据。第二个是生成下一个请求的url。\n\n##### 修改settings.py代码\n\n在做一个爬虫之前，一定要记得修改setttings.py中的设置。两个地方是强烈建议设置的。\n\n- ROBOTSTXT_OBEY设置为False。默认是True。即遵守机器协议，那么在爬虫的时候，scrapy首先去找robots.txt文件，如果没有找到。则直接停止爬取。\n- DEFAULT_REQUEST_HEADERS添加User-Agent。这个也是告诉服务器，我这个请求是一个正常的请求，不是一个爬虫。\n\n##### 完成的爬虫代码\n\n###### 爬虫部分代码\n\n```python\nimport scrapy\nfrom scrapy.http.response.html import HtmlResponse\nfrom scrapy.selector.unified import SelectorList\nfrom qsbk.items import QsbkItem\n\nclass QsbkSpider(scrapy.Spider):\n    name = 'qsbk_spider'\n    allowed_domains = ['qiushibaike.com']\n    start_urls = ['https://www.qiushibaike.com/text/page/1/']\n    base_domain = 'https://www.qiushibaike.com'\n\n    def parse(self, response):\n        duanziDivs = contentLeft = response.xpath(\"//div[@id='content-left']/div\")\n        for duanzidiv in duanziDivs:\n            author = duanzidiv.xpath(\".//h2/text()\").get().strip()\n            content = duanzidiv.xpath(\".//div[@class='content']//text()\").getall()\n            content = \"\".join(content).strip()\n\n            # duanzi = {\"author\":author,\"content\":content}\n            # yield duanzi\n\n            item = QsbkItem(author=author,content=content)\n            yield item\n        next_url = response.xpath(\"//ul[@class='pagination']/li[last()]/a/@href\").get()\n        if not next_url:\n            return\n        else:\n            yield scrapy.Request(self.base_domain + next_url, self.parse)\n```\n\n###### items.py部分代码\n\n```python\nimport scrapy\n\nclass QsbkItem(scrapy.Item):\n    author = scrapy.Field()\n    content = scrapy.Field()\n```\n\n###### pipeline部分代码\n\n```python\n# 方式1\nimport json\nclass QsbkPipeline(object):\n    def __init__(self):\n        self.fp = open(\"duanzi.josn\", 'w', encoding='utf-8')\n\n    def open_spider(self, spider):\n        print('start...')\n\n    def process_item(self, item, spider):\n        item_json = json.dumps(dict(item), ensure_ascii=False)\n        self.fp.write(item_json+ '\\n')\n        return item\n\n    def close_spider(self, spider):\n        self.fp.close()\n        print('end...')\n\n# 方式2\nfrom scrapy.exporters import JsonItemExporter\nclass QsbkPipeline(object):\n    def __init__(self):\n        self.fp = open(\"duanzi.josn\", 'wb')\n        self.exporter = JsonItemExporter(self.fp, ensure_ascii=False, encoding='utf-8')\n        self.exporter.start_exporting()\n\n    def open_spider(self, spider):\n        print('start...')\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item\n\n    def close_spider(self, spider):\n        self.exporter.finish_exporting()\n        self.fp.close()\n        print('end...')\n\n# 方式3\nfrom scrapy.exporters import JsonLinesItemExporter\nclass QsbkPipeline(object):\n    def __init__(self):\n        self.fp = open(\"duanzi.josn\", 'wb')\n        self.exporter = JsonLinesItemExporter(self.fp, ensure_ascii=False, encoding='utf-8')\n\n    def open_spider(self, spider):\n        print('start...')\n\n    def process_item(self, item, spider):\n        self.exporter.export_item(item)\n        return item\n\n    def close_spider(self, spider):\n        self.fp.close()\n        print('end...')\n```\n\n##### 运行scrapy项目\n\n运行scrapy项目。需要在终端，进入项目所在的路径，然后 ```scrapy crawl [爬虫名字]``` 即可运行指定的爬虫。如果不想每次都在命令行中运行，那么可以把这个命令写在一个文件中。以后就在pycharm中执行运行这个文件就可以了。比如现在新创建一个文件叫做 start.py，然后在这个文件中填入以下代码：\n\n```python\nfrom scrapy import cmdline\n\ncmdline.execute(\"scrapy crawl qsbk\".split())\n```\n\n### JsonItemExporter和JsonLinesItemExporter\n\n- 保存json数据的时候，可以使用这两个类，让操作变得更简单\n- `JsonItemExporter`：每次把数据添加到内存中，最后统一写入磁盘，存储的数据是一个满足json规则的数据，数据量比较大，比较耗内存\n- `JsonLinesItemExporter`：每次调用`export_item`的时候把这个item存储到磁盘，每一个字典是一行，整个文件不是一个满足json格式的文件，每次处理初级的时候直接存储到硬盘，不耗内存，数据比较安全\n\n### Scrapy爬虫注意事项\n\n- response 是一个`from scrapy.http.response.html.HtmlResponse`对象，可以执行`xpath`和`css`语法提取数据\n- 提取出来的数据是一个`Selector`或者`SelectorList`对象，如果想要获取其中的字符串，应该执行`getall`或者`get`方法\n- getall方法：获取`Selector`中所有文本，返回的是一个列表\n- get方法：获取的是`Selector`中的第一个文本，返回的是str类型\n- 如果数据解析回来要传给pipelines处理，可以使用`yield`来返回，或者是添加所有的item，统一使用`return`返回\n- item：在`item.py`中定义好模型，不要使用字典\n- pipelines：这个是专门一从来保存数据的，其中有三个方法是会被经常用到的。要激活pipelines，应该在`settings.py`中，设置`ITEM_PIPELINES`\n    - `open_spider`：当爬虫被打开的时候执行\n    - `process_item`：当爬虫有item传过来的时候会被调用\n    - `close_spider`：当爬虫关闭的时候被调用\n\n### CrawlSpider\n\n在糗事百科的爬虫案例中。我们是自己在解析完整个页面后获取下一页的url，然后重新发送一个请求。有时候我们想要这样做，只要满足某个条件的url，都给我进行爬取。那么这时候我们就可以通过CrawlSpider来帮我们完成了。CrawlSpider继承自Spider，只不过是在之前的基础之上增加了新的功能，可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动的yield Request。\n\n### 创建CrawlSpider爬虫\n\n之前创建爬虫的方式是通过```scrapy genspider [爬虫名字] [域名]```的方式创建的。如果想要创建CrawlSpider爬虫，那么应该通过以下命令创建：\n\n```scrapy genspider -c crawl [爬虫名字] [域名]```\n\n### LinkExtractors链接提取器\n\n使用LinkExtractors可以不用程序员自己提取想要的url，然后发送请求。这些工作都可以交给LinkExtractors，他会在所有爬的页面中找到满足规则的url，实现自动的爬取。\n\n```python\nclass scrapy.linkextractors.LinkExtractor(\n    allow = (),\n    deny = (),\n    allow_domains = (),\n    deny_domains = (),\n    deny_extensions = None,\n    restrict_xpaths = (),\n    tags = ('a','area'),\n    attrs = ('href'),\n    canonicalize = True,\n    unique = True,\n    process_value = None\n)\n```\n\n- allow：允许的url。所有满足这个正则表达式的url都会被提取。\n- deny：禁止的url。所有满足这个正则表达式的url都不会被提取。\n- allow_domains：允许的域名。只有在这个里面指定的域名的url才会被提取。\n- deny_domains：禁止的域名。所有在这个里面指定的域名的url都不会被提取。\n- restrict_xpaths：严格的xpath。和allow共同过滤链接。\n\n### Rule规则类\n\n定义爬虫的规则类。\n\n```python\nclass scrapy.spiders.Rule(\n    link_extractor,\n    callback = None,\n    cb_kwargs = None,\n    follow = None,\n    process_links = None,\n    process_request = None\n)\n```\n\n- link_extractor：一个LinkExtractor对象，用于定义爬取规则。\n- callback：满足这个规则的url，应该要执行哪个回调函数。因为CrawlSpider使用了parse作为回调函数，因此不要覆盖parse作为回调函数自己的回调函数。\n- follow：指定根据该规则从response中提取的链接是否需要跟进。\n- process_links：从link_extractor中获取到链接后会传递给这个函数，用来过滤不需要爬取的链接。\n\n### Scrapy Shell\n\n我们想要在爬虫中使用xpath、beautifulsoup、正则表达式、css选择器等来提取想要的数据。但是因为scrapy是一个比较重的框架。每次运行起来都要等待一段时间。因此要去验证我们写的提取规则是否正确，是一个比较麻烦的事情。因此Scrapy提供了一个shell，用来方便的测试规则\n\n打开cmd终端，进入到Scrapy项目所在的目录，然后进入到scrapy框架所在的虚拟环境中，输入命令```scrapy shell [链接]```。就会进入到scrapy的shell环境中。在这个环境中，你可以跟在爬虫的parse方法中一样使用了。\n",
    "category": "Python",
    "tag": [
      "爬虫进阶",
      "Scrapy"
    ],
    "createdAt": "2019-07-16 19:50:16"
  },
  {
    "title": "Scrapy-Redis分布式爬虫",
    "author": "阿星Plus",
    "url": "2019-07-17-scrapy-redis",
    "markdown": "## Scrapy-Redis分布式爬虫组件\n\nScrapy是一个框架，他本身是不支持分布式的。如果我们想要做分布式的爬虫，就需要借助一个组件叫做Scrapy-Redis，这个组件正是利用了Redis可以分布式的功能，集成到Scrapy框架中，使得爬虫可以进行分布式。可以充分的利用资源（多个ip、更多带宽、同步爬取）来提高爬虫的爬行效率。\n\n## 分布式爬虫的优点\n\n- 可以充分利用多台机器的带宽\n- 可以充分利用多台机器的ip地址\n- 多台机器做，爬取效率更高\n\n## 分布式爬虫必须要解决的问题\n\n- 分布式爬虫是好几台机器在同时运行，如何保证不同的机器爬取页面的时候不会出现重复爬取的问题\n- 分布式爬虫在不同的机器上运行，在把数据爬完后如何保证保存在同一个地方\n\n## 安装\n\n通过 ```pip install scrapy-redis``` 即可安装\n\n## 将scrapy框架开发的爬虫项目改为分布式爬虫项目\n\n1. 将爬虫的类从```scrapy.Spider```变成```scrapy_redis.spiders.RedisSpider```，或者是从```scrapy.CrawlSpider```变成```scrapy_redis.spiders.RedisCrawlSpider```\n\n2. 将爬虫中的```start_urls```删掉，增加一个 ```redis_key=\"xxx\"``` 。这个```redis_key```是为了以后在redis中控制爬虫启动的。爬虫的第一个url，就是在redis中通过这个发送出去的。\n\n3. 在配置文件中增加如下配置\n\n    ```python\n        # Scrapy-Redis相关配置\n\n        # 确保request存储到redis中\n        SCHEDULER = \"scrapy_redis.scheduler.Scheduler\"\n\n        # 确保所有爬虫共享相同的去重指纹\n        DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"\n\n        # 设置redis为item pipeline\n        ITEM_PIPELINES = {\n            'scrapy_redis.pipelines.RedisPipeline': 300\n        }\n\n        # 在redis中保持scrapy-redis用到的队列，不会清理redis中的队列，从而可以实现暂停和恢复的功能\n        SCHEDULER_PERSIST = True\n\n        # 设置连接redis信息\n        REDIS_HOST = '127.0.0.1'\n        REDIS_PORT = 6379\n    ```\n\n4. 运行爬虫\n    - 在爬虫服务器上，进入爬虫文件所在的路径，然后输入命令：```scrapy runspider [爬虫名字]```\n    - 在Redis服务器上，推入一个开始的url链接：```redis-cli> lpush [redis_key] start_url``` 开始爬取\n",
    "category": "Python",
    "tag": [
      "爬虫进阶",
      "Scrapy",
      "Redis",
      "分布式"
    ],
    "createdAt": "2019-07-17 20:18:17"
  },
  {
    "title": "MongoDB Shell 命令",
    "author": "阿星Plus",
    "url": "2019-07-21-mongodb-shell",
    "markdown": "更新列名\n\n```sql\ndb.Stores.update({}, {$rename : {\"StoreId\" : \"MetaId\"}}, false, true)\n```\n\n查询长度\n\n```sql\ndb.getCollection(\"Stores_Navigations\").find({$where:'this.StoreId.length>2'},{Name:0})\n```\n\n查询总条数\n\n```sql\ndb.getCollection(\"Stores_BusinessLogs\").find({}).count()\n```\n\n区间查询\n\n```sql\ndb.getCollection(\"Cards\").find({'StoreId':1139,'CardNo':{'$gte':'90225001','$lte':'90295000'}})\n```\n\n排序 1升序 -1降序\n\n```sql\ndb.getCollection(\"Stores_BusinessLogs\").find().sort({\"CreationTime\":1})\n```\n\n更改字段类型\n\n```sql\n// 16代表int\ndb.Stores_Experts.find({'PicId' : { $type : 16 }}).forEach(function(x) {x.PicId = String(x.PicId);db.Stores_Experts.save(x); })\n```\n\n字段类型表\n\n| 类型 | 对应数字 | 别名 |\n| :--- | :--- | :--- |\n| Double | 1 | double |\n| String | 2 | string |\n| Object | 3 | object |\n| Array | 4 | array |\n| Binary data | 5 | binData |\n| Undefined | 6 | undefined |\n| ObjectId | 7 | objectId |\n| Boolean | 8 | “bool” |\n| Date | 9 | “date” |\n| Null | 10 | “null” |\n| Regular Expression | 11 | “regex” |\n| DBPointer | 12 | “dbPointer” |\n| JavaScript | 13 | “javascript” |\n| Symbol | 14 | “symbol” |\n| JavaScript\\(with scope\\) | 15 | “javascriptWithScope” |\n| 32-bit integer | 16 | “int” |\n| Timestamp | 17 | “timestamp” |\n| 64-bit integer | 18 | “long” |\n| Min key | -1 | “minKey” |\n| Max key | 127 | “maxKey” |\n| - | - | - |\n\n添加一个字段. table 代表表名 , 添加字段 content,字符串类型\n\n```sql\ndb.table.update({}, {$set: {content:\"\"}}, {multi: true})\n```\n\n删除一个字段\n\n```sql\ndb.table.update({},{$unset:{content:\"\"}},false, true)\n```\n\n清空数据\n\n```sql\ndb.table.remove({})\n```\n\n查询指定列\n\n```sql\ndb.news.find( {}, { id: 1, title: 1 } )\n```\n\n修改列表\n\n```sql\ndb.getCollection('Orders_Scores').update({},{$rename:{\"OId\":'MetaId'}},false,true)\n```\n\n添加索引\n\n```sql\ndb.test.createIndex({\"username\":1})\ndb.Users_MobileAuthCodes.createIndex({\"Code\":1,\"Mobile\":1,\"ExpiresTime\":1},{\"name\":\"MobileAuthCodes_Validate\"})\n```\n\ngroup分组\n\n```sql\ndb.getCollection(\"Users_GaoKaoScores\").aggregate([{$match:{\"IsDeleted\":false}},{$group : {_id : \"$UserId\", count : {$sum : 1}}},{$sort:{\"count\":-1}}])\n```\n\n按条件修改update\n\n```sql\ndb.getCollection('Stores_Navigations').update( \n    // query\n    {\n        \"MenuKey\" : 28\n    },\n\n    // update\n    {\n        $set:{\"Url\":\"/tzy/choosebatch?type=3\"}\n    },\n    false,  \n    true\n);\n```\n",
    "category": "Database",
    "tag": [
      "MongoDB",
      "SQL"
    ],
    "createdAt": "2019-07-21 22:17:21"
  },
  {
    "title": "一些精简的JavaScript代码集合",
    "author": "阿星Plus",
    "url": "2019-07-22-js-code",
    "markdown": "## 日历\n\n创建过去七天的数组，如果将代码中的减号换成加号，你将得到未来7天的数组集合\n\n```javascript\n// 创建过去七天的数组\n[...Array(7).keys()].map(days => new Date(Date.now() - 86400000 * days));\n```\n\n## 生成随机ID\n\n生成长度为11的随机字母数字字符串\n\n```javascript\n// 生成长度为11的随机字母数字字符串\nMath.random().toString(36).substring(2);\n```\n\n## 获取URL的查询参数\n\n这个获取URL的查询参数代码，是我见过最精简的\n\n```javascript\n// 获取URL的查询参数\nq={};location.search.replace(/([^?&=]+)=([^&]+)/g,(_,k,v)=>q[k]=v);q;\n```\n\n## 本地时间\n\n通过一堆HTML，您可以创建一个本地时间，其中包含您可以一口气读出的源代码，它每秒都会用当前时间更新页面\n\n```javascript\n// 创建本地时间\n<body onload=\"setInterval(()=>document.body.innerHTML=new Date().toLocaleString().slice(10,19))\"></body>\n```\n\n## 数组混淆\n\n随机更改数组元素顺序，混淆数组\n\n```(arr) => arr.slice().sort(() => Math.random() - 0.5)```\n\n```javascript\n// 随机更改数组元素顺序，混淆数组\nlet a = (arr) => arr.slice().sort(() => Math.random() - 0.5)\nlet b = a([1,2,3,4,5])\nconsole.log(b)\n```\n\n## 生成随机十六进制代码（生成随机颜色）\n\n使用JavaScript简洁代码生成随机十六进制代码\n\n```javascript\n// 生成随机十六进制代码 如：'#c618b2'\n'#' + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, '0');\n```\n\n## 数组去重\n\n这是一个原生的JS函数但是非常简洁，Set接受任何可迭代对象，如数组[1,2,3,3]，并删除重复项\n\n```javascript\n// 数组去重\n[...new Set(arr)]\n```\n\n## 创建特定大小的数组\n\n```javascript\n[...Array(3).keys()]\n// [0, 1, 2]\n\nArray.from({length: 3}, (item, index) => index)\n// [0, 1, 2]\n```\n\n## 返回一个键盘\n\n```javascript\n// 用字符串返回一个键盘图形\n(_=>[...\"`1234567890-=~~QWERTYUIOP[]\\\\~ASDFGHJKL;'~~ZXCVBNM,./~\"].map(x=>(o+=`/${b='_'.repeat(w=x<y?2:' 667699'[x=[\"BS\",\"TAB\",\"CAPS\",\"ENTER\"][p++]||'SHIFT',p])}\\\\|`,m+=y+(x+'    ').slice(0,w)+y+y,n+=y+b+y+y,l+=' __'+b)[73]&&(k.push(l,m,n,o),l='',m=n=o=y),m=n=o=y='|',p=l=k=[])&&k.join`\n`)()\n```\n",
    "category": "Web",
    "tag": [
      "JavaScript"
    ],
    "createdAt": "2019-07-22 21:10:22"
  },
  {
    "title": "Redis快速入门及使用",
    "author": "阿星Plus",
    "url": "2019-07-24-quick-start-with-redis",
    "markdown": "## 概述\n\nredis是一种支持分布式的nosql数据库,他的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比memcached支持更多的数据结构(string,list列表[队列和栈],set[集合],sorted set[有序集合],hash(hash表))。\n\nredis文档：http://redisdoc.com/index.html\n\n## Redis使用场景\n\n- 登录会话存储：存储在redis中，与memcached相比，数据不会丢失。\n- 排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。\n- 作为消息队列：比如celery就是使用redis作为中间人。\n- 当前在线人数：当前系统有多少在线人数。\n- 一些常用的数据缓存：比如我们的BBS论坛，板块不会经常变化的，但是每次访问首页都要从mysql中获取，可以在redis中缓存起来，不用每次请求数据库。\n- 把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。\n- 好友关系：微博的好友关系使用redis实现。\n- 发布和订阅功能：可以用来做聊天软件。\n\n## Redis和Memcached的比较\n\n|  | Memcached | Redis |\n| :--- | :--- | :--- |\n| 类型 | 纯内存数据库 | 内存磁盘同步数据库 |\n| 数据类型 | 在定义value时就要固定数据类型 | 不需要 |\n| 虚拟内存 | 不支持 | 支持 |\n| 过期策略 | 支持 | 支持 |\n| 存储数据安全 | 不支持 | 可以将数据同步到dump.db中 |\n| 灾难恢复 | 不支持 | 可以将磁盘中的数据恢复到内存中 |\n| 分布式 | 支持 | 主从同步 |\n| 订阅与发布 | 不支持 | 支持 |\n\n## Redis在windows系统中的安装与启动\n\n- 下载：redis官方是不支持windows操作系统的，但是微软的开源部门将redis移植到了windows上，因此下载地址不是在redis官网上，而是在github上：https://github.com/MicrosoftArchive/redis/releases\n- 安装：点击一顿下一步安装就可以了\n- 运行：进入到redis安装所在的路径然后执行```redis-server.exe redis.windows.conf```就可以运行了\n- 连接：redis和mysql以及mongo是一样的，都提供了一个客户端进行连接。输入命令redis-cli（前提是redis安装路径已经加入到环境变量中了）就可以连接到redis服务器了\n\n## Redis在ubuntu系统中的安装与启动\n\n- 安装：```sudo apt-get install redis-server```\n- 卸载：```sudo apt-get purge --auto-remove redis-server```\n- 启动：redis安装后，默认会自动启动，可以通过以下命令查看：```ps aux|grep redis```\n- 如果想自己手动启动，可以通过以下命令进行启动：```sudo service redis-server start```\n- 停止：```sudo service redis-server stop```\n\n## Redis服务器允许其它机器访问\n\n- 想要让其他机器访问本机的redis服务器。那么要修改redis.conf的配置文件，将bind改成bind [自己的ip地址或者0.0.0.0]，其他机器才能访问。\n- bind绑定的是本机网卡的ip地址，而不是想让其他机器连接的ip地址。如果有多块网卡，那么可以绑定多个网卡的ip地址。如果绑定到额是0.0.0.0，那么意味着其他机器可以通过本机所有的ip地址进行访问。\n\n## 对Redis的操作\n\n操作redis可以分为两种方式，第一种是使用redis-cli，第二种就是使用编程语言对其操作， 如：.NET、Python等\n\n### 启动redis\n\n```sudo service redis-server start```\n\n### 连接redis-server\n\n```redis-cli -h [ip] -p [端口]```\n\n### 添加\n\n```set key value``` 如：```set key articles```\n\n将字符串值value关联到key。如果key已经持有其他值，set命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。\n\n### 删除\n\n```del key``` 如：```del articles```\n\n### 设置过期时间\n\n```expire key timeout(单位为秒)```\n\n也可以在设置值的时候，一同指定过期时间\n\n```set key value EX timeout``` 或：```setex key timeout value```\n\n### 查看过期时间\n\n```ttl key``` 如：```ttl articles```\n\n### 查看当前redis中的所有key\n\n```keys *```\n\n### 列表操作\n\n- 在列表左边添加元素\n\n    ```lpush key value```\n\n    将值value插入到列表key的表头。如果key不存在，一个空列表会被创建并执行lpush操作。当key存在但不是列表类型时，将返回一个错误\n\n- 在列表右边添加元素\n\n    ```rpush key value```\n\n    将值value插入到列表key的表尾。如果key不存在，一个空列表会被创建并执行RPUSH操作。当key存在但不是列表类型时，返回一个错误\n\n- 查看列表中的元素\n\n    ```lrange key start stop```\n\n    返回列表key中指定区间内的元素，区间以偏移量start和stop指定,如果要查看左边的第一个到最后的一个则：```lrange key 0 -1```\n\n- 移除列表中的元素\n\n    - 移除并返回列表key的头元素：```lpop key```\n    - 移除并返回列表的尾元素：```rpop key```\n    - 移除并返回列表key的中间元素：```lrem key count value``` 将删除key这个列表中，count个值为value的元素\n\n- 指定返回第几个元素\n\n    ```lindex key index``` 将返回key这个列表中，索引为index的这个元素\n\n- 获取列表中的元素个数\n\n    ```llen key``` 如：```llen languages```\n\n    根据参数 count 的值，移除列表中与参数 value 相等的元素。count的值可以是以下几种\n\n    - count > 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count\n    - count < 0：从表尾开始向表头搜索，移除与 value相等的元素，数量为count的绝对值\n    - count = 0：移除表中所有与value 相等的值\n\n### set集合的操作\n\n- 添加元素\n\n    ```sadd set value1 value2....``` 如：```sadd team web app```\n\n- 查看元素\n\n    ```smembers set``` 如：```smembers team```\n\n- 移除元素\n\n    ```rem set member...``` 如：```srem team web app```\n\n- 查看集合中的元素个数\n\n    ```scard set``` 如：```scard team1```\n\n- 获取多个集合的交集\n\n    ```sinter set1 set2``` 如：```sinter team1 team2```\n\n- 获取多个集合的并集\n\n    ```sunion set1 set2``` 如：```sunion team1 team2```\n\n- 获取多个集合的差集\n\n    ```sdiff set1 set2``` 如：```sdiff team1 team2```\n\n### hash哈希操作\n\n- 添加一个新值\n\n    ```hset key field value``` 如：```hset website baidu baidu.com```\n\n    将哈希表key中的域field的值设为value，如果key不存在，一个新的哈希表被创建并进行 HSET操作。如果域 field已经存在于哈希表中，旧值将被覆盖。\n\n- 获取哈希中的field对应的值\n\n    ```hget key field``` 如：```hget website baidu```\n\n- 删除field中的某个field\n\n    ```hdel key field``` 如：```hdel website baidu```\n\n- 获取某个哈希中所有的field和value\n\n    ```hgetall key``` 如：```hgetall website```\n\n- 获取某个哈希中所有的field\n\n    ```hkeys key``` 如：```hkeys website```\n\n- 获取某个哈希中所有的值\n\n    ```hvals key``` 如：```hvals website```\n\n- 判断哈希中是否存在某个field\n\n    ```hexists key field``` 如：```hexists website baidu```\n\n- 获取哈希中总共的键值对\n\n```hlen field``` 如：```hlen website```\n\n### 事务操作\n\nRedis事务可以一次执行多个命令，事务具有以下特征\n\n- 隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰\n- 原子操作：事务中的命令要么全部被执行，要么全部都不执行\n- 开启一个事务：```multi```，以后执行的所有命令，都在这个事务中执行的\n- 执行事务：```exec```，会将在```multi```和```exec```中的操作一并提交\n- 取消事务：```discard```，会将```multi```后的所有命令取消\n- 监视一个或者多个key：```watch key...```，监视一个(或多个)key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断\n- 取消所有key的监视：```unwatch```\n\n### 发布/订阅操作\n\n- 给某个频道发布消息：```publish channel message```\n- 订阅某个频道的消息：```subscribe channel```\n",
    "category": "Database",
    "tag": [
      "Redis"
    ],
    "createdAt": "2019-07-24 22:18:24"
  },
  {
    "title": "Windows下MySQL安装流程，8.0以上版本ROOT密码报错及修改",
    "author": "阿星Plus",
    "url": "2019-07-29-mysql-install",
    "markdown": "官网下载MySQL安装后，解压，添加环境变量，以管理员方式运行cmd，运行以下命令\n\n```text\nmysqld --initialize --console\nmysqld -install\n\nnet start mysql\nnet stop mysql\n```\n\n以上命令走完，确保MySQL安装和启动没问题，第一次安装设置密码\\(忘记密码也适用\\)\n\n运行：`mysqld --shared-memory --skip-grant-tables`\n\n此时命令提示符窗口处于锁定状态，我们重新以管理员方式运行新的cmd，运行以下命令\n\n```text\nmysql -uroot -p\n```\n\n提示输入密码时直接按回车进入，输入\n\n```text\nuse mysql;\nalter user 'root'@'localhost' identified by '123456';\nflush privileges;\n```\n\n123456就是要设置的密码，退出MySQL交互环境，再次启动MySQL服务，用设置的密码连接MySQL\n",
    "category": "Database",
    "tag": [
      "MySQL",
      "Windows"
    ],
    "createdAt": "2019-07-29 22:28:29"
  },
  {
    "title": "基于.NET Core开发的个人博客发布至CentOS小计",
    "author": "阿星Plus",
    "url": "2019-08-15-centos-usage",
    "markdown": "早些时候，使用 .NET Framework 开发网站，只能部署在 Windows 服务器上面，近两年 .NET Core 如火如荼，乘此机会赶紧上车，最近将自己利用 .NET Core 开发的个人博客发布在了 CentOS 上，简单记录一下使用过程和一些常用的命令，以备不时之需。\n\n## 渣渣服务器配置信息\n\n- 操作系统 CentOS 7.6 64 位\n- CPU 1 核\n- 内存 1 GB\n- 公网带宽 1 Mbps\n\n## 强大的管理工具\n\n- Xshell：强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。\n- WinSCP：WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 SCP 协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件\n- Xftp：Xftp 是一个功能强大的 SFTP、FTP 文件传输软件。使用了 Xftp 以后，MS Windows 用户能安全地在 UNIX/Linux 和 Windows PC 之间传输文件。\n\n## 安装 .NET Core SDK\n\n```shell\nsudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm\n\nsudo yum update\nsudo yum install dotnet-sdk-2.2\n\ndotnet --info\n```\n\n## 安装 Nginx\n\n```shell\ncurl -o  nginx.rpm http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\nrpm -ivh nginx.rpm\n\nyum install nginx\n\nsystemctl start nginx #启动nginx\nsystemctl enable nginx #设置nginx的开机启动\n```\n\n## Nginx 配置\n\n```shell\nserver {\n        listen 443 ssl;\n        server_name meowv.com;\n        ssl_certificate ssl/1_meowv.com_bundle.crt;\n        ssl_certificate_key ssl/2_meowv.com.key;\n        ssl_session_timeout 5m;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;\n        ssl_prefer_server_ciphers on;\n        # error_page 403 https://meowv.com;\n        location / {\n            # add_header Access-Control-Allow-Origin *;\n            # root   /qix/static;\n            proxy_pass http://localhost:5000;\n            proxy_set_header   X-Real-IP        $remote_addr;\n            proxy_set_header   Host             $host;\n            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n        }\n}\n\nserver {\n    listen 80;\n    server_name meowv.com;\n    rewrite ^(.*)$ https://meowv.com;\n}\n```\n\n## 安装 Supervisor 守护进程\n\n```shell\nyum install python-setuptools\n\neasy_install supervisor\n\nmkdir /etc/supervisor\necho_supervisord_conf > /etc/supervisor/supervisord.conf\n```\n\n## 配置 Supervisor\n\n找到文件 /etc/supervisor/supervisord.conf 去掉文件最后的注释并修改为\n\n```shell\n[include]\nfiles = conf.d/*.ini\n```\n\n在 /etc/supervisor/ 下新建文件夹 conf.d，conf.d 文件夹下新建 meowv.conf 文件，内容为\n\n```shell\n[program:meowv] #meowv为程序名称\ncommand=dotnet MeowvBlog.Web.dll #执行的命令\ndirectory=/qix/meowv # 命令执行的目录\nenvironment=ASPNETCORE__ENVIRONMENT=Production #环境变量\nuser=root #用户\nstopsignal=INT\nautostart=true #是否自启动\nautorestart=true #是否自动重启\nstartsecs=3 #自动重启时间间隔（s）\nstderr_logfile=/var/log/meowv.com.err.log #错误日志文件\nstdout_logfile=/var/log/meowv.com.out.log #输出日志文件\n```\n\n## 利用 crontab 定时执行 Python 爬虫任务\n\n在 Windows 平台我们可以使用任务计划程序运行定时任务，那么在 Linux 下有 crontab 帮我们实现\n\n可以用`crontab -e`命令来编辑`/var/spool/cron`下对应用户的`cron`文件，也可以直接编辑`/etc/crontab`\n\n```shell\n# Example of job definition:\n# .---------------- minute (0 - 59)\n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...\n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat\n# |  |  |  |  |\n*/30 * * * * /bin/python /qix/spider/spider.py #每30分钟执行一次\n\n```\n\n```shell\nsystemctl start  crond.service #启动\nsystemctl status  crond.service #查看状态\nsystemctl stop  crond.service #停止\nsystemctl restart  crond.service #重新启动\nsystemctl reload  crond.service #重新加载\n```\n\n## 常用命令\n\n```shell\ncd                 #目录跳转\ncd /               #回到根目录\nls                 #查看目录下的文件\ndf -h              #查看文件使用情况\nmkdir              #创建文件夹文件夹\nvi                 #编辑文件\n:wq!               #保存文件，并退出vi\nifconfig -a        #查看ip\nfree               #查看系统资源使用情况\nreboot             #重启系统\nnginx -s reload    #刷新nginx配置使其生效\nsupervisorctl start program_name   #启动某个进程(program_name=配置的进程名称)\nsupervisorctl stop program_name    #停止某一进程\nsupervisorctl reload               #重新启动配置中的所有程序\nsupervisorctl stop all             #停止全部进程\nsupervisorctl update               #更新新的配置到supervisord\nsupervisorctl restart program_name #重启某一进程\nsupervisorctl                      #查看正在守候的进程\n```\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Python",
      "CentOS",
      "Linux",
      "Nginx",
      "Supervisor",
      "crontab",
      "shell"
    ],
    "createdAt": "2019-08-15 13:12:15"
  },
  {
    "title": "利用SQL生成模型实体类",
    "author": "阿星Plus",
    "url": "2019-08-19-sql2model",
    "markdown": "```sql\nDECLARE @TableName sysname = 'TableName';\n\nDECLARE @Result VARCHAR(MAX) = 'public class ' + @TableName + '\n{';\n\nSELECT @Result = @Result + '\n\t/// <summary>\n    /// '        + CAST(t.Summary AS VARCHAR(MAX)) + '\n    /// </summary>\n    public '     + ColumnType + NullableSign + ' ' + ColumnName + ' { get; set; }\n'\nFROM\n(\n    SELECT REPLACE(col.name, ' ', '_') ColumnName,\n           col.column_id ColumnId,\n           CASE typ.name\n               WHEN 'bigint' THEN\n                   'long'\n               WHEN 'binary' THEN\n                   'byte[]'\n               WHEN 'bit' THEN\n                   'bool'\n               WHEN 'char' THEN\n                   'string'\n               WHEN 'date' THEN\n                   'DateTime'\n               WHEN 'datetime' THEN\n                   'DateTime'\n               WHEN 'datetime2' THEN\n                   'DateTime'\n               WHEN 'datetimeoffset' THEN\n                   'DateTimeOffset'\n               WHEN 'decimal' THEN\n                   'decimal'\n               WHEN 'float' THEN\n                   'float'\n               WHEN 'image' THEN\n                   'byte[]'\n               WHEN 'int' THEN\n                   'int'\n               WHEN 'money' THEN\n                   'decimal'\n               WHEN 'nchar' THEN\n                   'char'\n               WHEN 'ntext' THEN\n                   'string'\n               WHEN 'numeric' THEN\n                   'decimal'\n               WHEN 'nvarchar' THEN\n                   'string'\n               WHEN 'real' THEN\n                   'double'\n               WHEN 'smalldatetime' THEN\n                   'DateTime'\n               WHEN 'smallint' THEN\n                   'short'\n               WHEN 'smallmoney' THEN\n                   'decimal'\n               WHEN 'text' THEN\n                   'string'\n               WHEN 'time' THEN\n                   'TimeSpan'\n               WHEN 'timestamp' THEN\n                   'DateTime'\n               WHEN 'tinyint' THEN\n                   'byte'\n               WHEN 'uniqueidentifier' THEN\n                   'Guid'\n               WHEN 'varbinary' THEN\n                   'byte[]'\n               WHEN 'varchar' THEN\n                   'string'\n               ELSE\n                   'UNKNOWN_' + typ.name\n           END ColumnType,\n           CASE\n               WHEN col.is_nullable = 1\n                    AND typ.name IN ( 'bigint', 'bit', 'date', 'datetime', 'datetime2', 'datetimeoffset', 'decimal',\n                                      'float', 'int', 'money', 'numeric', 'real', 'smalldatetime', 'smallint',\n                                      'smallmoney', 'time', 'tinyint', 'uniqueidentifier'\n                                    ) THEN\n                   '?'\n               ELSE\n                   ''\n           END NullableSign,\n           ISNULL(ep.value, col.name) AS Summary\n    FROM sys.columns col\n        JOIN sys.types typ\n            ON col.system_type_id = typ.system_type_id\n               AND col.user_type_id = typ.user_type_id\n        LEFT JOIN sys.extended_properties ep\n            ON ep.major_id = col.object_id\n               AND ep.minor_id = col.column_id\n    WHERE col.object_id = OBJECT_ID(@TableName)\n) t\nORDER BY ColumnId;\n\nSET @Result = @Result + '\n}';\n\nPRINT @Result;\n```",
    "category": "Database",
    "tag": [
      "SqlServer",
      "SQL",
      "model"
    ],
    "createdAt": "2019-08-19 21:22:19"
  },
  {
    "title": "EPPlus.Core 处理 Excel 报错之天坑 WPS",
    "author": "阿星Plus",
    "url": "2019-08-21-epplus-wps-error",
    "markdown": "最近工作中常常有有数据处理的需求，一个Excel动不动就是上十万的数据量，在用 EPPlus.Core 导入数据入库的时候遇到了一个莫名其妙的问题 `The given key 'rId2' was not present in the dictionary.`\n\n我TM一个导入Excel，解析数据哪里来的 dictionary???\n\n然后开始了艰辛的调试debug之旅，反复上传导入都不行，然后自己创建了一个格式相同数据量比较少的Excel文件上传，成功。\n\n这时候我大概知道是什么问题了，给Excel数据的同事用的是WPS(这辈子都不会用的东东...)，由于EPPlus对WPS支持度不怎么友好，所以导致解析数据的时候出错，将WPS保存的Excel文件用Office Excel打开另存为一个新的文件，再上传解析，成功。\n\n```csharp\npublic async Task<ActionOutput> ProcessExcelData(IFormFile ExcelFile)\n{\n    using (var package = new ExcelPackage(ExcelFile.OpenReadStream()))\n    {\n        var sheet = package.Workbook.Worksheets.First();\n\n        ...\n\n        return new ActionOutput();\n    }\n}\n```\n\n切记：远离WPS，远离996..\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "EPPlus",
      "Excel",
      "WPS"
    ],
    "createdAt": "2019-08-21 11:00:21"
  },
  {
    "title": ".NET Core下操作Git，自动提交代码到 GitHub",
    "author": "阿星Plus",
    "url": "2019-08-21-netcore-worker-git",
    "markdown": ".NET Core 3.0 预览版发布已经好些时日了，博客园也已将其用于生产环境中，可见 .NET Core 日趋成熟\n\n回归正题，你想盖大楼吗？想 GitHub 首页一片绿吗？今天拿她玩玩自动提交代码至 GitHub。\n\n## 安装项目模板\n\n```shell\ndotnet new --install \"Microsoft.DotNet.Web.ProjectTemplates.3.0\"\ndotnet new worker\n```\n\n## 创建项目\n\n直接使用 .NET CLI 创建一个 Work Service 的项目\n\n```shell\ndotnet new worker -o AutomaticPush\n```\n\n用 Visual Studio 2019 打开项目可以看到以下代码\n\n```csharp\n// Program.cs\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        CreateHostBuilder(args).Build().Run();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureServices((hostContext, services) =>\n            {\n                services.AddHostedService<Worker>();\n            });\n}\n```\n\n- 从 3.0 起 WebHost 被 Host 取代了\n- `CreateHostBuilder`创建 Host 并在`ConfigureServices`中调用`.AddHostedService<Worker>()`\n\n```csharp\n// Worker.cs\npublic class Worker : BackgroundService\n{\n    private readonly ILogger<Worker> _logger;\n    public Worker(ILogger<Worker> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            _logger.LogInformation(\"Worker running at: {time}\", DateTimeOffset.Now);\n            await Task.Delay(1000, stoppingToken);\n        }\n    }\n}\n```\n\nWorker 继承了 BackgroundService，在 override ExecuteAsync 方法中完成自动提交的代码\n\n.NET 下操作 Git 需要用到一个库 `LibGit2Sharp`，同时支持 .NET Framework 及 .NET Core\n\n在项目中安装使用\n\n```shell\nInstall-Package LibGit2Sharp\n```\n\n## LibGit2Sharp 简单使用\n\n- `Repository.Init(@\"D:\\Work\")` 在指定路径创建一个新的 Git 仓库，相当于 `git init`\n\n- `Repository.Clone(\"https://github.com/Meowv/Blog.git\", @\"D:\\Work\")` 拉取一个远程仓库到本地，相当于 `git clone`\n\n- `using (var repo = new Repository(@\"D:\\Blog\")){}` 打开本地存在的 Git 仓库\n\n- 获取 Branch\n\n  ```csharp\n  using (var repo = new Repository(@\"D:\\Blog\"))\n  {\n      var branches = repo.Branches;\n\n      foreach (var item in branches)\n      {\n      }\n  }\n  ```\n\n- 获取 Commits\n\n  ```csharp\n  using (var repo = new Repository(@\"D:\\Blog\"))\n  {\n      foreach (var commit in repo.Commits)\n      {\n      }\n  }\n  ```\n\n- 获取 Tags\n\n  ```csharp\n  using (var repo = new Repository(@\"D:\\Blog\"))\n  {\n      foreach (var commit in repo.Tags)\n      {\n      }\n  }\n  ```\n\n- 更多操作请移步 https://github.com/libgit2/libgit2sharp\n\n## 自动 Push 代码盖大楼\n\n有了以上基础，就可以实现自动生成文件，push 代码到 GitHub 了。\n\n新建一个配置文件，存放我们 GitHub 仓库以及账号密码等重要信息\n\n```json\n{\n  \"repository\": \"本地git仓库绝对路径\",\n  \"username\": \"GitHub账号\",\n  \"password\": \"GitHub密码\",\n  \"name\": \"提交人\",\n  \"email\": \"邮箱\"\n}\n```\n\n在ExecuteAsync中读取配置文件信息\n\n```csharp\nvar configurationRoot = new ConfigurationBuilder().AddJsonFile(\"config.json\").Build();\n\nvar path = configurationRoot[\"repository\"];\nvar username = configurationRoot[\"username\"];\nvar password = configurationRoot[\"password\"];\nvar name = configurationRoot[\"name\"];\nvar email = configurationRoot[\"email\"];\n```\n\ngit会自动检测文件变化，所以就先自动按日期创建.log文件，不断生成内容然后提交\n\n```csharp\nwhile (!stoppingToken.IsCancellationRequested)\n{\n    var fileName = $\"{DateTime.Now.ToString(\"dd\")}.log\";\n    var content = DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\");\n\n    // 写入内容\n    WriteText(path, fileName, content);\n\n    using (var repo = new Repository(path))\n    {\n        // Stage the file\n        Commands.Stage(repo, \"*\");\n        // Create the committer's signature and commit\n        var author = new Signature(name, email, DateTime.Now);\n        var committer = author;\n        // Commit to the repository\n        var commit = repo.Commit(content, author, committer);\n        // git push\n        var options = new PushOptions\n        {\n            CredentialsProvider = new CredentialsHandler((url, usernameFromUrl, types) =>\n            {\n                return new UsernamePasswordCredentials()\n                {\n                    Username = username,\n                    Password = password\n                };\n            })\n        };\n        repo.Network.Push(repo.Branches[\"master\"], options);\n    }\n\n    Console.WriteLine(content);\n\n    // 等待60秒继续执行...\n    await Task.Delay(60000, stoppingToken);\n}\n\nprivate static void WriteText(string path, string fileName, string content)\n{\n    path = Path.Combine(path, DateTime.Now.ToString(@\"yyyy\\\\MM\"));\n    if (!Directory.Exists(path))\n    {\n        Directory.CreateDirectory(path);\n    }\n    var filePath = Path.Combine(path, fileName);\n    using var fs = new FileStream(filePath, FileMode.Append);\n    using var sw = new StreamWriter(fs);\n    sw.WriteLine(content);\n}\n```\n\n至此，整个代码编写部分结束，项目发布后可以选择sc.exe注册为Windows服务，在这里推荐使用nssm(一个服务封装程序)，好了，赶紧盖大楼去吧~~\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "git",
      "GitHub",
      "LibGit2Sharp"
    ],
    "createdAt": "2019-08-21 15:40:21"
  },
  {
    "title": "两枚Visual Studio 2019密钥",
    "author": "阿星Plus",
    "url": "2019-08-22-vs2019-key",
    "markdown": "Visual Studio 2019 Enterprise：`BF8Y8-GN2QH-T84XB-QVY3B-RC4DF`\n\nVisual Studio 2019 Professional：`NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y`",
    "category": "Other",
    "tag": [
      "Visual Studio"
    ],
    "createdAt": "2019-08-22 14:32:22"
  },
  {
    "title": "使用MTA HTML5统计API来分析数据",
    "author": "阿星Plus",
    "url": "2019-08-23-mta-package",
    "markdown": "在开发个人博客的时候，用到了腾讯移动分析(MTA)，相比其他数据统计平台来说我喜欢她的简洁高效，易上手，同时文档也比较全面，提供了数据接口供用户调用。\n\n在看了MTA演示[Demo](https://mta.qq.com/mta/manage/ctr_demo)和[官方文档](https://mta.qq.com/docs/)后，我就决定使用 .NET Core将其HTML5统计API进行封装，以供博客直接调用，省去各种鉴权生成sign的操作。\n\n首先需要在[MTA](https://mta.qq.com/)官网进行HTML5应用创建，当然她还支持小程序和移动App。\n\n![MTA](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/mta.png)\n\n然后就可以看到如上图的应用管理界面，如果你不打算使用其API接口，直接拿到统计代码嵌入在自己网站中即可，不出意外10分钟左右即可查看网站部分指标的实时数据，次日可以查看昨日的全部数据。\n\n接下来继续，在调用MTA接口之前需要先生成sign，\n\n> 双方维护同一份私钥，在发起请求的时候，发起方(合作方)将当前的请求参数数组，按照key值进行排序，然后'key=value'拼接到加密串后，进行md5的编码。接收方以同样的处理方式，对ts小于或等于30分钟的请求进行处理，sign一致则合法，否则失败。\n\n有了这段算法描述，利用C#代码实现如下：\n\n```csharp\n/// <summary>\n/// 生成sign\n/// </summary>\n/// <param name=\"keyValues\"></param>\n/// <returns></returns>\npublic static string GgenerateSign(this Dictionary<string, string> keyValues)\n{\n    keyValues.Add(\"app_id\", MtaConfig.App_Id);\n    IDictionary<string, string> sortedParams = new SortedDictionary<string, string>(keyValues);\n    var iterator = sortedParams.GetEnumerator();\n    var sb = new StringBuilder();\n    while (iterator.MoveNext())\n    {\n        var key = iterator.Current.Key;\n        var value = iterator.Current.Value;\n        if (key.IsNotNullOrEmpty() && value.IsNotNullOrEmpty())\n        {\n            sb.Append(key).Append(\"=\").Append(value);\n        }\n    }\n    return (MtaConfig.SECRET_KEY + sb.ToString()).Md5();\n}\n```\n\n将参数放入一个字典，并按照key值进行排序。因为所有接口都需要参数`app_id`，所以将其默认添加进去，不在额外当做参数。\n\n`.Md5()`是一个扩展方法，将字符串按照MD5方式加密\n\n拿到sign后就可以调用接口了，因为是封装，那么将所有接口都保存为静态变量，代码如下\n\n```csharp\n#region 应用趋势\n\n/// <summary>\n/// 应用历史趋势\n/// 每天的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_core_data = \"https://mta.qq.com/h5/api/ctr_core_data\";\n\n/// <summary>\n/// 应用实时小时数据\n/// 当天每小时的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_realtime = \"https://mta.qq.com/h5/api/ctr_realtime/get_by_hour\";\n\n/// <summary>\n/// 应用心跳数据\n/// 当前pv\\uv\\vv\\iv心跳数据数据\n/// </summary>\npublic static string Ctr_realtime_heartbeat = \"https://mta.qq.com/h5/api/ctr_realtime/heartbeat\";\n\n#endregion\n\n#region 访客分析\n\n/// <summary>\n/// 实时访客\n/// 在24小时内的实时访客信息\n/// </summary>\npublic static string Ctr_user_realtime = \"https://mta.qq.com/h5/api/ctr_user_realtime\";\n\n/// <summary>\n/// 新老访客比\n/// 按天查询当天新访客与旧访客的数量\n/// </summary>\npublic static string Ctr_user_compare = \"https://mta.qq.com/h5/api/ctr_user_compare\";\n\n/// <summary>\n/// 用户画像\n/// 查询用户画像数据，包含性别比例、年龄分布、学历分布、职业分布，数据为pv量\n/// </summary>\npublic static string Ctr_user_portrait = \"https://mta.qq.com/h5/api/ctr_user_portrait\";\n\n#endregion\n\n#region 客户端分析\n\n/// <summary>\n/// 地区数据\n/// 按天查询地区的pv\\uv\\vv\\iv量\n/// </summary>\npublic static string Ctr_area = \"https://mta.qq.com/h5/api/ctr_area/get_by_area\";\n\n/// <summary>\n/// 省市数据\n/// 按天查询省市下有流量的城市的pv\\uv\\vv\\iv量\n/// </summary>\npublic static string Ctr_area_province = \"https://mta.qq.com/h5/api/ctr_area/get_by_province\";\n\n/// <summary>\n/// 运营商\n/// 按天查询运营商的pv\\uv\\vv\\iv量\n/// </summary>\npublic static string Ctr_operator = \"https://mta.qq.com/h5/api/ctr_operator\";\n\n/// <summary>\n/// 终端属性列表\n/// 按天查询对应属性的终端信息数据\n/// </summary>\npublic static string Ctr_client_para = \"https://mta.qq.com/h5/api/ctr_client/get_by_para\";\n\n/// <summary>\n/// 终端信息\n/// 按天查询终端信息数据\n/// </summary>\npublic static string Ctr_client_content = \"https://mta.qq.com/h5/api/ctr_client/get_by_content\";\n\n#endregion\n\n#region 页面分析\n\n/// <summary>\n/// 页面排行-当天实时列表\n/// 查询当天所有url的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_page_realtime = \"https://mta.qq.com/h5/api/ctr_page/list_all_page_realtime\";\n\n/// <summary>\n/// 页面排行-离线列表\n/// 按天查询所有url的pv\\uv\\vv\\iv数据\n/// </summary>\npublic static string Ctr_page_offline = \"https://mta.qq.com/h5/api/ctr_page/list_all_page_offline\";\n\n/// <summary>\n/// 页面排行-指定查询部分url\n/// 按天查询url的pv\\uv\\vv\\iv数据。\n/// </summary>\npublic static string Ctr_page_url = \"https://mta.qq.com/h5/api/ctr_page\";\n\n/// <summary>\n/// 性能监控\n/// 按天查询对应省市的访问延时与解析时长\n/// </summary>\npublic static string Ctr_page_speed = \"https://mta.qq.com/h5/api/ctr_page_speed\";\n\n/// <summary>\n/// 访问深度\n/// 按天查询用户访问深度\n/// </summary>\npublic static string Ctr_page_depth = \"https://mta.qq.com/h5/api/ctr_depth\";\n\n#endregion\n\n#region 来源分析\n\n/// <summary>\n/// 外部链接\n/// 按天查询外部同站链接带来的流量情情况\n/// </summary>\npublic static string Ctr_source_out = \"https://mta.qq.com/h5/api/ctr_source_out\";\n\n/// <summary>\n/// 入口页面\n/// 按天查询用户最后访问的进入次数与跳出率\n/// </summary>\npublic static string Ctr_page_land = \"https://mta.qq.com/h5/api/ctr_page_land\";\n\n/// <summary>\n/// 离开页面\n/// 按天查询最后访问页面的离次数\n/// </summary>\npublic static string Ctr_page_exit = \"https://mta.qq.com/h5/api/ctr_page_exit\";\n\n#endregion\n\n#region 自定义事件\n\n/// <summary>\n/// 自定义事件\n/// 按天查询自定义事件的pv\\uv\\vv\\iv\n/// </summary>\npublic static string Ctr_custom = \"https://mta.qq.com/h5/api/ctr_custom\";\n\n#endregion\n\n#region 渠道效果统计\n\n/// <summary>\n/// 渠道效果统计\n/// 按天查询渠道的分析数据\n/// </summary>\npublic static string Ctr_adtag = \"https://mta.qq.com/h5/api/ctr_adtag\";\n\n#endregion\n```\n\n接下来对照文档生成URL的查询参数，然后访问接口拿到返回数据\n\n```csharp\n/// <summary>\n/// 生成URL查询参数\n/// </summary>\n/// <param name=\"keyValues\"></param>\n/// <returns></returns>\npublic static string GgenerateQuery(this Dictionary<string, string> keyValues)\n{\n    var sign = keyValues.GgenerateSign();\n\n    var query = \"?\";\n\n    keyValues.ForEach(x =>\n    {\n        query += $\"{x.Key}={x.Value}&\";\n    });\n\n    return $\"{query}sign={sign}\";\n}\n```\n\n```csharp\n/// <summary>\n/// 获取MTA接口返回数据\n/// </summary>\n/// <param name=\"keyValues\"></param>\n/// <returns></returns>\npublic static async Task<string> GetMTAData(this Dictionary<string, string> keyValues, string api)\n{\n    var url = $\"{api}{keyValues.GgenerateQuery()}\";\n\n    // HWRequest()和HWRequestResult()是扩展方法，可以选择自己熟悉HTTP请求方法\n    var hwr = url.HWRequest();\n    string result = hwr.HWRequestResult();\n\n    return await Task.FromResult(result);\n}\n```\n\n到这里基本上就结束了，只需对照MTA文档传入对应的参数即可拿到返回的数据了。\n\n以其中一个接口为例，应用历史趋势，获取每天的pv、uv、vv、iv数据\n\n```csharp\n/// <summary>\n/// 应用历史趋势\n/// 每天的pv\\uv\\vv\\iv数据\n/// </summary>\n/// <param name=\"start_date\">开始时间（Y-m-d）</param>\n/// <param name=\"end_date\">结束时间（Y-m-d）</param>\n/// <param name=\"idx\">查询指标(pv,uv,vv,iv)，使用“,”间隔</param>\n/// <returns></returns>\npublic async Task<string> Ctr_core_data(string start_date, string end_date, string idx)\n{\n    var keyValues = new Dictionary<string, string>\n    {\n        { \"start_date\", start_date },\n        { \"end_date\", end_date },\n        { \"idx\", idx }\n    };\n    return await keyValues.GetMTAData(MtaConfig.Ctr_core_data);\n}\n```\n\n在controller中进行调用\n\n```csharp\n/// <summary>\n/// 应用历史趋势\n/// 每天的pv\\uv\\vv\\iv数据\n/// </summary>\n/// <param name=\"start_date\">开始时间（Y-m-d）</param>\n/// <param name=\"end_date\">结束时间（Y-m-d）</param>\n/// <param name=\"idx\">查询指标(pv,uv,vv,iv)，使用“,”间隔</param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"ctr_core_data\")]\npublic async Task<dynamic> Ctr_core_data(string start_date, string end_date, string idx)\n{\n    var result = await _mtaService.Ctr_core_data(start_date, end_date, idx);\n\n    return result.DeserializeFromJson<dynamic>();\n}\n```\n\n查询结果看下图\n\n![MTAAPI](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/mtaapi.png)\n\n详细代码可参考：https://github.com/Meowv/Blog/tree/master/src/MeowvBlog.MTA\n",
    "category": ".NET",
    "tag": [
      "MTA",
      "数据分析",
      "API"
    ],
    "createdAt": "2019-08-23 10:47:23"
  },
  {
    "title": "我已经看到了，撤回也没用了(PC微信防撤回补丁)",
    "author": "阿星Plus",
    "url": "2019-08-29-revoke-wechart-msg-patcher",
    "markdown": "前两天看 GitHub 发现一个有趣的项目，[PC微信防撤回补丁](https://github.com/huiyadanli/RevokeMsgPatcher)，本着研究学习的目的，在看过源码，一顿疯狂操作之后，了解了其原理是基于修改 wechatwin.dll 达到防撤回的。\n\n于是乎，自己动手玩一玩，以下为详细步骤：\n\n首先下载 [x64dbg](https://github.com/x64dbg/x64dbg)，我这里使用的是 x32dbg，效果是一样的。\n\n打开 x32dbg.exe，打开微信扫码登录，附加微信进程，此时微信处于假死状态，暂时不要使用。\n\n![wx1](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx1.gif)\n\n点击菜单栏下面 Symbols 按钮，搜索 \"WeChatWin\"，找到 WeChatWin.dll，双击进入\n\n![wx2](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx2.png)\n\n在当前界面右键，搜索，当前区域，字符串，输入 \"revokemsg\" 搜索，然后找到第一个字符串为 \"revokemsg\" 的命令双击进入跳转到二进制程序\n\n![wx3](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx3.png)\n![wx4](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx4.png)\n\n分析发现进入防撤回前有一个 je 跳转语句，满足撤回条件就进入到撤回流程，不满足就跳转到别的地方，直接将这里修改成无条件跳转到别的不撤回的地方，就实现了防撤回功能。进入 revokemsg 二进制界面后，找到它的前的一个命令，是一个 je 开头的命令，双击将其修改为 jmp。\n\n![wx5](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx5.gif)\n\n此时整个补丁已经修改完成，右键点击\"Patches\"，另存为新的 WeChatWin.dll，关掉 x32dbg 和微信，将新的 WeChatWin.dll 覆盖微信安装目录下即可。\n\n![wx6](https://raw.githubusercontent.com/meowv/notes/master/.gitbook/assets/wx6.gif)\n\n现在重新打开微信，扫码登陆，然后用手机给自己发几条消息然后撤回一下试试看，如果手机上消息显示撤回，电脑上消息还在，那就说明成功了。这么简单还不去试试？\n",
    "category": "Other",
    "tag": [
      "GitHub",
      "x64dbg",
      "x32dbg",
      "补丁",
      "微信"
    ],
    "createdAt": "2019-08-29 11:25:29"
  },
  {
    "title": "Win10 1903 运行安卓模拟器蓝屏解决方案",
    "author": "阿星Plus",
    "url": "2019-08-30-win10-bsod",
    "markdown": "由于没有安卓机，想要测试一些东西，所以选择了安卓模拟器，可是一运行模拟器就导致电脑蓝屏，试了 N 次都不行。\n\n于是在网上寻找解决方案，了解到导致蓝屏的原因都是因为虚拟化技术，我的系统是 Windows10 1903，加上之前开启了 Hyper-V 虚拟机，和 Windows 沙盒，再加上 Win10 对于安卓模拟器的虚拟化兼容不够才一直崩溃。\n\n解决方案：关闭 Hyper-V 和 Windows 沙盒，运行以下命令，重启电脑。\n\n```bash\nDISM /Online /Disable-Feature /FeatureName:\"Containers-DisposableClientVM\"\nDISM /Online /Disable-Feature /FeatureName:\"Microsoft-Hyper-V-All\"\nDISM /Online /Disable-Feature /FeatureName:\"VirtualMachinePlatform\"\n```\n",
    "category": "Other",
    "tag": [
      "Windows",
      "安卓模拟器",
      "蓝屏"
    ],
    "createdAt": "2019-08-30 09:45:30"
  },
  {
    "title": "←2017，2019→",
    "author": "阿星Plus",
    "url": "2019-11-27-2017_2019",
    "markdown": "时间过得真快啊，都还没来得及做好迎接2020的准备。\n\n距离2019年结束，只剩下一个多月了。\n\n2017年：当年我是瓜子脸，2019年：我长成了西瓜脸\n\n还有双下巴！\n\n两年之间多长了几十斤肉的自己，没有一顿饭是无辜的！\n\n头越来越秃，黑眼圈越来越重！\n\n三年时间，也收获颇多。\n\n时间，总会改变很多东西\n\n也总有一些东西历久弥新\n\n变化的是年轮，不变的是初心",
    "category": "Life",
    "tag": [
      "总结"
    ],
    "createdAt": "2019-11-27 15:22:27"
  },
  {
    "title": "2019 年终总结",
    "author": "阿星Plus",
    "url": "2020-01-02-2019-summary",
    "markdown": "哇，2020年了，大家都奔小康了吗？\n\n越长大感觉时间过得越快，都20年了我还沉浸在19年的各种欢乐中。\n\n到目前为止，加上实习经验，工作也有四个年头了。也算得上一个职场老手了，经历了各种代码的洗礼。然而却发现自己没有上学时的那种学习精神了，时常写代码到凌晨的我，经常感叹：学不动了。\n\n作为程序员，只有不断学习新的知识才能在工作中游刃有余不被淘汰。我是一名 .net 后端开发工程师，今年2月份离开上家公司，到了新的公司开始了新的编码生涯。我要感谢我的女朋友(未婚妻)对我的支持和鼓励，还有她随我居无定所辗转反侧的奔波。\n\n在新的公司写代码感觉比在上家公司写代码愉快了不少，毕竟是跳槽，总不能越跳越糟吧，哈哈。\n\n- 技术上紧跟微软步伐，所有新项目都采用 .net core开发，同时我也负责维护一个公司的老项目，是 .net framework 的一个和OCR识别相关的项目，生产着公司的所有数据。\n\n- 团队规模更加完善，前后端分离让专业的人干专业的事，我所在的小组，主要负责后端数据接口，协调整个公司的数据支撑，配合 .net core 技术写着各种API。\n\n- 领导和小组成员Nice，技术牛逼，容易接触，领导好说话，请假容易(不会出现19年的情况了)。\n\n- 工资上涨了，可能这是最主要的原因吧！\n\n记录一下，19年的大事年表：\n\n- 2月份，开工第一天裸辞，于2月底正式离职\n- 3月初，和女票前往云南旅游，happy了一周，同时完成了第一次坐飞机的技能点\n- 3月中旬，找工作投简历面试，成功入职一家教育科技公司。体验了一周6点起床，挤地铁两小时上班的生活，果断在新公司附近找房子住，然后就是和上家房东退租，各种来回跑搬家等琐事\n- 4-5月份，按部就班在新公司写代码，了解新业务\n- 6月份，公司高峰期，全月无休，完成职业生涯第一次通宵加班的技能点\n- 7-9月份，公司业务高峰期过后，闲暇时间系统学了Python，然后调休一周在家宅着休息，哪也没去，现在有点后悔，时间比较长，应该利用这段时间回家见双方家长的，还有就是领养了一只蓝猫，喵喵喵，我的最爱\n- 10月份，带女朋友回家见了父母，爸妈很喜欢，同时我也见了我未来的老丈人和丈母娘，哇，现在想想和做梦一样，哈哈哈。\n- 11-12月份，在完成公司编码任务的同时，自学前端技术React(React基础知识、Redux、React Router、React Hooks、Next.js等等)，到现在仍在继续学习中，真是有趣\n\n工作之余，学习各种新技术，用 .net core 完成了个人博客 [https://meowv.com](https://meowv.com) 的开发重构工作，已开源，地址：https://github.com/Meowv/Blog ，欢迎 star。\n\n今天是1月2号，我已经买了1月18回家的火车票，准备和父母一起前往女朋友家拜访，哈哈哈，这应该算是订婚吧，希望一切顺利。",
    "category": "Summary",
    "tag": [
      "年终总结",
      "总结",
      "2020"
    ],
    "createdAt": "2020-01-02 10:55:02"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目",
    "author": "阿星Plus",
    "url": "2020-05-15-blog",
    "markdown": "## 项目介绍\n\n\n此版本个人博客项目底层基于 abp vNext (不完全依赖)搭建，和免费开源跨平台的 .NET Core 3.1 开发，支持各种主流数据库(SqlServer、MySQL、PostgreSql、Sqlite)一键切换，遵循 RESTful 接口规范，前端使用 Blazor 开发，可作为 .NET Core 入门项目进行学习。\n\n项目开源地址：https://github.com/Meowv/Blog\n\nIf you liked `Blog` project or if it helped you, please give a star ⭐️ for this repository. 👍👍👍\n\n---\n\n## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n```tree\nBlog ---------- root\n ├── .dockerignore ---------- docker ignore\n ├── .gitattributes ---------- git attributes\n ├── .gitignore ---------- git ignore\n ├── common.props ---------- common.props\n ├── Dockerfile ---------- Dockerfile\n ├── LICENSE ---------- LICENSE\n ├── Meowv.Blog.sln ---------- Solution\n ├── README.md ---------- README.md\n ├── src\n │   ├── Meowv.Blog.Application ---------- Application\n │   ├── Meowv.Blog.Application.Caching ---------- Application.Caching\n │   ├── Meowv.Blog.Application.Contracts ---------- Application.Contracts\n │   ├── Meowv.Blog.BackgroundJobs ---------- BackgroundJobs\n │   ├── Meowv.Blog.BlazorApp ---------- Blazor App\n │   ├── Meowv.Blog.Domain ---------- Domain\n │   ├── Meowv.Blog.Domain.Shared ---------- Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore ---------- EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations ---------- EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi ---------- HttpApi\n │   ├── Meowv.Blog.HttpApi.Hosting ---------- HttpApi.Hosting\n │   ├── Meowv.Blog.Swagger ---------- Swagger\n │   └── Meowv.Blog.ToolKits ---------- ToolKits\n └── static ---------- static\n```\n\n## 技术栈\n\nabp vNext + .NET Core 3.1 + Blazor + JWT + Redis + Hangfire + Mysql + SqlServer + Sqlite + PostgreSql + WebApi + EF Core + Swagger + HtmlAgilityPack + PuppeteerSharp + log4net + MailKit + Docker + Nginx + ...\n\n## 预览\n\n### Blog：\n\n![white](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515152658419-1391655969.jpg)\n![black](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515152704485-1341903403.jpg)\n\n### API：\n\n![api](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515152729014-592003613.jpg)\n\n### Hangfire：\n\n![hangfire](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515152741421-710857681.jpg)\n\n## LICENSE\n\nThis project is licensed under [MIT](LICENSE).\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext"
    ],
    "createdAt": "2020-05-15 15:33:15"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目",
    "author": "阿星Plus",
    "url": "2020-05-15-blog_01",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n首先，默认咱们已经有了.net core 3.1的开发环境，如果你没有，快去下载... https://dotnet.microsoft.com/download\n\n由于项目是基于abp vNext开发的，所以开发之前建议去撸一遍abp官方文档，https://docs.abp.io/en/abp/latest/\n\n创建项目有很多种方式：\n\n- 第一种，纯手撸，使用vs手动创建新项目\n- 第二种，借助abp模板直接傻瓜式下载，地址：http://abp.io/get-started\n- 第三种，abp cli(推荐)\n\n---\n\n## abp cli\n\nabp cli是使用ABP框架启动新解决方案的最快方法，那么前提是你要安装啊。\n\n`dotnet tool install -g Volo.Abp.Cli`\n\n如果你的版本比较低，使用下面命令进行更新\n\n`dotnet tool update -g Volo.Abp.Cli`\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515162159710-1612749796.png)\n\n更多使用方法，请参考 https://docs.abp.io/en/abp/latest/CLI\n\n## abp new\n\n终于进入主题了，使用命令\n\n`abp new <solution-name>` 创建博客项目\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163210215-348851009.png)\n\n默认会生成两个项目，一个aspnet-core，一个react-native。暂时干掉不需要项目吧，虽然react-native也很香，但是现在先忽略它。\n\n然后将aspnet-core文件夹下所有文件剪切至我们的根目录，于是就变成下面这个样子。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515163641981-332915042.png)\n\n至此，基于abp cli创建项目完成，用VS2019打开看看吧。\n\n此时整个目录结构是这样婶的~\n\n```tree\nblog_tutorial\n ├── common.props\n ├── Meowv.Blog.sln\n ├── Meowv.Blog.sln.DotSettings\n ├── src\n │   ├── Meowv.Blog.Application\n │   ├── Meowv.Blog.Application.Contracts\n │   ├── Meowv.Blog.DbMigrator\n │   ├── Meowv.Blog.Domain\n │   ├── Meowv.Blog.Domain.Shared\n │   ├── Meowv.Blog.EntityFrameworkCore\n │   ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n │   ├── Meowv.Blog.HttpApi\n │   ├── Meowv.Blog.HttpApi.Client\n │   └── Meowv.Blog.Web\n └── test\n     ├── Meowv.Blog.Application.Tests\n     ├── Meowv.Blog.Domain.Tests\n     ├── Meowv.Blog.EntityFrameworkCore.Tests\n     ├── Meowv.Blog.HttpApi.Client.ConsoleTestApp\n     ├── Meowv.Blog.TestBase\n     └── Meowv.Blog.Web.Tests\n```\n\n由于是基于abp开发，所有默认的项目帮我们引用了一些非常强大但是我们用不到或者不想用的功能，进一步优化项目结构，删掉不要的引用，美化美化。\n\n- 先干掉test文件夹吧，项目刚搭建测试个毛毛啊？**干掉不代表测试不重要**\n- 干掉Meowv.Blog.sln.DotSettings，目前来说没啥乱用\n- 添加了一个LICENSE\n- 再添加一个README.md文件\n- 再添加一个.github文件夹，请暂时忽略它，这个是GitHub Action所需\n- 干掉src\\Meowv.Blog.DbMigrator，有Meowv.Blog.EntityFrameworkCore.DbMigrations就够了\n- 干掉src\\Meowv.Blog.HttpApi.Client\n- 在src目录下新增项目Meowv.Blog.Application.Caching，用来处理应用服务缓存\n- 在src目录下新增项目Meowv.Blog.BackgroundJobs，用来处理后台定时任务\n- 在src目录下新增项目Meowv.Blog.Swagger，这里用来编写Swagger扩展、Filter等\n- 在src目录下新增项目Meowv.Blog.ToolKits，这里放公共的工具类、扩展方法\n- 修改项目名称Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，为了完美同时也可以去修改一下文件夹的名称哦\n- 在解决方案中新建解决方案文件夹solution-items，然后编辑Meowv.Blog.sln文件，修改Meowv.Blog.Web为Meowv.Blog.HttpApi.Hosting，再新增以下代码\n\n```\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"solution-items\", \"solution-items\", \"{731730B9-645C-430A-AB05-3FC2BED63614}\"\n      ProjectSection(SolutionItems) = preProject\n            .gitattributes = .gitattributes\n            .gitignore = .gitignore\n            common.props = common.props\n            LICENSE = LICENSE\n            README.md = README.md\n      EndProjectSection\nEndProject\n```\n\n现在整个项目变成了下面这个样子\n\n```tree\nblog_tutorial\n ├── common.props\n ├── LICENSE\n ├── Meowv.Blog.sln\n ├── README.md\n └── src\n     ├── Meowv.Blog.Application\n     ├── Meowv.Blog.Application.Caching\n     ├── Meowv.Blog.Application.Contracts\n     ├── Meowv.Blog.BackgroundJobs\n     ├── Meowv.Blog.Domain\n     ├── Meowv.Blog.Domain.Shared\n     ├── Meowv.Blog.EntityFrameworkCore\n     ├── Meowv.Blog.EntityFrameworkCore.DbMigrations\n     ├── Meowv.Blog.HttpApi\n     ├── Meowv.Blog.HttpApi.Hosting\n     ├── Meowv.Blog.Swagger\n     └── Meowv.Blog.ToolKits\n```\n\n编译一下，全部生成成功，到这里算是用abp cli成功搭建一个属于自己的项目，并且还做了响应的调整。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200515172859538-826216255.png)\n\n本章只是搭建了项目，后面将逐一分解，期待吗，骚年？\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext"
    ],
    "createdAt": "2020-05-15 17:31:15"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来",
    "author": "阿星Plus",
    "url": "2020-05-17-blog_02",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章已经成功创建了博客项目，但是abp默认给我们引用了许多项目中用不到的组件。\n\n本篇文章将给项目进行瘦身，删掉对我们来说暂时用不到的组件。讲解各个模块之间的关系，写一个Hello World，让其成功运行起来。\n\n## 给项目瘦身\n\n### Meowv.Blog.HttpApi.Hosting\n\n`Meowv.Blog.HttpApi.Hosting`相当于一个web项目，但这里主要依赖于`Meowv.Blog.HttpApi`模块，用来暴露我们的API的。\n\n删掉`Meowv.Blog.HttpApi.Hosting`项目中abp自己生成的文件和文件夹，只留下`Program.cs`和`Startup.cs`两个类。\n\n在abp中，每个模块都应该定义一个模块类，派生自`AbpModule`，那么就添加一个模块类`MeowvBlogHttpApiHostingModule.cs`\n\n`AbpModule`类中可以做 配置服务前和后的操作，应用程序初始化，应用程序初始化前和后，应用程序关闭和模块依赖等一系列操作，详看，https://docs.abp.io/en/abp/latest/Module-Development-Basics\n\n为了方便，在这里直接集成Autofac，来替换官方依赖注入，详看，https://docs.abp.io/zh-Hans/abp/latest/Autofac-Integration\n\n于是我们的模块类就变成下面这个样子。\n\n```CSharp\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Hosting;\nusing Volo.Abp;\nusing Volo.Abp.AspNetCore.Mvc;\nusing Volo.Abp.Autofac;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.HttpApi.Hosting\n{\n    [DependsOn(\n       typeof(AbpAspNetCoreMvcModule),\n       typeof(AbpAutofacModule)\n    )]\n    public class MeowvBlogHttpApiHostingModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            base.ConfigureServices(context);\n        }\n\n        public override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            var app = context.GetApplicationBuilder();\n            var env = context.GetEnvironment();\n\n            // 环境变量，开发环境\n            if (env.IsDevelopment())\n            {\n                // 生成异常页面\n                app.UseDeveloperExceptionPage();\n            }\n\n            // 路由\n            app.UseRouting();\n\n            // 路由映射\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n        }\n    }\n}\n```\n\n然后在`Startup.cs`使用，`services.AddApplication<MeowvBlogHttpApiHostingModule>();`\n\n继续修改`Program.cs`代码，如下：\n\n```CSharp\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.HttpApi.Hosting\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            await Host.CreateDefaultBuilder(args)\n                      .ConfigureWebHostDefaults(builder =>\n                      {\n                          builder.UseIISIntegration()\n                                 .UseStartup<Startup>();\n                      }).UseAutofac().Build().RunAsync();\n        }\n    }\n}\n```\n\n然后编辑一下项目文件，`Meowv.Blog.HttpApi.Hosting.csproj`，删掉无用的配置文件信息和abp默认引用的组件。\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Volo.Abp.Autofac\" Version=\"2.7.0\" />\n  \n    <ProjectReference Include=\"..\\Meowv.Blog.HttpApi\\Meowv.Blog.HttpApi.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n### Meowv.Blog.HttpApi\n\n`Meowv.Blog.HttpApi`职责主要是编写Controller，所有的API都写在这里，同时它要依赖于`Meowv.Blog.Application`模块\n\n先删掉Models文件夹和默认的Controller，修改默认模块类名称为：`MeowvBlogHttpApiModule`，并删掉无用的依赖项\n\n```CSharp\nusing Volo.Abp.Identity;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.HttpApi\n{\n    [DependsOn(\n        typeof(AbpIdentityHttpApiModule)\n    )]\n    public class MeowvBlogHttpApiModule : AbpModule\n    {\n\n    }\n}\n```\n\n编辑项目文件`Meowv.Blog.HttpApi.csproj`\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Volo.Abp.Identity.HttpApi\" Version=\"2.7.0\" />\n  </ItemGroup>\n\n</Project>\n```\n\n### Meowv.Blog.Application\n\n`Meowv.Blog.Application`为我们的应用服务层，在这里编写服务的接口以及对应的实现\n\n首先还是模块类，`MeowvBlogApplicationModule`，在这里我们应该集成缓存和AutoMapper，这个先留着，先把项目瘦身跑起来后面在说吧。\n\n```CSharp\nusing Volo.Abp.Identity;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Application\n{\n    [DependsOn(\n        typeof(AbpIdentityApplicationModule)\n    )]\n    public class MeowvBlogApplicationModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n          \n        }\n    }\n}\n```\n\n新建一个`MeowvBlogApplicationServiceBase.cs`继承自`ApplicationService`，然后就可以先写一个Hello World的应用服务接口和实现。\n\n```CSharp\n//IHelloWorldService.cs\nnamespace Meowv.Blog.Application.HelloWorld\n{\n    public interface IHelloWorldService\n    {\n        string HelloWorld();\n    }\n}\n```\n\n```CSharp\n//HelloWorldService.cs\nnamespace Meowv.Blog.Application.HelloWorld.Impl\n{\n    public class HelloWorldService : ServiceBase, IHelloWorldService\n    {\n        public string HelloWorld()\n        {\n            return \"Hello World\";\n        }\n    }\n}\n```\n\n> 这里有两点需要注意，我们的服务都以Service结尾，每个服务都应该继承我们编写的的基类`ServiceBase`\n\n然后在`Meowv.Blog.HttpApi`层中添引用：`Meowv.Blog.Application`，同时添加依赖模块类，`MeowvBlogApplicationModule`\n\n```CSharp\n//MeowvBlogHttpApiModule.cs\nusing Meowv.Blog.Application;\nusing Volo.Abp.Identity;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.HttpApi\n{\n    [DependsOn(\n        typeof(AbpIdentityHttpApiModule),\n        typeof(MeowvBlogApplicationModule)\n    )]\n    public class MeowvBlogHttpApiModule : AbpModule\n    {\n\n    }\n}\n```\n\n## 让它跑起来\n\n好了，完成以上步骤，基本上差不多了，在`Meowv.Blog.HttpApi`中新增一个 Controller，`HelloWorldController.cs`\n\n```CSharp\nusing Meowv.Blog.Application.HelloWorld;\nusing Microsoft.AspNetCore.Mvc;\nusing Volo.Abp.AspNetCore.Mvc;\n\nnamespace Meowv.Blog.HttpApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class HelloWorldController : AbpController\n    {\n        private readonly IHelloWorldService _helloWorldService;\n\n        public HelloWorldController(IHelloWorldService helloWorldService)\n        {\n            _helloWorldService = helloWorldService;\n        }\n\n        [HttpGet]\n        public string HelloWorld()\n        {\n            return _helloWorldService.HelloWorld();\n        }\n    }\n}\n```\n\nok，运行一下`Meowv.Blog.HttpApi.Hosting`试试看，不出意料应该会报错的，因为我们在启动层`Meowv.Blog.HttpApi.Hosting`没有依赖`MeowvBlogHttpApiModule`模块，添加上试试\n\n```CSharp\n...\n    [DependsOn(\n       typeof(AbpAspNetCoreMvcModule),\n       typeof(AbpAutofacModule),\n       typeof(MeowvBlogHttpApiModule)\n    )]\n    public class MeowvBlogHttpApiHostingModule : AbpModule\n    {\n        ...\n    }\n...\n```\n\n搞定，成功出现Hello World，目标圆满完成。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200517123252334-230893510.png)\n\n放一张此时项目的层级目录，以供参考\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200517125505684-525194586.png)\n\n以上就是本章全部内容，暂时只用到了其中三个项目层便成功运行，由于时间问题，其中还有许多需要完善的地方没有操作，但后续用到的时候会逐步优化掉。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext"
    ],
    "createdAt": "2020-05-17 13:13:17"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场",
    "author": "阿星Plus",
    "url": "2020-05-18-blog_03",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章已经成功将博客项目跑起来了，那么本篇主要是将之前遗留的问题解决，现在的代码看起来可能还是比较混乱，有大量与之无关的代码存在里面，对于强迫症患者来说真的是零容忍。\n\n在程序员界，总有一批强迫症患者，他们希望自己写的代码看起来尽量的完美无瑕疵。\n\n## 完善与美化\n\n直奔主题，首先将各项目层的项目文件(`.csproj`)打开，格式化一下，没有引用`<Import Project=\"..\\..\\common.props\" />`这句代码的也加一下，这里其实就是将公共属性拿出来，没什么特殊的。\n\n`common.props`中的代码也非常简单，主要是禁用当开启输出XML的时候没有给代码进行summary注释产生的警告，其实这些大可不必为之折腾，不影响项目的成功运行。如果您觉得没啥必要，完全可以跳过此小节看最后。\n\n### .Application\n\n`.Application`层现在只引用`Volo.Abp.Identity.Application`包，和依赖`.Application.Caching`、`.Application.Contracts`、`.Domain`三个项目。\n\n```xml\n//Meowv.Blog.Application.csproj\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Volo.Abp.Identity.Application\" Version=\"2.7.0\" />\n  \n    <ProjectReference Include=\"..\\Meowv.Blog.Application.Caching\\Meowv.Blog.Application.Caching.csproj\" />\n    <ProjectReference Include=\"..\\Meowv.Blog.Application.Contracts\\Meowv.Blog.Application.Contracts.csproj\" />\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain.Shared\\Meowv.Blog.Domain.Shared.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n### .Application.Caching\n\n`.Application.Caching`层看名字就知道，我准备用它来处理缓存，这里会用到两个包，`Volo.Abp.Caching`、`Microsoft.Extensions.Caching.Redis`。\n\n不管三七二十一，新建一个模块类`MeowvBlogApplicationCachingModule.cs`，依赖于`AbpCachingModule`和我们的`MeowvBlogDomainModule`模块(此时还没添加)\n\n```CSharp\nusing Volo.Abp.Caching;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Application.Caching\n{\n    [DependsOn(\n        typeof(AbpCachingModule)\n        // ...\n    )]\n    public class MeowvBlogApplicationCachingModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            base.ConfigureServices(context);\n        }\n    }\n}\n```\n\n```xml\n//Meowv.Blog.Application.Caching.csproj\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.Extensions.Caching.Redis\" Version=\"2.2.0\" />\n    <PackageReference Include=\"Volo.Abp.Caching\" Version=\"2.7.0\" />\n  \n    <ProjectReference Include=\"..\\Meowv.Blog.Application.Contracts\\Meowv.Blog.Application.Contracts.csproj\" />\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain.Shared\\Meowv.Blog.Domain.Shared.csproj\" />\n    <ProjectReference Include=\"..\\Meowv.Blog.ToolKits\\Meowv.Blog.ToolKits.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n### .Application.Contracts\n\n删掉里面所有文件，`.Application.Contracts`层我不准备按照abp那样来做，此层我只想用来放我们的传输对象(DTO)，添加项目引用`Domain.Shared`，同时开启输出XML文件到我们`.HttpApi.Hosting`\n\n输出XML很简单，在 Visual Studio 中对着项目 右键=>属性=>生成=>输出，然后选择XML文档文件，默认为一个物理路径，我们将其改为相对路径`..\\Meowv.Blog.HttpApi.Hosting\\Meowv.Blog.Application.Contracts.xml`，XML输出到`.HttpApi.Hosting`层。\n\n也可以直接修改项目文件实现，如下\n\n```xml\n//Meowv.Blog.Application.Contracts.csproj\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|AnyCPU'\">\n    <DocumentationFile>..\\Meowv.Blog.HttpApi.Hosting\\Meowv.Blog.Application.Contracts.xml</DocumentationFile>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain.Shared\\Meowv.Blog.Domain.Shared.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n### .Domain\n\n`.Domain`层为我们的实体领域模型，不需要引用其它层，只添加包`Volo.Abp.Identity.Domain`，同时也输出一下XML文件，XML文件的作用后续Swagger会用的。\n\n```xml\n//Meowv.Blog.Domain.csproj\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|AnyCPU'\">\n    <DocumentationFile>..\\Meowv.Blog.HttpApi.Hosting\\Meowv.Blog.Domain.xml</DocumentationFile>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Volo.Abp.Identity.Domain\" Version=\"2.7.0\" />\n\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain.Shared\\Meowv.Blog.Domain.Shared.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n删掉此层所有文件，不要忘了添加模块类，`MeowvBlogDomainModule.cs`，它依赖`AbpIdentityDomainModule`模块\n\n```CSharp\nusing Volo.Abp.Identity;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Domain\n{\n    [DependsOn(typeof(AbpIdentityDomainModule))]\n    public class MeowvBlogDomainModule : AbpModule\n    {\n\n    }\n}\n```\n\n此时上面`.Application.Caching`中可以将`MeowvBlogDomainModule`加上了。\n\n```CSharp\n//MeowvBlogApplicationCachingModule.cs\n...\n    [DependsOn(\n        typeof(AbpCachingModule),\n        typeof(MeowvBlogDomainModule)\n    )]\n    public class MeowvBlogApplicationCachingModule : AbpModule\n    {\n        ...\n    }\n...\n```\n\n### .Domain.Shared\n\n`.Domain.Shared`层相当于`.Domain`的一个扩展一样，这里放一下项目用到的枚举、公共常量等内容，需要引用我们的`.Domain`项目\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain\\Meowv.Blog.Domain.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n还是要新增一个模块类`MeowvBlogDomainSharedModule.cs`，它依赖`AbpIdentityDomainSharedModule`模块\n\n```CSharp\n//MeowvBlogDomainSharedModule.cs\nusing Volo.Abp.Identity;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Domain\n{\n    [DependsOn(typeof(AbpIdentityDomainModule))]\n    public class MeowvBlogDomainModule : AbpModule\n    {\n    }\n}\n```\n\n### .EntityFrameworkCore\n\n`.EntityFrameworkCore`层同样的，先删掉默认生成的文件。它主要是集成了EF Core，自定义仓储。详细可以看看abp文档：https://docs.abp.io/zh-Hans/abp/latest/Repositories\n\n它支持多种数据库 MySQL、SqlServer、PostgreSql、Sqlite等，如果你有用到MongoDB，则需要新建一个项目，单独实现。可以看官方文档，有时间可以分享具体方法，本项目用不到。https://docs.abp.io/zh-Hans/abp/latest/MongoDB\n\n为了方便大家，我把以上4种主流数据库都集成到项目中，添加包`Volo.Abp.EntityFrameworkCore.MySQL`，`.PostgreSql`、`.Sqlite`、`.SqlServer`，同时引用`.Domain.Shared`项目\n\n```xml\n//Meowv.Blog.EntityFrameworkCore.csproj\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <PackageReference Include=\"Volo.Abp.EntityFrameworkCore.MySQL\" Version=\"2.7.0\" />\n    <PackageReference Include=\"Volo.Abp.EntityFrameworkCore.PostgreSql\" Version=\"2.7.0\" />\n    <PackageReference Include=\"Volo.Abp.EntityFrameworkCore.Sqlite\" Version=\"2.7.0\" />\n    <PackageReference Include=\"Volo.Abp.EntityFrameworkCore.SqlServer\" Version=\"2.7.0\" />\n\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain.Shared\\Meowv.Blog.Domain.Shared.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n新建一个模块类`MeowvBlogFrameworkCoreModule.cs`，依赖`MeowvBlogDomainModule`和数据库模块\n\n```CSharp\n//MeowvBlogFrameworkCoreModule.cs\nusing Meowv.Blog.Domain;\nusing Volo.Abp.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore.MySQL;\nusing Volo.Abp.EntityFrameworkCore.PostgreSql;\nusing Volo.Abp.EntityFrameworkCore.Sqlite;\nusing Volo.Abp.EntityFrameworkCore.SqlServer;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.EntityFrameworkCore\n{\n    [DependsOn(\n        typeof(MeowvBlogDomainModule),\n        typeof(AbpEntityFrameworkCoreModule),\n        typeof(AbpEntityFrameworkCoreMySQLModule),\n        typeof(AbpEntityFrameworkCoreSqlServerModule),\n        typeof(AbpEntityFrameworkCorePostgreSqlModule),\n        typeof(AbpEntityFrameworkCoreSqliteModule)\n    )]\n    public class MeowvBlogFrameworkCoreModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n\n        }\n    }\n}\n```\n\n### .EntityFrameworkCore.DbMigrations\n\n`.EntityFrameworkCore.DbMigrations`层主要做数据库迁移，用code-first方式创建数据库表，先删掉默认生成的文件，目前还用不上，后面讲。\n\n### .ToolKits\n\n`.ToolKits`层是我们手动创建的项目，我主要用它来包装一些扩展方法，公共的工具类。\n\n## Swagger登场\n\n做.net core开发的，相信Swagger的使用大家应该都很熟悉了，不做过多的介绍，今天只先将其用上看看效果。\n\n我单独为Swagger新建了一个项目`Meowv.Blog.Swagger`，其实大可不必，直接写在`.HttpApi.Hosting`中也是一样的。\n\n添加`Volo.Abp.AspNetCore`和`Swashbuckle.AspNetCore`包，引用实体层`.Domain`。\n\n```xml\n//Meowv.Blog.Swagger.csproj\n<Project Sdk=\"Microsoft.NET.Sdk\">\n\n  <Import Project=\"..\\..\\common.props\" />\n\n  <PropertyGroup>\n    <TargetFramework>netcoreapp3.1</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Volo.Abp.AspNetCore\" Version=\"2.7.0\" />\n    <PackageReference Include=\"Swashbuckle.AspNetCore\" Version=\"5.4.1\" />\n\n    <ProjectReference Include=\"..\\Meowv.Blog.Domain\\Meowv.Blog.Domain.csproj\" />\n  </ItemGroup>\n\n</Project>\n```\n\n添加模块类`MeowvBlogSwaggerModule.cs`，依赖`MeowvBlogDomainModule`模块，并且重写`ConfigureServices`和`OnApplicationInitialization`方法，不知道这是什么的，可以看文档：https://docs.abp.io/zh-Hans/abp/latest/Module-Development-Basics\n\n然后新建一个扩展类`MeowvBlogSwaggerExtensions.cs`，编写两个扩展方法`AddSwagger`和`UseSwaggerUI`。\n\n在`AddSwagger`方法中引用我们的XML文件，配置接口的名称版本以及描述信息，在`UseSwaggerUI`方法中使用SwaggerUI，代码如下：\n\n```CSharp\n//MeowvBlogSwaggerExtensions.cs\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.OpenApi.Models;\nusing System;\nusing System.IO;\n\nnamespace Meowv.Blog.Swagger\n{\n    public static class MeowvBlogSwaggerExtensions\n    {\n        public static IServiceCollection AddSwagger(this IServiceCollection services)\n        {\n            return services.AddSwaggerGen(options =>\n            {\n                options.SwaggerDoc(\"v1\", new OpenApiInfo\n                {\n                    Version = \"1.0.0\",\n                    Title = \"我的接口啊\",\n                    Description = \"接口描述\"\n                });\n\n                options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, \"Meowv.Blog.HttpApi.xml\"));\n                options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, \"Meowv.Blog.Domain.xml\"));\n                options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, \"Meowv.Blog.Application.Contracts.xml\"));\n            });\n        }\n\n        public static void UseSwaggerUI(this IApplicationBuilder app)\n        {\n            app.UseSwaggerUI(options =>\n            {\n                options.SwaggerEndpoint($\"/swagger/v1/swagger.json\", \"默认接口\");\n            });\n        }\n    }\n}\n```\n\n随后便可以在模块`MeowvBlogDomainModule`中引用了\n\n```CSharp\n//MeowvBlogSwaggerModule.cs\nusing Meowv.Blog.Domain;\nusing Microsoft.AspNetCore.Builder;\nusing Volo.Abp;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Swagger\n{\n    [DependsOn(typeof(MeowvBlogDomainModule))]\n    public class MeowvBlogSwaggerModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            context.Services.AddSwagger();\n        }\n\n        public override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            context.GetApplicationBuilder().UseSwagger().UseSwaggerUI();\n        }\n    }\n}\n```\n\n最后在`.HttpApi.Hosting`层的的启动模块中引用一下。\n\n```\n//MeowvBlogHttpApiHostingModule.cs\n...\n    [DependsOn(\n       typeof(AbpAspNetCoreMvcModule),\n       typeof(AbpAutofacModule),\n       typeof(MeowvBlogHttpApiModule),\n       typeof(MeowvBlogSwaggerModule),\n       typeof(MeowvBlogFrameworkCoreModule)\n    )]\n    public class MeowvBlogHttpApiHostingModule : AbpModule\n    {\n        ...\n    }\n...\n```\n\n`Ctrl + Shift + B`生成解决方案，`Ctrl+F5`打开 .../swagger/index.html 看看效果，上面有一个坑没有填，不知道大家发现了没有，`Meowv.Blog.HttpApi.xml`没有生成，启动是是会报错的，大家按照之前的方法自行生成XML即可。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518122623204-1818824243.png)\n\n棒！预期已经达到了。Swagger之所以想单独创建一个项目是因为还涉及到很多内容，如接口分组、JWT授权、还有Swagger文档描述信息的Filter等。\n\n项目中还剩下`.BackgroundJobs`层没有处理，此层准备集成`Hangfire`做一个定时任务处理的，后面会慢慢用起来的。\n\n现在再回头看看，项目是不是很清爽? 没有乱七八糟的东西，有的只是我们需要的。\n\n此时的层级目录，以供参考。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518123714509-857770767.png)\n\n项目中可能有许多不是很合理的地方，请酌情参考。因为大佬们都不愿意出来分享，所以我们渣渣只能做到这种程度，如果有错误欢迎指正，谢谢。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "Swagger"
    ],
    "createdAt": "2020-05-18 16:50:18"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先",
    "author": "阿星Plus",
    "url": "2020-05-19-blog_04",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章完善了项目中的代码，接入了Swagger。本篇主要使用Entity Framework Core完成对数据库的访问，以及使用Code-First的方式进行数据迁移，自动创建表结构。\n\n## 数据访问\n\n在`.EntityFrameworkCore`项目中添加我们的数据访问上下文对象`MeowvBlogDbContext`，继承自 `AbpDbContext<T>`。然后重写`OnModelCreating`方法。\n\n`OnModelCreating`：定义EF Core 实体映射。先调用 `base.OnModelCreating` 让 abp 框架为我们实现基础映射，然后调用`builder.Configure()`扩展方法来配置应用程序的实体。当然也可以不用扩展，直接写在里面，这样一大坨显得不好看而已。\n\n在abp框架中，可以使用 `[ConnectionStringName]` Attribute 为我们的DbContext配置连接字符串名称。先加上，然后再在`appsettings.json`中进行配置，因为之前集成了多个数据库，所以这里我们也配置多个连接字符串，与之对应。\n\n本项目默认采用MySql，你可以选择任意你喜欢的。\n\n```CSharp\n//MeowvBlogDbContext.cs\nusing Microsoft.EntityFrameworkCore;\nusing Volo.Abp.Data;\nusing Volo.Abp.EntityFrameworkCore;\n\nnamespace Meowv.Blog.EntityFrameworkCore\n{\n    [ConnectionStringName(\"MySql\")]\n    public class MeowvBlogDbContext : AbpDbContext<MeowvBlogDbContext>\n    {\n        public MeowvBlogDbContext(DbContextOptions<MeowvBlogDbContext> options) : base(options)\n        {\n        }\n\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            base.OnModelCreating(modelBuilder);\n\n            modelBuilder.Configure();\n        }\n    }\n}\n```\n\n```json\n//appsettings.json\n{\n  \"ConnectionStrings\": {\n    \"Enable\": \"MySQL\",\n    \"MySql\": \"Server=localhost;User Id=root;Password=123456;Database=meowv_blog_tutorial\",\n    \"SqlServer\": \"\",\n    \"PostgreSql\": \"\",\n    \"Sqlite\": \"\"\n  }\n}\n```\n\n然后新建我们的扩展类`MeowvBlogDbContextModelCreatingExtensions.cs`和扩展方法`Configure()`。注意，扩展方法是静态的，需加`static`\n\n```CSharp\n//MeowvBlogDbContextModelCreatingExtensions.cs\nusing Microsoft.EntityFrameworkCore;\nusing Volo.Abp;\n\nnamespace Meowv.Blog.EntityFrameworkCore\n{\n    public static class MeowvBlogDbContextModelCreatingExtensions\n    {\n        public static void Configure(this ModelBuilder builder)\n        {\n            Check.NotNull(builder, nameof(builder));\n            ...\n        }\n    }\n}\n```\n\n完成上述操作后在我们的模块类`MeowvBlogFrameworkCoreModule`中将DbContext注册到依赖注入，根据你配置的值使用不同的数据库。在`.Domain`层创建配置文件访问类`AppSettings.cs`\n\n```CSharp\n//AppSettings.cs\nusing Microsoft.Extensions.Configuration;\nusing System.IO;\n\nnamespace Meowv.Blog.Domain.Configurations\n{\n    /// <summary>\n    /// appsettings.json配置文件数据读取类\n    /// </summary>\n    public class AppSettings\n    {\n        /// <summary>\n        /// 配置文件的根节点\n        /// </summary>\n        private static readonly IConfigurationRoot _config;\n\n        /// <summary>\n        /// Constructor\n        /// </summary>\n        static AppSettings()\n        {\n            // 加载appsettings.json，并构建IConfigurationRoot\n            var builder = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory())\n                                                    .AddJsonFile(\"appsettings.json\", true, true);\n            _config = builder.Build();\n        }\n\n        /// <summary>\n        /// EnableDb\n        /// </summary>\n        public static string EnableDb => _config[\"ConnectionStrings:Enable\"];\n\n        /// <summary>\n        /// ConnectionStrings\n        /// </summary>\n        public static string ConnectionStrings => _config.GetConnectionString(EnableDb);\n    }\n}\n```\n\n获取配置文件内容比较容易，代码中有注释也很容易理解。\n\n值得一提的是，ABP会自动为DbContext中的实体创建默认仓储. 需要在注册的时使用options添加`AddDefaultRepositories()`。\n\n默认情况下为每个实体创建一个仓储，如果想要为其他实体也创建仓储，可以将 `includeAllEntities` 设置为 true，然后就可以在服务中注入和使用 `IRepository<TEntity>` 或 `IQueryableRepository<TEntity>`\n\n```CSharp\n//MeowvBlogFrameworkCoreModule.cs\nusing Meowv.Blog.Domain;\nusing Meowv.Blog.Domain.Configurations;\nusing Microsoft.Extensions.DependencyInjection;\nusing Volo.Abp.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore.MySQL;\nusing Volo.Abp.EntityFrameworkCore.PostgreSql;\nusing Volo.Abp.EntityFrameworkCore.Sqlite;\nusing Volo.Abp.EntityFrameworkCore.SqlServer;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.EntityFrameworkCore\n{\n    [DependsOn(\n        typeof(MeowvBlogDomainModule),\n        typeof(AbpEntityFrameworkCoreModule),\n        typeof(AbpEntityFrameworkCoreMySQLModule),\n        typeof(AbpEntityFrameworkCoreSqlServerModule),\n        typeof(AbpEntityFrameworkCorePostgreSqlModule),\n        typeof(AbpEntityFrameworkCoreSqliteModule)\n    )]\n    public class MeowvBlogFrameworkCoreModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            context.Services.AddAbpDbContext<MeowvBlogDbContext>(options =>\n            {\n                options.AddDefaultRepositories(includeAllEntities: true);\n            });\n\n            Configure<AbpDbContextOptions>(options =>\n            {\n                switch (AppSettings.EnableDb)\n                {\n                    case \"MySQL\":\n                        options.UseMySQL();\n                        break;\n                    case \"SqlServer\":\n                        options.UseSqlServer();\n                        break;\n                    case \"PostgreSql\":\n                        options.UsePostgreSql();\n                        break;\n                    case \"Sqlite\":\n                        options.UseSqlite();\n                        break;\n                    default:\n                        options.UseMySQL();\n                        break;\n                }\n            });\n        }\n    }\n}\n```\n\n现在可以来初步设计博客所需表为：发表文章表(posts)、分类表(categories)、标签表(tags)、文章对应标签表(post_tags)、友情链接表(friendlinks)\n\n在`.Domain`层编写实体类，Post.cs、Category.cs、Tag.cs、PostTag.cs、FriendLink.cs。把主键设置为int型，直接继承Entity<int>。关于这点可以参考ABP文档，https://docs.abp.io/zh-Hans/abp/latest/Entities\n\n<details>\n<summary>点击查看代码</summary>\n\n```CSharp\n//Post.cs\nusing System;\nusing Volo.Abp.Domain.Entities;\n\nnamespace Meowv.Blog.Domain.Blog\n{\n    /// <summary>\n    /// Post\n    /// </summary>\n    public class Post : Entity<int>\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 作者\n        /// </summary>\n        public string Author { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string Url { get; set; }\n\n        /// <summary>\n        /// HTML\n        /// </summary>\n        public string Html { get; set; }\n\n        /// <summary>\n        /// Markdown\n        /// </summary>\n        public string Markdown { get; set; }\n\n        /// <summary>\n        /// 分类Id\n        /// </summary>\n        public int CategoryId { get; set; }\n\n        /// <summary>\n        /// 创建时间\n        /// </summary>\n        public DateTime CreationTime { get; set; }\n    }\n}\n```\n\n```CSharp\n//Category.cs\nusing Volo.Abp.Domain.Entities;\n\nnamespace Meowv.Blog.Domain.Blog\n{\n    /// <summary>\n    /// Category\n    /// </summary>\n    public class Category : Entity<int>\n    {\n        /// <summary>\n        /// 分类名称\n        /// </summary>\n        public string CategoryName { get; set; }\n\n        /// <summary>\n        /// 展示名称\n        /// </summary>\n        public string DisplayName { get; set; }\n    }\n}\n```\n\n```CSharp\n//Tag.cs\nusing Volo.Abp.Domain.Entities;\n\nnamespace Meowv.Blog.Domain.Blog\n{\n    /// <summary>\n    /// Tag\n    /// </summary>\n    public class Tag : Entity<int>\n    {\n        /// <summary>\n        /// 标签名称\n        /// </summary>\n        public string TagName { get; set; }\n\n        /// <summary>\n        /// 展示名称\n        /// </summary>\n        public string DisplayName { get; set; }\n    }\n}\n```\n\n```CSharp\n//PostTag.cs\nusing Volo.Abp.Domain.Entities;\n\nnamespace Meowv.Blog.Domain.Blog\n{\n    /// <summary>\n    /// PostTag\n    /// </summary>\n    public class PostTag : Entity<int>\n    {\n        /// <summary>\n        /// 文章Id\n        /// </summary>\n        public int PostId { get; set; }\n\n        /// <summary>\n        /// 标签Id\n        /// </summary>\n        public int TagId { get; set; }\n    }\n}\n```\n\n```CSharp\n//FriendLink.cs\nusing Volo.Abp.Domain.Entities;\n\nnamespace Meowv.Blog.Domain.Blog\n{\n    /// <summary>\n    /// FriendLink\n    /// </summary>\n    public class FriendLink : Entity<int>\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string LinkUrl { get; set; }\n    }\n}\n```\n\n</details>\n\n创建好实体类后，在`MeowvBlogDbContext`添加DbSet属性\n\n```CSharp\n//MeowvBlogDbContext.cs\n...\n    [ConnectionStringName(\"MySql\")]\n    public class MeowvBlogDbContext : AbpDbContext<MeowvBlogDbContext>\n    {\n        public DbSet<Post> Posts { get; set; }\n\n        public DbSet<Category> Categories { get; set; }\n\n        public DbSet<Tag> Tags { get; set; }\n\n        public DbSet<PostTag> PostTags { get; set; }\n\n        public DbSet<FriendLink> FriendLinks { get; set; }\n\n        ...\n    }\n...\n```\n\n在`.Domain.Shared`层添加全局常量类`MeowvBlogConsts.cs`和表名常量类`MeowvBlogDbConsts.cs`，搞一个表前缀的常量，我这里写的是`meowv_`，大家可以随意。代表我们的表名都将以`meowv_`开头。然后在`MeowvBlogDbConsts`中将表名称定义好。\n\n```CSharp\n//MeowvBlogConsts.cs\nnamespace Meowv.Blog.Domain.Shared\n{\n    /// <summary>\n    /// 全局常量\n    /// </summary>\n    public class MeowvBlogConsts\n    {\n        /// <summary>\n        /// 数据库表前缀\n        /// </summary>\n        public const string DbTablePrefix = \"meowv_\";\n    }\n}\n```\n\n```CSharp\n//MeowvBlogDbConsts.cs\nnamespace Meowv.Blog.Domain.Shared\n{\n    public class MeowvBlogDbConsts\n    {\n        public static class DbTableName\n        {\n            public const string Posts = \"Posts\";\n\n            public const string Categories = \"Categories\";\n\n            public const string Tags = \"Tags\";\n\n            public const string PostTags = \"Post_Tags\";\n\n            public const string Friendlinks = \"Friendlinks\";\n        }\n    }\n}\n```\n\n在`Configure()`方法中配置表模型，包括表名、字段类型和长度等信息。对于下面代码不是很明白的可以看看微软的自定义 Code First 约定：https://docs.microsoft.com/zh-cn/ef/ef6/modeling/code-first/conventions/custom\n\n```CSharp\n//MeowvBlogDbContextModelCreatingExtensions.cs\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.Domain.Shared;\nusing Microsoft.EntityFrameworkCore;\nusing Volo.Abp;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogDbConsts;\n\nnamespace Meowv.Blog.EntityFrameworkCore\n{\n    public static class MeowvBlogDbContextModelCreatingExtensions\n    {\n        public static void Configure(this ModelBuilder builder)\n        {\n            Check.NotNull(builder, nameof(builder));\n\n            builder.Entity<Post>(b =>\n            {\n                b.ToTable(MeowvBlogConsts.DbTablePrefix + DbTableName.Posts);\n                b.HasKey(x => x.Id);\n                b.Property(x => x.Title).HasMaxLength(200).IsRequired();\n                b.Property(x => x.Author).HasMaxLength(10);\n                b.Property(x => x.Url).HasMaxLength(100).IsRequired();\n                b.Property(x => x.Html).HasColumnType(\"longtext\").IsRequired();\n                b.Property(x => x.Markdown).HasColumnType(\"longtext\").IsRequired();\n                b.Property(x => x.CategoryId).HasColumnType(\"int\");\n                b.Property(x => x.CreationTime).HasColumnType(\"datetime\");\n            });\n\n            builder.Entity<Category>(b =>\n            {\n                b.ToTable(MeowvBlogConsts.DbTablePrefix + DbTableName.Categories);\n                b.HasKey(x => x.Id);\n                b.Property(x => x.CategoryName).HasMaxLength(50).IsRequired();\n                b.Property(x => x.DisplayName).HasMaxLength(50).IsRequired();\n            });\n\n            builder.Entity<Tag>(b =>\n            {\n                b.ToTable(MeowvBlogConsts.DbTablePrefix + DbTableName.Tags);\n                b.HasKey(x => x.Id);\n                b.Property(x => x.TagName).HasMaxLength(50).IsRequired();\n                b.Property(x => x.DisplayName).HasMaxLength(50).IsRequired();\n            });\n\n            builder.Entity<PostTag>(b =>\n            {\n                b.ToTable(MeowvBlogConsts.DbTablePrefix + DbTableName.PostTags);\n                b.HasKey(x => x.Id);\n                b.Property(x => x.PostId).HasColumnType(\"int\").IsRequired();\n                b.Property(x => x.TagId).HasColumnType(\"int\").IsRequired();\n            });\n\n            builder.Entity<FriendLink>(b =>\n            {\n                b.ToTable(MeowvBlogConsts.DbTablePrefix + DbTableName.Friendlinks);\n                b.HasKey(x => x.Id);\n                b.Property(x => x.Title).HasMaxLength(20).IsRequired();\n                b.Property(x => x.LinkUrl).HasMaxLength(100).IsRequired();\n            });\n        }\n    }\n}\n```\n\n此时项目层级目录如下\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518222720250-371775560.png)\n\n## 代码优先\n\n在`.EntityFrameworkCore.DbMigrations`中新建模块类`MeowvBlogEntityFrameworkCoreDbMigrationsModule.cs`、数据迁移上下文访问对象`MeowvBlogMigrationsDbContext.cs`和一个Design Time Db Factory类`MeowvBlogMigrationsDbContextFactory.cs`\n\n模块类依赖`MeowvBlogFrameworkCoreModule`模块和`AbpModule`。并在`ConfigureServices`方法中添加上下文的依赖注入。\n\n```CSharp\n//MeowvBlogEntityFrameworkCoreDbMigrationsModule.cs\nusing Microsoft.Extensions.DependencyInjection;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.EntityFrameworkCore.DbMigrations.EntityFrameworkCore\n{\n    [DependsOn(\n        typeof(MeowvBlogFrameworkCoreModule)\n    )]\n    public class MeowvBlogEntityFrameworkCoreDbMigrationsModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            context.Services.AddAbpDbContext<MeowvBlogMigrationsDbContext>();\n        }\n    }\n}\n```\n\n`MeowvBlogMigrationsDbContext`和`MeowvBlogDbContext`没什么大的区别\n\n```CSharp\n//MeowvBlogMigrationsDbContext.cs\nusing Microsoft.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore;\n\nnamespace Meowv.Blog.EntityFrameworkCore.DbMigrations.EntityFrameworkCore\n{\n    public class MeowvBlogMigrationsDbContext : AbpDbContext<MeowvBlogMigrationsDbContext>\n    {\n        public MeowvBlogMigrationsDbContext(DbContextOptions<MeowvBlogMigrationsDbContext> options) : base(options)\n        {\n\n        }\n\n        protected override void OnModelCreating(ModelBuilder builder)\n        {\n            base.OnModelCreating(builder);\n\n            builder.Configure();\n        }\n    }\n}\n```\n\n`MeowvBlogMigrationsDbContextFactory`类主要是用来使用Code-First命令的(`Add-Migration` 和 `Update-Database` ...)\n\n需要注意的地方，我们在这里要单独设置配置文件的连接字符串，将`.HttpApi.Hosting`层的`appsettings.json`复制一份到`.EntityFrameworkCore.DbMigrations`，你用了什么数据库就配置什么数据库的连接字符串。\n\n```json\n//appsettings.json\n{\n  \"ConnectionStrings\": {\n    \"Default\": \"Server=localhost;User Id=root;Password=123456;Database=meowv_blog\"\n  }\n}\n```\n\n```CSharp\n//MeowvBlogMigrationsDbContextFactory.cs\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.EntityFrameworkCore.Design;\nusing Microsoft.Extensions.Configuration;\nusing System.IO;\n\nnamespace Meowv.Blog.EntityFrameworkCore.DbMigrations.EntityFrameworkCore\n{\n    public class MeowvBlogMigrationsDbContextFactory : IDesignTimeDbContextFactory<MeowvBlogMigrationsDbContext>\n    {\n        public MeowvBlogMigrationsDbContext CreateDbContext(string[] args)\n        {\n            var configuration = BuildConfiguration();\n\n            var builder = new DbContextOptionsBuilder<MeowvBlogMigrationsDbContext>()\n                .UseMySql(configuration.GetConnectionString(\"Default\"));\n\n            return new MeowvBlogMigrationsDbContext(builder.Options);\n        }\n\n        private static IConfigurationRoot BuildConfiguration()\n        {\n            var builder = new ConfigurationBuilder()\n                .SetBasePath(Directory.GetCurrentDirectory())\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true);\n\n            return builder.Build();\n        }\n    }\n}\n```\n\n到这里差不多就结束了，默认数据库`meowv_blog_tutorial`是不存在的，先去创建一个空的数据库。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518224704263-241593676.png)\n\n然后在Visual Studio中打开程序包管理控制台，将`.EntityFrameworkCore.DbMigrations`设为启动项目。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518224833467-1959921804.png)\n\n键入命令：`Add-Migration Initial`,会发现报错啦，错误信息如下：\n\n```\nAdd-Migration : 无法将“Add-Migration”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。\n所在位置 行:1 字符: 1\n+ Add-Migration Initial\n+ ~~~~~~~~~~~~~\n    + CategoryInfo          : ObjectNotFound: (Add-Migration:String) [], CommandNotFoundException\n    + FullyQualifiedErrorId : CommandNotFoundException\n```\n\n这是因为我们少添加了一个包，要使用代码优先方式迁移数据，必须添加，`Microsoft.EntityFrameworkCore.Tools`。\n\n紧接着直接用命令安装`Install-Package Microsoft.EntityFrameworkCore.Tools`包，再试一遍\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518225618304-1296718119.png)\n\n可以看到已经成功，并且生成了一个Migrations文件夹和对应的数据迁移文件\n\n最后输入更新命令：`Update-Database`，然后打开数据瞅瞅。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518230144006-254504217.png)\n\n完美，成功创建了数据库表，而且命名也是我们想要的，字段类型也是ok的。`__efmigrationshistory`表是用来记录迁移历史的，这个可以不用管。当我们后续如果想要修改添加表字段，新增表的时候，都可以使用这种方式来完成。\n\n解决方案层级目录图，供参考\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200518231410716-1109583030.png)\n\n本篇使用Entity Framework Core完成数据访问和代码优先的方式创建数据库表，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "EntityFramework Core",
      "Code-First"
    ],
    "createdAt": "2020-05-19 14:18:19"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查",
    "author": "阿星Plus",
    "url": "2020-05-20-blog_05",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章我们用Code-First的方式创建了博客所需的实体类，生成了数据库表，完成了对EF Core的封装。\n\n本篇说一下自定义仓储的实现方式，其实在abp框架中已经默认给我们实现了默认的通用(泛型)仓储，`IRepository<TEntity, TKey>`，有着标准的CRUD操作，可以看：https://docs.abp.io/zh-Hans/abp/latest/Repositories 学习更多。\n\n之所以实现自定义仓储，是因为abp没有给我们实现批量插入、更新的方法，这个是需要自己去扩展的。\n\n既然是自定义仓储，那么就有了很高的自由度，我们可以任意发挥，可以接入第三方批量处理数据的库，可以接入Dapper操作等等，在这里贴一下微软官方推荐的一些EF Core的工具和扩展：https://docs.microsoft.com/zh-cn/ef/core/extensions/ 。\n\n## 自定义仓储\n\n在`.Domain`领域层中创建仓储接口，`IPostRepository`、`ICategoryRepository`、`ITagRepository`、`IPostTagRepository`、`IFriendLinkRepository`，这里直接全部继承 `IRepository<TEntity, TKey>` 以使用已有的通用仓储功能。\n\n可以转到`IRepository<TEntity, TKey>`接口定义看一下\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519200528695-235513765.png)\n\n看看abp对于仓储的介绍，如下：\n\n`IRepository<TEntity, TKey>` 接口扩展了标准 `IQueryable<TEntity>` 你可以使用标准LINQ方法自由查询。但是，某些ORM提供程序或数据库系统可能不支持IQueryable接口。\n\nABP提供了 `IBasicRepository<TEntity, TPrimaryKey>` 和 `IBasicRepository<TEntity>` 接口来支持这样的场景。\n\n你可以扩展这些接口（并可选择性地从BasicRepositoryBase派生）为你的实体创建自定义存储库。\n\n依赖于 `IBasicRepository` 而不是依赖 `IRepository` 有一个优点, 即使它们不支持 `IQueryable` 也可以使用所有的数据源, 但主要的供应商, 像 Entity Framework, NHibernate 或 MongoDb 已经支持了 `IQueryable`。\n\n因此, 使用 `IRepository` 是典型应用程序的 建议方法。但是可重用的模块开发人员可能会考虑使用 `IBasicRepository` 来支持广泛的数据源。\n\n对于想要使用只读仓储提供了`IReadOnlyRepository<TEntity, TKey>` 与 `IReadOnlyBasicRepository<Tentity, TKey>`接口。\n\n仓储接口类如下：\n\n```CSharp\n//IPostRepository.cs\nusing Volo.Abp.Domain.Repositories;\n\nnamespace Meowv.Blog.Domain.Blog.Repositories\n{\n    /// <summary>\n    /// IPostRepository\n    /// </summary>\n    public interface IPostRepository : IRepository<Post, int>\n    {\n    }\n}\n```\n\n```CSharp\n//ICategoryRepository.cs\nusing Volo.Abp.Domain.Repositories;\n\nnamespace Meowv.Blog.Domain.Blog.Repositories\n{\n    /// <summary>\n    /// ICategoryRepository\n    /// </summary>\n    public interface ICategoryRepository : IRepository<Category, int>\n    {\n    }\n}\n```\n\n```CSharp\n//ITagRepository.cs\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Volo.Abp.Domain.Repositories;\n\nnamespace Meowv.Blog.Domain.Blog.Repositories\n{\n    /// <summary>\n    /// ITagRepository\n    /// </summary>\n    public interface ITagRepository : IRepository<Tag, int>\n    {\n        /// <summary>\n        /// 批量插入\n        /// </summary>\n        /// <param name=\"tags\"></param>\n        /// <returns></returns>\n        Task BulkInsertAsync(IEnumerable<Tag> tags);\n    }\n}\n```\n\n```CSharp\n//IPostTagRepository.cs\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Volo.Abp.Domain.Repositories;\n\nnamespace Meowv.Blog.Domain.Blog.Repositories\n{\n    /// <summary>\n    /// IPostTagRepository\n    /// </summary>\n    public interface IPostTagRepository : IRepository<PostTag, int>\n    {\n        /// <summary>\n        /// 批量插入\n        /// </summary>\n        /// <param name=\"postTags\"></param>\n        /// <returns></returns>\n        Task BulkInsertAsync(IEnumerable<PostTag> postTags);\n    }\n}\n```\n\n```CSharp\n//IFriendLinkRepository.cs\nusing Volo.Abp.Domain.Repositories;\n\nnamespace Meowv.Blog.Domain.Blog.Repositories\n{\n    /// <summary>\n    /// IFriendLinkRepository\n    /// </summary>\n    public interface IFriendLinkRepository : IRepository<FriendLink, int>\n    {\n    }\n}\n```\n\n在`ITagRepository`和`IPostTagRepository`仓储接口中，我们添加了批量插入的方法。相对于的在我们的`.EntityFrameworkCore`层实现这些接口。\n\n创建Repositories/Blog 文件夹，添加实现类：`PostRepository`、`CategoryRepository`、`TagRepository`、`PostTagRepository`、`FriendLinkRepository`。\n\n不知道大家发现没有，我们的仓储接口以及实现，都是以`Repository`结尾的，这和我们的`.Application`应用服务层都以`Service`结尾是一个道理。\n\n在自定义仓储的实现中，我们可以使用任意你想使用的数据访问工具，我们这里还是继续用`Entity Framework Core`，需要继承`EfCoreRepository<TDbContext, TEntity, TKey>`，和我们的仓储接口`IXxxRepository`。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519203537559-1603736992.png)\n\n`EfCoreRepository`默认实现了许多默认的方法，然后就可以直接使用 `DbContext` 来执行操作了。\n\n仓储接口实现类如下：\n\n```CSharp\n//PostRepository.cs\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\nusing Volo.Abp.Domain.Repositories.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore;\n\nnamespace Meowv.Blog.EntityFrameworkCore.Repositories.Blog\n{\n    /// <summary>\n    /// PostRepository\n    /// </summary>\n    public class PostRepository : EfCoreRepository<MeowvBlogDbContext, Post, int>, IPostRepository\n    {\n        public PostRepository(IDbContextProvider<MeowvBlogDbContext> dbContextProvider) : base(dbContextProvider)\n        {\n        }\n    }\n}\n```\n\n```CSharp\n//CategoryRepository.cs\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\nusing Volo.Abp.Domain.Repositories.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore;\nnamespace Meowv.Blog.EntityFrameworkCore.Repositories.Blog\n{\n    /// <summary>\n    /// CategoryRepository\n    /// </summary>\n    public class CategoryRepository : EfCoreRepository<MeowvBlogDbContext, Category, int>, ICategoryRepository\n    {\n        public CategoryRepository(IDbContextProvider<MeowvBlogDbContext> dbContextProvider) : base(dbContextProvider)\n        {\n        }\n    }\n}\n```\n\n```CSharp\n//TagRepository.cs\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Volo.Abp.Domain.Repositories.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore;\n\nnamespace Meowv.Blog.EntityFrameworkCore.Repositories.Blog\n{\n    /// <summary>\n    /// TagRepository\n    /// </summary>\n    public class TagRepository : EfCoreRepository<MeowvBlogDbContext, Tag, int>, ITagRepository\n    {\n        public TagRepository(IDbContextProvider<MeowvBlogDbContext> dbContextProvider) : base(dbContextProvider)\n        {\n        }\n\n        /// <summary>\n        /// 批量插入\n        /// </summary>\n        /// <param name=\"tags\"></param>\n        /// <returns></returns>\n        public async Task BulkInsertAsync(IEnumerable<Tag> tags)\n        {\n            await DbContext.Set<Tag>().AddRangeAsync(tags);\n            await DbContext.SaveChangesAsync();\n        }\n    }\n}\n```\n\n```CSharp\n//PostTagRepository.cs\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Volo.Abp.Domain.Repositories.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore;\n\nnamespace Meowv.Blog.EntityFrameworkCore.Repositories.Blog\n{\n    /// <summary>\n    /// PostTagRepository\n    /// </summary>\n    public class PostTagRepository : EfCoreRepository<MeowvBlogDbContext, PostTag, int>, IPostTagRepository\n    {\n        public PostTagRepository(IDbContextProvider<MeowvBlogDbContext> dbContextProvider) : base(dbContextProvider)\n        {\n        }\n\n        /// <summary>\n        /// 批量插入\n        /// </summary>\n        /// <param name=\"postTags\"></param>\n        /// <returns></returns>\n        public async Task BulkInsertAsync(IEnumerable<PostTag> postTags)\n        {\n            await DbContext.Set<PostTag>().AddRangeAsync(postTags);\n            await DbContext.SaveChangesAsync();\n        }\n    }\n}\n```\n\n```CSharp\n//FriendLinkRepository.cs\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\nusing Volo.Abp.Domain.Repositories.EntityFrameworkCore;\nusing Volo.Abp.EntityFrameworkCore;\n\nnamespace Meowv.Blog.EntityFrameworkCore.Repositories.Blog\n{\n    /// <summary>\n    /// PostTagRepository\n    /// </summary>\n    public class FriendLinkRepository : EfCoreRepository<MeowvBlogDbContext, FriendLink, int>, IFriendLinkRepository\n    {\n        public FriendLinkRepository(IDbContextProvider<MeowvBlogDbContext> dbContextProvider) : base(dbContextProvider)\n        {\n        }\n    }\n}\n```\n\n在`TagRepository`和`PostTagRepository`仓储接口的实现中，因为数据量不大，可以直接用了EF Core自带的`AddRangeAsync`批量保存数据。\n\n到这里，关于博客的自定义仓储便完成了，此时项目层级目录图，如下：\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519204147807-1375027236.png)\n\n## 增删改查\n\n接下来在就可以在`.Application`服务层愉快的玩耍了，写服务之前，我们要分析我们的项目，要有哪些功能业务。由于是博客项目，无非就是一些增删改查。今天先不写博客业务，先完成对数据库文章表`meowv_posts`的一个简单CRUD。\n\n在`.Application`层新建Blog文件夹，添加一个`IBlogService.cs`博客接口服务类，分别添加增删改查四个方法。\n\n这时就要用到我们的数据传输对象(DTO)了，简单理解，DTO就是从我们的领域模型中抽离出来的对象，它是很纯粹的只包含我们拿到的数据，不参杂任何行为逻辑。\n\n在`.Application.Contracts`层新建Blog文件夹，同时新建一个`PostDto.cs`类，与`.Domain`层中的`Post.cs`与之对应，他们很相似，但是不一样。\n\n于是`IBlogService.cs`接口服务类的CRUD为：\n\n```CSharp\n//IBlogService.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog\n{\n    public interface IBlogService\n    {\n        Task<bool> InsertPostAsync(PostDto dto);\n\n        Task<bool> DeletePostAsync(int id);\n\n        Task<bool> UpdatePostAsync(int id, PostDto dto);\n\n        Task<PostDto> GetPostAsync(int id);\n    }\n}\n```\n\n接口写好了，少不了实现方式，直接在Blog文件夹新建Impl文件夹，用来存放我们的接口实现类`BlogService.cs`，注意：都是以`Service`结尾的噢~\n\n实现服务接口除了要继承我们的`IBlogService`外，不要忘了还需依赖我们的`ServiceBase`类。由于我们之前直接接入了Autofac，可以直接使用构造函数依赖注入的方式。\n\n```CSharp\n//BlogService.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog.Impl\n{\n    public class BlogService : ServiceBase, IBlogService\n    {\n        private readonly IPostRepository _postRepository;\n\n        public BlogService(IPostRepository postRepository)\n        {\n            _postRepository = postRepository;\n        }\n        ...\n    }\n}\n```\n\n现在就可以实现我们写的`IBlogService`接口了。\n\n先写添加，这里实现方式全采用异步的方法，先构建一个`Post`实体对象，具体内容参数都从`PostDto`中获取，由于主键之前设置了自增，这里就不用管它了。然后调用 `await _postRepository.InsertAsync(entity);`，正好它返回了一个创建成功的`Post`对象，那么我们就可以判断对象是否为空，从而确定文章是否添加成功。\n\n代码如下：\n\n```CSharp\n...\n        public async Task<bool> InsertPostAsync(PostDto dto)\n        {\n            var entity = new Post\n            {\n                Title = dto.Title,\n                Author = dto.Author,\n                Url = dto.Url,\n                Html = dto.Html,\n                Markdown = dto.Markdown,\n                CategoryId = dto.CategoryId,\n                CreationTime = dto.CreationTime\n            };\n\n            var post = await _postRepository.InsertAsync(entity);\n            return post != null;\n        }\n...\n```\n\n然后在`.HttpApi`层和之前添加`HelloWorldController`一样，添加`BlogController`。调用写的`InsertPostAsync`方法，如下：\n\n```CSharp\n//BlogController.cs\nusing Meowv.Blog.Application.Blog;\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Threading.Tasks;\nusing Volo.Abp.AspNetCore.Mvc;\n\nnamespace Meowv.Blog.HttpApi.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class BlogController : AbpController\n    {\n        private readonly IBlogService _blogService;\n\n        public BlogController(IBlogService blogService)\n        {\n            _blogService = blogService;\n        }\n\n        /// <summary>\n        /// 添加博客\n        /// </summary>\n        /// <param name=\"dto\"></param>\n        /// <returns></returns>\n        [HttpPost]\n        public async Task<bool> InsertPostAsync([FromBody] PostDto dto)\n        {\n            return await _blogService.InsertPostAsync(dto);\n        }\n    }\n}\n```\n\n添加博客操作，我们将其设置为`[HttpPost]`方式来提交，因为现在开发接口api，都要遵循RESTful方式，所以就不用给他指定路由了，`[FromBody]`的意思是在请求正文中以JSON的方式来提交参数。\n\n完成上述操作，打开我们的Swagger文档看看， .../swagger/index.html ，已经出现我们的接口了。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519213650913-1871748706.png)\n\n随手就试一下这个接口，能否成功创建文章。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519214442360-1594124256.png)\n\n可以看到数据库已经躺着我们刚刚添加数据内容。\n\n将剩下的三个接口一一实现，相信大家肯定都知道怎么写了。就不逐一唠叨了，代码如下：\n\n```CSharp\n...\n        public async Task<bool> DeletePostAsync(int id)\n        {\n            await _postRepository.DeleteAsync(id);\n\n            return true;\n        }\n\n        public async Task<bool> UpdatePostAsync(int id, PostDto dto)\n        {\n            var post = await _postRepository.GetAsync(id);\n\n            post.Title = dto.Title;\n            post.Author = dto.Author;\n            post.Url = dto.Url;\n            post.Html = dto.Html;\n            post.Markdown = dto.Markdown;\n            post.CategoryId = dto.CategoryId;\n            post.CreationTime = dto.CreationTime;\n\n            await _postRepository.UpdateAsync(post);\n\n            return true;\n        }\n\n        public async Task<PostDto> GetPostAsync(int id)\n        {\n            var post = await _postRepository.GetAsync(id);\n\n            return new PostDto\n            {\n                Title = post.Title,\n                Author = post.Author,\n                Url = post.Url,\n                Html = post.Html,\n                Markdown = post.Markdown,\n                CategoryId = post.CategoryId,\n                CreationTime = post.CreationTime\n            };\n        }\n...\n```\n\n在这里先暂时不做参数校验，咱们默认都是正常操作，如果执行操作成功，直接返回true。大家会发现，当我们使用了DTO后，写了大量对象的转换，在这里暂不做优化，将在后续业务开始后使用`AutoMapper`处理对象映射。如果大家感兴趣可以自己先试一下。\n\n在Controller中调用，代码如下：\n\n```\n...\n        /// <summary>\n        /// 删除博客\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <returns></returns>\n        [HttpDelete]\n        public async Task<bool> DeletePostAsync([Required] int id)\n        {\n            return await _blogService.DeletePostAsync(id);\n        }\n\n        /// <summary>\n        /// 更新博客\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <param name=\"dto\"></param>\n        /// <returns></returns>\n        [HttpPut]\n        public async Task<bool> UpdatePostAsync([Required] int id, [FromBody] PostDto dto)\n        {\n            return await _blogService.UpdatePostAsync(id, dto);\n        }\n\n        /// <summary>\n        /// 查询博客\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <returns></returns>\n        [HttpGet]\n        public async Task<PostDto> GetPostAsync([Required] int id)\n        {\n            return await _blogService.GetPostAsync(id);\n        }\n...\n```\n\n`DeletePostAsync`：指定了请求方式`[HttpDelete]`，参数id为必填项\n\n`UpdatePostAsync`：指定了请求方式`[HttpPut]`，参数id为必填项并且为url的一部分，要更新的具体内容和添加博客的方法`InsertPostAsync`的一样的\n\n`GetPostAsync`：指定了请求方式`[HttpGet]`，参数id为必填项\n\nok，打开Swagger文档看看效果，并试试我们的接口是否好使吧，反正我试了是没有问题的。\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519220446147-402514670.png)\n\n做到这一步的项目层级目录如下:\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200519220657414-1572584084.png)\n\n本篇使用自定义仓储的方式完成了对博客(meowv_posts)的增删改查，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "EntityFramework Core",
      "Repository"
    ],
    "createdAt": "2020-05-20 13:14:20"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型",
    "author": "阿星Plus",
    "url": "2020-05-21-blog_06",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章使用自定义仓储完成了简单的增删改查案例，有心的同学可以看出，我们的返回参数一塌糊涂，显得很不友好。\n\n在实际开发过程中，每个公司可能不尽相同，但都大同小异，我们的返回数据都是包裹在一个公共的模型下面的，而不是直接返回最终数据，在返回参数中，显示出当前请求的时间戳，是否请求成功，如果错误那么错误的消息是什么，状态码(状态码可以是我们自己定义的值)等等。可能显得很繁琐，没必要，但这样做的好处毋庸置疑，除了美化了我们的API之外，也方便了前端同学的数据处理。\n\n我们将统一的返回模型放在`.ToolKits`层中，之前说过这里主要是公共的工具类、扩展方法。\n\n新建一个Base文件夹，添加响应实体类`ServiceResult.cs`，在Enum文件夹下单独定义一个`ServiceResultCode`响应码枚举，0/1。分别代表 成功和失败。\n\n```CSharp\n//ServiceResultCode.cs\nnamespace Meowv.Blog.ToolKits.Base.Enum\n{\n    /// <summary>\n    /// 服务层响应码枚举\n    /// </summary>\n    public enum ServiceResultCode\n    {\n        /// <summary>\n        /// 成功\n        /// </summary>\n        Succeed = 0,\n\n        /// <summary>\n        /// 失败\n        /// </summary>\n        Failed = 1,\n    }\n}\n```\n\n```CSharp\n//ServiceResult.cs\nusing Meowv.Blog.ToolKits.Base.Enum;\nusing System;\n\nnamespace Meowv.Blog.ToolKits.Base\n{\n    /// <summary>\n    /// 服务层响应实体\n    /// </summary>\n    public class ServiceResult\n    {\n        /// <summary>\n        /// 响应码\n        /// </summary>\n        public ServiceResultCode Code { get; set; }\n\n        /// <summary>\n        /// 响应信息\n        /// </summary>\n        public string Message { get; set; }\n\n        /// <summary>\n        /// 成功\n        /// </summary>\n        public bool Success => Code == ServiceResultCode.Succeed;\n\n        /// <summary>\n        /// 时间戳(毫秒)\n        /// </summary>\n        public long Timestamp { get; } = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();\n\n        /// <summary>\n        /// 响应成功\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>\n        public void IsSuccess(string message = \"\")\n        {\n            Message = message;\n            Code = ServiceResultCode.Succeed;\n        }\n\n        /// <summary>\n        /// 响应失败\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>\n        public void IsFailed(string message = \"\")\n        {\n            Message = message;\n            Code = ServiceResultCode.Failed;\n        }\n\n        /// <summary>\n        /// 响应失败\n        /// </summary>\n        /// <param name=\"exexception></param>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>\n        public void IsFailed(Exception exception)\n        {\n            Message = exception.InnerException?.StackTrace;\n            Code = ServiceResultCode.Failed;\n        }\n    }\n}\n```\n\n可以看到，还定义了 string 类型的 Message，bool 类型的 Success，Success取决于`Code == ServiceResultCode.Succeed`的结果。还有一个当前的时间戳Timestamp。\n\n其中还有`IsSuccess(...)`和`IsFailed(...)`方法，当我们成功返回数据或者当系统出错或者参数异常的时候执行，这一点也不难理解吧。\n\n这个返回模型暂时只支持无需返回参数的api使用，还需要扩展一下，当我们需要返回其它各种复杂类型的数据就行不通了。所以还需要添加一个支持泛型的返回模型，新建模型类：`ServiceResultOfT.cs`，这里的T就是我们的返回结果，然后继承我们的ServiceResult，指定T为class。并重新编写一个`IsSuccess(...)`方法，代码如下：\n\n```CSharp\n//ServiceResultOfT.cs\nusing Meowv.Blog.ToolKits.Base.Enum;\n\nnamespace Meowv.Blog.ToolKits.Base\n{\n    /// <summary>\n    /// 服务层响应实体(泛型)\n    /// </summary>\n    /// <typeparam name=\"T\"></typeparam>\n    public class ServiceResult<T> : ServiceResult where T : class\n    {\n        /// <summary>\n        /// 返回结果\n        /// </summary>\n        public T Result { get; set; }\n\n        /// <summary>\n        /// 响应成功\n        /// </summary>\n        /// <param name=\"result\"></param>\n        /// <param name=\"message\"></param>\n        public void IsSuccess(T result = null, string message = \"\")\n        {\n            Message = message;\n            Code = ServiceResultCode.Succeed;\n            Result = result;\n        }\n    }\n}\n```\n\n此时针对无需返回参数和需要返回参数的api都可以满足要求了。但是还有一种就没办法了，那就是带分页的数据，我们都应该知道想要分页，数据总数肯定是必不可少的。\n\n所以此时还需要扩展一个分页的响应实体，当我们使用的时候，直接将分页响应实体作为上面写的`ServiceResult<T>`中的T参数，即可满足需求。\n\n新建文件夹Paged，添加总数接口`IHasTotalCount`、返回结果列表接口`IListResult`\n\n```CSharp\n//IHasTotalCount.cs\nnamespace Meowv.Blog.ToolKits.Base.Paged\n{\n    public interface IHasTotalCount\n    {\n        /// <summary>\n        /// 总数\n        /// </summary>\n        int Total { get; set; }\n    }\n}\n\n//IListResult.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.ToolKits.Base.Paged\n{\n    public interface IListResult<T>\n    {\n        /// <summary>\n        /// 返回结果\n        /// </summary>\n        IReadOnlyList<T> Item { get; set; }\n    }\n}\n```\n\n`IListResult<T>`接受一个参数，并将其指定为`IReadOnlyList`返回。\n\n现在来实现`IListResult`接口，新建`ListResult`实现类，继承`IListResult`，在构造函数中为其赋值，代码如下：\n\n```CSharp\n//ListResult.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.ToolKits.Base.Paged\n{\n    public class ListResult<T> : IListResult<T>\n    {\n        IReadOnlyList<T> item;\n\n        public IReadOnlyList<T> Item\n        {\n            get => item ?? (item = new List<T>());\n            set => item = value;\n        }\n\n        public ListResult()\n        {\n        }\n\n        public ListResult(IReadOnlyList<T> item)\n        {\n            Item = item;\n        }\n    }\n}\n```\n\n最后新建我们的分页响应实体接口：`IPagedList`和分页响应实体实现类：`PagedList`，它同时也要接受一个泛型参数 T。\n\n接口继承了`IListResult<T>`和`IHasTotalCount`，实现类继承`ListResult<T>`和`IPagedList<T>`，在构造函数中为其赋值。代码如下：\n\n```CSharp\n//IPagedList.cs\nnamespace Meowv.Blog.ToolKits.Base.Paged\n{\n    public interface IPagedList<T> : IListResult<T>, IHasTotalCount\n    {\n    }\n}\n\n//PagedList.cs\nusing Meowv.Blog.ToolKits.Base.Paged;\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.ToolKits.Base\n{\n    /// <summary>\n    /// 分页响应实体\n    /// </summary>\n    /// <typeparam name=\"T\"></typeparam>\n    public class PagedList<T> : ListResult<T>, IPagedList<T>\n    {\n        /// <summary>\n        /// 总数\n        /// </summary>\n        public int Total { get; set; }\n\n        public PagedList()\n        {\n        }\n\n        public PagedList(int total, IReadOnlyList<T> result) : base(result)\n        {\n            Total = total;\n        }\n    }\n}\n```\n\n到这里我们的返回模型就圆满了，看一下此时下我们的项目层级目录。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200520160152496-1654274153.png)\n\n接下来去实践一下，修改我们之前创建的增删改查接口的返回参数。\n\n```CSharp\n//IBlogService.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog\n{\n    public interface IBlogService\n    {\n        //Task<bool> InsertPostAsync(PostDto dto);\n        Task<ServiceResult<string>> InsertPostAsync(PostDto dto);\n\n        //Task<bool> DeletePostAsync(int id);\n        Task<ServiceResult> DeletePostAsync(int id);\n\n        //Task<bool> UpdatePostAsync(int id, PostDto dto);\n        Task<ServiceResult<string>> UpdatePostAsync(int id, PostDto dto);\n\n        //Task<PostDto> GetPostAsync(int id);\n        Task<ServiceResult<PostDto>> GetPostAsync(int id);\n    }\n}\n```\n\n接口全部为异步方式，用`ServiceResult`包裹作为返回模型，添加和更新T参数为string类型，删除就直接不返回结果，然后查询为：`ServiceResult<PostDto>`，再看一下实现类：\n\n```CSharp\n//BlogService.cs\n...\n        public async Task<ServiceResult<string>> InsertPostAsync(PostDto dto)\n        {\n            var result = new ServiceResult<string>();\n\n            var entity = new Post\n            {\n                Title = dto.Title,\n                Author = dto.Author,\n                Url = dto.Url,\n                Html = dto.Html,\n                Markdown = dto.Markdown,\n                CategoryId = dto.CategoryId,\n                CreationTime = dto.CreationTime\n            };\n\n            var post = await _postRepository.InsertAsync(entity);\n            if (post == null)\n            {\n                result.IsFailed(\"添加失败\");\n                return result;\n            }\n\n            result.IsSuccess(\"添加成功\");\n            return result;\n        }\n\n        public async Task<ServiceResult> DeletePostAsync(int id)\n        {\n            var result = new ServiceResult();\n\n            await _postRepository.DeleteAsync(id);\n\n            return result;\n        }\n\n        public async Task<ServiceResult<string>> UpdatePostAsync(int id, PostDto dto)\n        {\n            var result = new ServiceResult<string>();\n\n            var post = await _postRepository.GetAsync(id);\n            if (post == null)\n            {\n                result.IsFailed(\"文章不存在\");\n                return result;\n            }\n\n            post.Title = dto.Title;\n            post.Author = dto.Author;\n            post.Url = dto.Url;\n            post.Html = dto.Html;\n            post.Markdown = dto.Markdown;\n            post.CategoryId = dto.CategoryId;\n            post.CreationTime = dto.CreationTime;\n\n            await _postRepository.UpdateAsync(post);\n\n\n            result.IsSuccess(\"更新成功\");\n            return result;\n        }\n\n        public async Task<ServiceResult<PostDto>> GetPostAsync(int id)\n        {\n            var result = new ServiceResult<PostDto>();\n\n            var post = await _postRepository.GetAsync(id);\n            if (post == null)\n            {\n                result.IsFailed(\"文章不存在\");\n                return result;\n            }\n\n            var dto = new PostDto\n            {\n                Title = post.Title,\n                Author = post.Author,\n                Url = post.Url,\n                Html = post.Html,\n                Markdown = post.Markdown,\n                CategoryId = post.CategoryId,\n                CreationTime = post.CreationTime\n            };\n\n            result.IsSuccess(dto);\n            return result;\n        }\n...\n```\n\n当成功时，调用`IsSuccess(...)`方法，当失败时，调用`IsFailed(...)`方法。最终我们返回的是`new ServiceResult()`或者`new ServiceResult<T>()`对象。\n\n同时不要忘记在Controller中也需要修改一下，如下：\n\n```CSharp\n//BlogController.cs\n...\n        ...\n        public async Task<ServiceResult<string>> InsertPostAsync([FromBody] PostDto dto)\n        ...\n\n        ...\n        public async Task<ServiceResult> DeletePostAsync([Required] int id)\n        ...\n\n        ...\n        public async Task<ServiceResult<string>> UpdatePostAsync([Required] int id, [FromBody] PostDto dto)\n        ...\n\n        ...\n        public async Task<ServiceResult<PostDto>> GetPostAsync([Required] int id)\n        ...\n...\n```\n\n此时再去我们的Swagger文档发起请求，这里我们调用一下查询接口看看返回的样子，看看效果吧。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200520162754540-370589984.png)\n\n本篇内容比较简单，主要是包装我们的api，让返回结果显得比较正式一点。那么，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "WebApi",
      "Models"
    ],
    "createdAt": "2020-05-21 11:00:21"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁",
    "author": "阿星Plus",
    "url": "2020-05-22-blog_07",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n在开始本篇正文之前，解决一个 @疯疯过 指出的错误，再次感谢指正。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200521140310243-1483710674.png)\n\n步骤如下：\n\n* 删掉`.Domain.Shared`层中的项目引用，添加nuget依赖包`Volo.Abp.Identity.Domain.Shared`，可以使用命令：`Install-Package Volo.Abp.Identity.Domain.Shared`\n* 在`.Domain`层中引用项目`.Domain.Shared`，在模块类中添加依赖`typeof(MeowvBlogDomainSharedModule)`\n* 将`.EntityFrameworkCore`层中的引用项目`.Domain.Shared`改成`.Domain`。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200521133459192-1346996704.png)\n\n---\n\n上一篇文章完成了对API返回模型的封装，紧接着我打算继续来折腾一下Swagger，之前的文章中已经简单用起了Swagger，本篇还是围绕它让其发挥更高的更多的价值。\n\n当我们的项目不断壮大，API持续增多，这时如果想要快速准确定位到某个API可能不是那么容易，需要翻半天才能找对我们的API。于是对Swagger API文档分组和详细的文档描述就有必要了，就本项目而言，博客系统可以分组为：博客前台接口、博客后台接口、其它公共接口、JWT认证授权接口。\n\n其中，博客后台组中的接口需要授权后才可以调用，需要授权那么就涉及到身份验证，在这里准备采用JWT(JSON WEB TOKEN)的方式进行。\n\n## 分组\n\n对Swagger进行分组很简单，在`.Swagger`层中的扩展方法`AddSwagger(this IServiceCollection services)`中多次调用`options.SwaggerDoc(...)`即可，像这样\n\n```CSharp\n...\n    options.SwaggerDoc(\"v1\", new OpenApiInfo\n    {\n        Version = \"1.0.0\",\n        Title = \"我的接口啊1\",\n        Description = \"接口描述1\"\n    });\n    options.SwaggerDoc(\"v2\", new OpenApiInfo\n    {\n        Version = \"1.0.0\",\n        Title = \"我的接口啊2\",\n        Description = \"接口描述2\"\n    });\n    ...\n...\n```\n\n不过这样显得有点low，然后可以转变一下思路使用遍历的方式进行。`options.SwaggerDoc(...)`接收两个参数：`string name, OpenApiInfo info`。\n\n`name`：可以理解为当前分组的前缀；`OpenApiInfo`：有许多可配置的参数，在这里我只用到三个，`Version`、`Title`、`Description`。\n\n要注意，当在`AddSwagger(...)`中调用完后，还需要在我们的扩展方法`UseSwaggerUI(this IApplicationBuilder app)`中`options.SwaggerEndpoint()`使用它，同样的也用遍历的方法。它接收的的参数：`string url, string name`。\n\n`url`：这里的`url`要与前面配置的`name`参数对应。\n\n`name`：我们自定义显示的分组名称。\n\n于是可以直接在扩展方法中新建一个内部类：`SwaggerApiInfo`\n\n```CSharp\ninternal class SwaggerApiInfo\n        {\n            /// <summary>\n            /// URL前缀\n            /// </summary>\n            public string UrlPrefix { get; set; }\n\n            /// <summary>\n            /// 名称\n            /// </summary>\n            public string Name { get; set; }\n\n            /// <summary>\n            /// <see cref=\"Microsoft.OpenApi.Models.OpenApiInfo\"/>\n            /// </summary>\n            public OpenApiInfo OpenApiInfo { get; set; }\n        }\n```\n\n然后新建一个`List<SwaggerApiInfo>`手动为其初始化一些值。\n\n```CSharp\n...\n       /// <summary>\n        /// Swagger分组信息，将进行遍历使用\n        /// </summary>\n        private static readonly List<SwaggerApiInfo> ApiInfos = new List<SwaggerApiInfo>()\n        {\n            new SwaggerApiInfo\n            {\n                UrlPrefix = Grouping.GroupName_v1,\n                Name = \"博客前台接口\",\n                OpenApiInfo = new OpenApiInfo\n                {\n                    Version = version,\n                    Title = \"阿星Plus - 博客前台接口\",\n                    Description = description\n                }\n            },\n            new SwaggerApiInfo\n            {\n                UrlPrefix = Grouping.GroupName_v2,\n                Name = \"博客后台接口\",\n                OpenApiInfo = new OpenApiInfo\n                {\n                    Version = version,\n                    Title = \"阿星Plus - 博客后台接口\",\n                    Description = description\n                }\n            },\n            new SwaggerApiInfo\n            {\n                UrlPrefix = Grouping.GroupName_v3,\n                Name = \"通用公共接口\",\n                OpenApiInfo = new OpenApiInfo\n                {\n                    Version = version,\n                    Title = \"阿星Plus - 通用公共接口\",\n                    Description = description\n                }\n            },\n            new SwaggerApiInfo\n            {\n                UrlPrefix = Grouping.GroupName_v4,\n                Name = \"JWT授权接口\",\n                OpenApiInfo = new OpenApiInfo\n                {\n                    Version = version,\n                    Title = \"阿星Plus - JWT授权接口\",\n                    Description = description\n                }\n            }\n        };\n...\n```\n\n`version`：我们将其配置在`appsettings.json`中，做到动态可以修改。\n\n```CSharp\n//AppSettings.cs\n...\n        /// <summary>\n        /// ApiVersion\n        /// </summary>\n        public static string ApiVersion => _config[\"ApiVersion\"];\n...\n\n//appsettings.json\n{\n...\n  \"ApiVersion\": \"1.0.0\"\n...\n}\n```\n\n`description`：因为多次使用，就定义一个变量，内容自拟主要是一些介绍性的描述，将在Swagger界面进行显示。\n\n`UrlPrefix`：分别为，v1,v2,v3,v4。在`Domain.Shared`层中为其定义好常量\n\n```CSharp\n//MeowvBlogConsts.cs\n...\n        /// <summary>\n        /// 分组\n        /// </summary>\n        public static class Grouping\n        {\n            /// <summary>\n            /// 博客前台接口组\n            /// </summary>\n            public const string GroupName_v1 = \"v1\";\n\n            /// <summary>\n            /// 博客后台接口组\n            /// </summary>\n            public const string GroupName_v2 = \"v2\";\n\n            /// <summary>\n            /// 其他通用接口组\n            /// </summary>\n            public const string GroupName_v3 = \"v3\";\n\n            /// <summary>\n            /// JWT授权接口组\n            /// </summary>\n            public const string GroupName_v4 = \"v4\";\n        }\n...\n```\n\n现在修改扩展方法`AddSwagger(...)`，遍历`List<SwaggerApiInfo>`。\n\n```CSharp\n...\n        public static IServiceCollection AddSwagger(this IServiceCollection services)\n        {\n            return services.AddSwaggerGen(options =>\n            {\n                //options.SwaggerDoc(\"v1\", new OpenApiInfo\n                //{\n                //    Version = \"1.0.0\",\n                //    Title = \"我的接口啊\",\n                //    Description = \"接口描述\"\n                //});\n\n                // 遍历并应用Swagger分组信息\n                ApiInfos.ForEach(x =>\n                {\n                    options.SwaggerDoc(x.UrlPrefix, x.OpenApiInfo);\n                });\n                ...\n            });\n        }\n...\n```\n\n在扩展方法`UseSwaggerUI(...)`使用，通用也需要遍历。\n\n```CSharp\n...\n        // 遍历分组信息，生成Json\n        ApiInfos.ForEach(x =>\n        {\n                options.SwaggerEndpoint($\"/swagger/{x.UrlPrefix}/swagger.json\", x.Name);\n        });\n...\n```\n\n细心的同学可以发现，我们前几篇文章打开Swagger文档的时候都是需要手动更改URL地址：`.../swagger`才能正确进入，其实Swagger是支持配置路由的。同时咱们也将页面Title也给改了吧。看下面`UseSwaggerUI(...)`完整代码：\n\n```CSharp\n...\n        /// <summary>\n        /// UseSwaggerUI\n        /// </summary>\n        /// <param name=\"app\"></param>\n        public static void UseSwaggerUI(this IApplicationBuilder app)\n        {\n            app.UseSwaggerUI(options =>\n            {\n                // 遍历分组信息，生成Json\n                ApiInfos.ForEach(x =>\n                {\n                    options.SwaggerEndpoint($\"/swagger/{x.UrlPrefix}/swagger.json\", x.Name);\n                });\n\n                // 模型的默认扩展深度，设置为 -1 完全隐藏模型\n                options.DefaultModelsExpandDepth(-1);\n                // API文档仅展开标记\n                options.DocExpansion(DocExpansion.List);\n                // API前缀设置为空\n                options.RoutePrefix = string.Empty;\n                // API页面Title\n                options.DocumentTitle = \"😍接口文档 - 阿星Plus⭐⭐⭐\";\n            });\n        }\n...\n```\n\n`options.DefaultModelsExpandDepth(-1);`是模型的默认扩展深度，设置为 -1 完全隐藏模型。\n\n`options.DocExpansion(DocExpansion.List);`代表API文档仅展开标记，不默然展开所有接口，需要我们手动去点击才展开，可以自行查看`DocExpansion`。\n\n`options.RoutePrefix = string.Empty;`代表路由设置为空，直接打开页面就可以访问了。\n\n`options.DocumentTitle = \"😍接口文档 - 阿星Plus⭐⭐⭐\";`是设置文档页面的标题的。\n\n完成以上操作，在Controller中使用 Attribute：`[ApiExplorerSettings(GroupName = ...)]`指定是哪个分组然后就可以愉快的使用了。\n\n默认不指定的话就是全部都有，目前只有两个Controller，我们将`HelloWorldController`设置成v3，`BlogController`设置成v1。\n\n```CSharp\n//HelloWorldController.cs\n...\n    [ApiExplorerSettings(GroupName = Grouping.GroupName_v3)]\n    public class HelloWorldController : AbpController\n    {\n        ...\n    }\n...\n\n//BlogController.cs\n...\n    [ApiExplorerSettings(GroupName = Grouping.GroupName_v1)]\n    public class BlogController : AbpController\n    {\n        ...\n    }\n...\n```\n\n编译运行，打开我们的Swagger文档看一下。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200521102121598-405128275.png)\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200521102157649-1930260689.png)\n\n自己试着换切换一下分组试试吧，大功告成。​\n\n## 描述\n\n在Swagger文档中，默认只显示我们的Controller的名称，其实他也是支持描述信息的，这是就需要我们自行扩展了。在`.Swagger`层新建一个文件夹Filters，添加`SwaggerDocumentFilter`类来实现IDocumentFilter接口。\n\n```CSharp\n//SwaggerDocumentFilter.cs\nusing Microsoft.OpenApi.Models;\nusing Swashbuckle.AspNetCore.SwaggerGen;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Meowv.Blog.Swagger.Filters\n{\n    /// <summary>\n    /// 对应Controller的API文档描述信息\n    /// </summary>\n    public class SwaggerDocumentFilter : IDocumentFilter\n    {\n        public void Apply(OpenApiDocument swaggerDoc, DocumentFilterContext context)\n        {\n            var tags = new List<OpenApiTag>\n            {\n                new OpenApiTag {\n                    Name = \"Blog\",\n                    Description = \"个人博客相关接口\",\n                    ExternalDocs = new OpenApiExternalDocs { Description = \"包含：文章/标签/分类/友链\" }\n                }\n                new OpenApiTag {\n                    Name = \"HelloWorld\",\n                    Description = \"通用公共接口\",\n                    ExternalDocs = new OpenApiExternalDocs { Description = \"这里是一些通用的公共接口\" }\n                }\n            };\n\n            // 按照Name升序排序\n            swaggerDoc.Tags = tags.OrderBy(x => x.Name).ToList();\n        }\n    }\n}\n```\n\n实现`Apply(...)`方法后，使用Linq语法对文档排个序，然后最重要的使用这个Filter，在扩展方法`AddSwagger(...)`中使用\n\n```CSharp\npublic static IServiceCollection AddSwagger(this IServiceCollection services)\n        {\n            return services.AddSwaggerGen(options =>\n            {\n                ...\n                // 应用Controller的API文档描述信息\n                options.DocumentFilter<SwaggerDocumentFilter>();\n            });\n        }\n```\n\n再打开Swagger文档看看效果。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200521104440140-1407541973.png)\n\nok，此时描述信息也出来了。\n\n## 小绿锁\n\n在Swagger文档中开启小绿锁是非常简单的，只需添加一个包：`Swashbuckle.AspNetCore.Filters`，直接使用命令安装：`Install-Package Swashbuckle.AspNetCore.Filters`\n\n然后再扩展方法`AddSwagger(this IServiceCollection services)`中调用\n\n```CSharp\npublic static IServiceCollection AddSwagger(this IServiceCollection services)\n{\n    return services.AddSwaggerGen(options =>\n    {\n        ...\n        var security = new OpenApiSecurityScheme\n        {\n            Description = \"JWT模式授权，请输入 Bearer {Token} 进行身份验证\",\n            Name = \"Authorization\",\n            In = ParameterLocation.Header,\n            Type = SecuritySchemeType.ApiKey\n        };\n        options.AddSecurityDefinition(\"oauth2\", security);\n        options.AddSecurityRequirement(new OpenApiSecurityRequirement { { security, new List<string>() } });\n        options.OperationFilter<AddResponseHeadersFilter>();\n        options.OperationFilter<AppendAuthorizeToSummaryOperationFilter>();\n        options.OperationFilter<SecurityRequirementsOperationFilter>();\n        ...\n    });\n}\n```\n\n以上便实现了在Swagger文档中显示小绿锁，我们new的`OpenApiSecurityScheme`对象，具体参数大家可以自行看一下注释就明白具体含义。分别调用`options.AddSecurityDefinition(...)`、`options.AddSecurityRequiremen(...)`、`options.OperationFilter(...)`，编译运行，打开瞅瞅。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200521135050093-1966088336.png)\n\n现在只是做了小绿锁的显示，但是并没有实际意义，因为在.net core中还需要配置我们的身份认证授权代码，才能具体发挥其真正的作用，所以目前我们的api还是处于裸奔状态，谁都能调用你的api，等你发现你写的文章都被别人删了，你都不知道为什么。\n\n实现JWT，将在下篇文章中详细说明，本篇到这里就结束了，我们完善了Swagger文档，给接口加了分组、描述，还有小绿锁。老铁，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "jwt"
    ],
    "createdAt": "2020-05-22 09:01:22"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API",
    "author": "阿星Plus",
    "url": "2020-05-23-blog_08",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章再次把Swagger的使用进行了讲解，完成了对Swagger的分组、描述和开启小绿锁以进行身份的认证授权，那么本篇就来说说身份认证授权。\n\n开始之前先搞清楚几个概念，请注意认证与授权是不同的意思，简单理解：认证，是证明你的身份，你有账号密码，你可以登录进我们的系统，说明你认证成功了；授权，即权限，分配给用户某一权限标识，用户得到什么什么权限，才能使用系统的某一功能，就是授权。\n\n身份认证可以有很多种方式，可以创建一个用户表，使用账号密码，也可以接入第三方平台，在这里我接入GitHub进行身份认证。当然你可以选择其他方式(如：QQ、微信、微博等)，可以自己扩展。\n\n打开GitHub，进入开发者设置界面(https://github.com/settings/developers)，我们新建一个 oAuth App。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522105532220-1778866466.png)\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522105827131-636300344.png)\n\n如图所示，我们将要用到敏感数据放在`appsettings.json`中\n\n```json\n{\n  ...\n  \"Github\": {\n    \"UserId\": 13010050,\n    \"ClientID\": \"5956811a5d04337ec2ca\",\n    \"ClientSecret\": \"8fc1062c39728a8c2a47ba445dd45165063edd92\",\n    \"RedirectUri\": \"https://localhost:44388/account/auth\",\n    \"ApplicationName\": \"阿星Plus\"\n  }\n}\n```\n\n`ClientID`和`ClientSecret`是GitHub为我们生成的，请注意保管好你的`ClientID`和`ClientSecret`。我这里直接给出了明文，我将在本篇结束后删掉此 oAuth App 😝。请自己创建噢！\n\n`RedirectUri`是我们自己添加的回调地址。`ApplicationName`是我们应用的名称，全部都要和GitHub对应。\n\n相应的在`AppSettings.cs`中读取\n\n```CSharp\n...\n        /// <summary>\n        /// GitHub\n        /// </summary>\n        public static class GitHub\n        {\n            public static int UserId => Convert.ToInt32(_config[\"Github:UserId\"]);\n\n            public static string Client_ID => _config[\"Github:ClientID\"];\n\n            public static string Client_Secret => _config[\"Github:ClientSecret\"];\n\n            public static string Redirect_Uri => _config[\"Github:RedirectUri\"];\n\n            public static string ApplicationName => _config[\"Github:ApplicationName\"];\n        }\n...\n```\n\n接下来，我们大家自行去GitHub的OAuth官方文档看看，https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/\n\n分析一下，我们接入GitHub身份认证授权整个流程下来分以下几步\n\n1. 根据参数生成GitHub重定向的地址，跳转到GitHub登录页，进行登录\n2. 登录成功之后会跳转到我们的回调地址，回调地址会携带`code`参数\n3. 拿到code参数，就可以换取到access_token\n4. 有了access_token，可以调用GitHub获取用户信息的接口，得到当前登录成功的用户信息\n\n开始之前，先将GitHub的API简单处理一下。\n\n在`.Domain`层中Configurations文件夹下新建`GitHubConfig.cs`配置类，将所需要的API以及`appsettings.json`的内容读取出来。\n\n```CSharp\n//GitHubConfig.cs\nnamespace Meowv.Blog.Domain.Configurations\n{\n    public class GitHubConfig\n    {\n        /// <summary>\n        /// GET请求，跳转GitHub登录界面，获取用户授权，得到code\n        /// </summary>\n        public static string API_Authorize = \"https://github.com/login/oauth/authorize\";\n\n        /// <summary>\n        /// POST请求，根据code得到access_token\n        /// </summary>\n        public static string API_AccessToken = \"https://github.com/login/oauth/access_token\";\n\n        /// <summary>\n        /// GET请求，根据access_token得到用户信息\n        /// </summary>\n        public static string API_User = \"https://api.github.com/user\";\n\n        /// <summary>\n        /// Github UserId\n        /// </summary>\n        public static int UserId = AppSettings.GitHub.UserId;\n\n        /// <summary>\n        /// Client ID\n        /// </summary>\n        public static string Client_ID = AppSettings.GitHub.Client_ID;\n\n        /// <summary>\n        /// Client Secret\n        /// </summary>\n        public static string Client_Secret = AppSettings.GitHub.Client_Secret;\n\n        /// <summary>\n        /// Authorization callback URL\n        /// </summary>\n        public static string Redirect_Uri = AppSettings.GitHub.Redirect_Uri;\n\n        /// <summary>\n        /// Application name\n        /// </summary>\n        public static string ApplicationName = AppSettings.GitHub.ApplicationName;\n    }\n}\n```\n\n细心的同学可能以及看到了，我们在配置的时候多了一个`UserId`。在这里使用一个策略，因为我是博客系统，管理员用户就只有我一个人，GitHub的用户Id是唯一的，我将自己的`UserId`配置进去，当我们通过api获取到`UserId`和自己配置的`UserId`一致时，就为其授权，你就是我，我认可你，你可以进入后台随意玩耍了。\n\n在开始写接口之前，还有一些工作要做，就是在 .net core 中开启使用我们的身份认证和授权，因为`.HttpApi.Hosting`层引用了项目`.Application`，`.Application`层本身也需要添加`Microsoft.AspNetCore.Authentication.JwtBearer`，所以在`.Application`添加包：`Microsoft.AspNetCore.Authentication.JwtBearer`，打开程序包管理器控制台用命令`Install-Package Microsoft.AspNetCore.Authentication.JwtBearer`安装，这样就不需要重复添加引用了。\n\n在`.HttpApi.Hosting`模块类`MeowvBlogHttpApiHostingModule`，`ConfigureServices`中添加\n\n```CSharp\npublic override void ConfigureServices(ServiceConfigurationContext context)\n{\n    // 身份验证\n    context.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n           .AddJwtBearer(options =>\n           {\n               options.TokenValidationParameters = new TokenValidationParameters\n               {\n                   ValidateIssuer = true,\n                   ValidateAudience = true,\n                   ValidateLifetime = true,\n                   ClockSkew = TimeSpan.FromSeconds(30),\n                   ValidateIssuerSigningKey = true,\n                   ValidAudience = AppSettings.JWT.Domain,\n                   ValidIssuer = AppSettings.JWT.Domain,\n                   IssuerSigningKey = new SymmetricSecurityKey(AppSettings.JWT.SecurityKey.GetBytes())\n               };\n           });\n\n    // 认证授权\n    context.Services.AddAuthorization();\n\n    // Http请求\n    context.Services.AddHttpClient();\n}\n```\n\n因为待会我们要在代码中调用GitHub的api，所以这里提前将`System.Net.Http.IHttpClientFactory`和相关服务添加到IServiceCollection中。\n\n解释一下`TokenValidationParameters`参数的含义：\n\n`ValidateIssuer`：是否验证颁发者。`ValidateAudience`：是否验证访问群体。`ValidateLifetime`：是否验证生存期。`ClockSkew`：验证Token的时间偏移量。`ValidateIssuerSigningKey`：是否验证安全密钥。`ValidAudience`：访问群体。`ValidIssuer`：颁发者。`IssuerSigningKey`：安全密钥。\n`GetBytes()`是abp的一个扩展方法，可以直接使用。\n\n设置值全部为true，时间偏移量为30秒，然后将`ValidAudience`、`ValidIssuer`、`IssuerSigningKey`的值配置在`appsettings.json`中，这些值都是可以自定义的，不一定按照我填的来。\n\n```CSharp\n//appsettings.json\n{\n  ...\n  \"JWT\": {\n    \"Domain\": \"https://localhost:44388\",\n    \"SecurityKey\": \"H4sIAAAAAAAAA3N0cnZxdXP38PTy9vH18w8I9AkOCQ0Lj4iMAgDB4fXPGgAAAA==\",\n    \"Expires\": 30\n  }\n}\n\n//AppSettings.cs\n...\n        public static class JWT\n        {\n            public static string Domain => _config[\"JWT:Domain\"];\n\n            public static string SecurityKey => _config[\"JWT:SecurityKey\"];\n\n            public static int Expires => Convert.ToInt32(_config[\"JWT:Expires\"]);\n        }\n...\n```\n\n`Expires`是我们的token过期时间，这里也给个30。至于它是30分钟还是30秒，由你自己决定。\n\n`SecurityKey`是我随便用编码工具进行生成的。\n\n同时在`OnApplicationInitialization(ApplicationInitializationContext context)`中使用它。\n\n```CSharp\n...\n        public override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            ...\n            // 身份验证\n            app.UseAuthentication();\n\n            // 认证授权\n            app.UseAuthorization();\n            ...\n        }\n...\n```\n\n此时配置就完成了，接下来去写接口生成Token并在Swagger中运用起来。\n\n在`.Application`层之前已经添加了包：`Microsoft.AspNetCore.Authentication.JwtBearer`，直接新建Authorize文件夹，添加接口`IAuthorizeService`以及实现类`AuthorizeService`。\n\n```CSharp\n//IAuthorizeService.cs\nusing Meowv.Blog.ToolKits.Base;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Authorize\n{\n    public interface IAuthorizeService\n    {\n        /// <summary>\n        /// 获取登录地址(GitHub)\n        /// </summary>\n        /// <returns></returns>\n        Task<ServiceResult<string>> GetLoginAddressAsync();\n\n        /// <summary>\n        /// 获取AccessToken\n        /// </summary>\n        /// <param name=\"code\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<string>> GetAccessTokenAsync(string code);\n\n        /// <summary>\n        /// 登录成功，生成Token\n        /// </summary>\n        /// <param name=\"access_token\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<string>> GenerateTokenAsync(string access_token);\n    }\n}\n```\n\n添加三个接口成员方法，全部为异步的方式，同时注意我们是用之前编写的返回模型接收噢，然后一一去实现他们。\n\n先实现`GetLoginAddressAsync()`，咱们构建一个`AuthorizeRequest`对象，用来填充生成GitHub登录地址，在`.ToolKits`层新建GitHub文件夹，引用`.Domain`项目，添加类：`AuthorizeRequest.cs`。\n\n```CSharp\n//AuthorizeRequest.cs\nusing Meowv.Blog.Domain.Configurations;\nusing System;\n\nnamespace Meowv.Blog.ToolKits.GitHub\n{\n    public class AuthorizeRequest\n    {\n        /// <summary>\n        /// Client ID\n        /// </summary>\n        public string Client_ID = GitHubConfig.Client_ID;\n\n        /// <summary>\n        /// Authorization callback URL\n        /// </summary>\n        public string Redirect_Uri = GitHubConfig.Redirect_Uri;\n\n        /// <summary>\n        /// State\n        /// </summary>\n        public string State { get; set; } = Guid.NewGuid().ToString(\"N\");\n\n        /// <summary>\n        /// 该参数可选，需要调用Github哪些信息，可以填写多个，以逗号分割，比如：scope=user,public_repo。\n        /// 如果不填写，那么你的应用程序将只能读取Github公开的信息，比如公开的用户信息，公开的库(repository)信息以及gists信息\n        /// </summary>\n        public string Scope { get; set; } = \"user,public_repo\";\n    }\n}\n```\n\n实现方法如下，拼接参数，输出GitHub重定向的地址。\n\n```CSharp\n...\n        /// <summary>\n        /// 获取登录地址(GitHub)\n        /// </summary>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetLoginAddressAsync()\n        {\n            var result = new ServiceResult<string>();\n\n            var request = new AuthorizeRequest();\n            var address = string.Concat(new string[]\n            {\n                    GitHubConfig.API_Authorize,\n                    \"?client_id=\", request.Client_ID,\n                    \"&scope=\", request.Scope,\n                    \"&state=\", request.State,\n                    \"&redirect_uri=\", request.Redirect_Uri\n            });\n\n            result.IsSuccess(address);\n            return await Task.FromResult(result);\n        }\n...\n```\n\n同样的，实现`GetAccessTokenAsync(string code)`，构建`AccessTokenRequest`对象，在`.ToolKits`GitHub文件夹添加类：`AccessTokenRequest.cs`。\n\n```CSharp\n//AccessTokenRequest.cs\nusing Meowv.Blog.Domain.Configurations;\n\nnamespace Meowv.Blog.ToolKits.GitHub\n{\n    public class AccessTokenRequest\n    {\n        /// <summary>\n        /// Client ID\n        /// </summary>\n        public string Client_ID = GitHubConfig.Client_ID;\n\n        /// <summary>\n        /// Client Secret\n        /// </summary>\n        public string Client_Secret = GitHubConfig.Client_Secret;\n\n        /// <summary>\n        /// 调用API_Authorize获取到的Code值\n        /// </summary>\n        public string Code { get; set; }\n\n        /// <summary>\n        /// Authorization callback URL\n        /// </summary>\n        public string Redirect_Uri = GitHubConfig.Redirect_Uri;\n\n        /// <summary>\n        /// State\n        /// </summary>\n        public string State { get; set; }\n    }\n}\n```\n\n根据登录成功得到的code来获取AccessToken，因为涉及到HTTP请求，在这之前我们需要在构造函数中依赖注入`IHttpClientFactory`，使用`IHttpClientFactory`创建`HttpClient`。\n\n```CSharp\n...\nprivate readonly IHttpClientFactory _httpClient;\n\npublic AuthorizeService(IHttpClientFactory httpClient)\n{\n    _httpClient = httpClient;\n}\n...\n```\n\n```CSharp\n...\n        /// <summary>\n        /// 获取AccessToken\n        /// </summary>\n        /// <param name=\"code\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetAccessTokenAsync(string code)\n        {\n            var result = new ServiceResult<string>();\n\n            if (string.IsNullOrEmpty(code))\n            {\n                result.IsFailed(\"code为空\");\n                return result;\n            }\n\n            var request = new AccessTokenRequest();\n\n            var content = new StringContent($\"code={code}&client_id={request.Client_ID}&redirect_uri={request.Redirect_Uri}&client_secret={request.Client_Secret}\");\n            content.Headers.ContentType = new MediaTypeHeaderValue(\"application/x-www-form-urlencoded\");\n\n            using var client = _httpClient.CreateClient();\n            var httpResponse = await client.PostAsync(GitHubConfig.API_AccessToken, content);\n\n            var response = await httpResponse.Content.ReadAsStringAsync();\n\n            if (response.StartsWith(\"access_token\"))\n                result.IsSuccess(response.Split(\"=\")[1].Split(\"&\").First());\n            else\n                result.IsFailed(\"code不正确\");\n\n            return result;\n        }\n...\n```\n\n使用`IHttpClientFactory`创建`HttpClient`可以自动释放对象，用`HttpClient`发送一个POST请求，如果GitHub服务器给我们返回了带access_token的字符串便表示成功了，将其处理一下输出access_token。如果没有，就代表参数code有误。\n\n在`.HttpApi`层新建一个`AuthController`控制器，注入我们的`IAuthorizeService`Service，试试我们的接口。\n\n```CSharp\n//AuthController.cs\nusing Meowv.Blog.Application.Authorize;\nusing Meowv.Blog.ToolKits.Base;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Threading.Tasks;\nusing Volo.Abp.AspNetCore.Mvc;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogConsts;\n\nnamespace Meowv.Blog.HttpApi.Controllers\n{\n    [ApiController]\n    [AllowAnonymous]\n    [Route(\"[controller]\")]\n    [ApiExplorerSettings(GroupName = Grouping.GroupName_v4)]\n    public class AuthController : AbpController\n    {\n        private readonly IAuthorizeService _authorizeService;\n\n        public AuthController(IAuthorizeService authorizeService)\n        {\n            _authorizeService = authorizeService;\n        }\n\n        /// <summary>\n        /// 获取登录地址(GitHub)\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet]\n        [Route(\"url\")]\n        public async Task<ServiceResult<string>> GetLoginAddressAsync()\n        {\n            return await _authorizeService.GetLoginAddressAsync();\n        }\n\n        /// <summary>\n        /// 获取AccessToken\n        /// </summary>\n        /// <param name=\"code\"></param>\n        /// <returns></returns>\n        [HttpGet]\n        [Route(\"access_token\")]\n        public async Task<ServiceResult<string>> GetAccessTokenAsync(string code)\n        {\n            return await _authorizeService.GetAccessTokenAsync(code);\n        }\n    }\n}\n```\n\n注意这里我们添加了两个Attribute：[AllowAnonymous]、[ApiExplorerSettings(GroupName = Grouping.GroupName_v4)]，在`.Swagger`层中为`AuthController`添加描述信息\n\n```CSharp\n...\nnew OpenApiTag {\n    Name = \"Auth\",\n    Description = \"JWT模式认证授权\",\n    ExternalDocs = new OpenApiExternalDocs { Description = \"JSON Web Token\" }\n}\n...\n```\n\n打开Swagger文档，调用一下我们两个接口看看效果。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522150909577-1938687071.png)\n\n然后打开我们生成的重定向地址，会跳转到登录页面，如下：\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522150958833-427621242.png)\n\n点击Authorize按钮，登录成功后会跳转至我们配置的回调页面，.../account/auth?code=10b7a58c7ba2e4414a14&state=a1ef05212c3b4a2cb2bbd87846dd4a8e\n\n然后拿到code(10b7a58c7ba2e4414a14)，在去调用一下获取AccessToken接口，成功返回我们的access_token(97eeafd5ca01b3719f74fc928440c89d59f2eeag)。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522151403124-74550339.png)\n\n拿到access_token，就可以去调用获取用户信息API了。在这之前我们先来写几个扩展方法，待会和以后都用得着，在`.ToolKits`层新建文件夹Extensions，添加几个比较常用的扩展类(...)。\n\n扩展类的代码我就不贴出来了。大家可以去GitHub(https://github.com/Meowv/Blog/tree/blog_tutorial/src/Meowv.Blog.ToolKits/Extensions)自行下载，每个扩展方法都有具体的注释。\n\n接下来实现`GenerateTokenAsync(string access_token)`，生成Token。\n\n有了access_token，可以直接调用获取用户信息的接口：https://api.github.com/user?access_token=97eeafd5ca01b3719f74fc928440c89d59f2eeag ，会得到一个json，将这个json包装成一个模型类`UserResponse.cs`。\n\n在这里教大家一个小技巧，如果你需要将json或者xml转换成模型类，可以使用Visual Studio的一个快捷功能，点击左上角菜单：编辑 => 选择性粘贴 => 将JSON粘贴为类/将XML粘贴为类，是不是很方便，快去试试吧。\n\n```CSharp\n//UserResponse.cs\nnamespace Meowv.Blog.ToolKits.GitHub\n{\n    public class UserResponse\n    {\n        public string Login { get; set; }\n\n        public int Id { get; set; }\n\n        public string Avatar_url { get; set; }\n\n        public string Html_url { get; set; }\n\n        public string Repos_url { get; set; }\n\n        public string Name { get; set; }\n\n        public string Company { get; set; }\n\n        public string Blog { get; set; }\n\n        public string Location { get; set; }\n\n        public string Email { get; set; }\n\n        public string Bio { get; set; }\n\n        public int Public_repos { get; set; }\n    }\n}\n```\n\n然后看一下具体生成token的方法吧。\n\n```CSharp\n...\n        /// <summary>\n        /// 登录成功，生成Token\n        /// </summary>\n        /// <param name=\"access_token\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GenerateTokenAsync(string access_token)\n        {\n            var result = new ServiceResult<string>();\n\n            if (string.IsNullOrEmpty(access_token))\n            {\n                result.IsFailed(\"access_token为空\");\n                return result;\n            }\n\n            var url = $\"{GitHubConfig.API_User}?access_token={access_token}\";\n            using var client = _httpClient.CreateClient();\n            client.DefaultRequestHeaders.Add(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.14 Safari/537.36 Edg/83.0.478.13\");\n            var httpResponse = await client.GetAsync(url);\n            if (httpResponse.StatusCode != HttpStatusCode.OK)\n            {\n                result.IsFailed(\"access_token不正确\");\n                return result;\n            }\n\n            var content = await httpResponse.Content.ReadAsStringAsync();\n\n            var user = content.FromJson<UserResponse>();\n            if (user.IsNull())\n            {\n                result.IsFailed(\"未获取到用户数据\");\n                return result;\n            }\n\n            if (user.Id != GitHubConfig.UserId)\n            {\n                result.IsFailed(\"当前账号未授权\");\n                return result;\n            }\n\n            var claims = new[] {\n                    new Claim(ClaimTypes.Name, user.Name),\n                    new Claim(ClaimTypes.Email, user.Email),\n                    new Claim(JwtRegisteredClaimNames.Exp, $\"{new DateTimeOffset(DateTime.Now.AddMinutes(AppSettings.JWT.Expires)).ToUnixTimeSeconds()}\"),\n                    new Claim(JwtRegisteredClaimNames.Nbf, $\"{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}\")\n                };\n\n            var key = new SymmetricSecurityKey(AppSettings.JWT.SecurityKey.SerializeUtf8());\n            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n            var securityToken = new JwtSecurityToken(\n                issuer: AppSettings.JWT.Domain,\n                audience: AppSettings.JWT.Domain,\n                claims: claims,\n                expires: DateTime.Now.AddMinutes(AppSettings.JWT.Expires),\n                signingCredentials: creds);\n\n            var token = new JwtSecurityTokenHandler().WriteToken(securityToken);\n\n            result.IsSuccess(token);\n            return await Task.FromResult(result);\n        }\n...\n```\n\nGitHub的这个API做了相应的安全机制，有一点要注意一下，当我们用代码去模拟请求的时候，需要给他加上`User-Agent`，不然是不会成功返回结果的。\n\n`FromJson<T>`是之前我们添加的扩展方法，将JSON字符串转为实体对象。\n\n`SymmetricSecurityKey(byte[] key)`接收一个`byte[]`参数，这里也用到一个扩展方法`SerializeUtf8()`字符串序列化成字节序列。\n\n我们判断返回的Id是否为我们配置的用户Id，如果是的话，就验证成功，进行授权，生成Token。\n\n生成Token的代码也很简单，指定了 Name，Email，过期时间为30分钟。具体各项含义可以去这里看看：https://tools.ietf.org/html/rfc7519。\n\n最后调用`new JwtSecurityTokenHandler().WriteToken(SecurityToken token)`便可成功生成Token，在Controller添加好，去试试吧。\n\n```CSharp\n...\n        /// <summary>\n        /// 登录成功，生成Token\n        /// </summary>\n        /// <param name=\"access_token\"></param>\n        /// <returns></returns>\n        [HttpGet]\n        [Route(\"token\")]\n        public async Task<ServiceResult<string>> GenerateTokenAsync(string access_token)\n        {\n            return await _authorizeService.GenerateTokenAsync(access_token);\n        }\n...\n```\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522162514843-120950440.png)\n\n将之前拿到的access_token传进去，调用接口可以看到已经成功生成了token。\n\n前面为`AuthController`添加了一个Attribute：`[AllowAnonymous]`，代表这个Controller下的接口都不需要授权，就可以访问，当然你不添加的话默认也是开放的。可以为整个Controller指定，同时也可以为具体的接口指定。\n\n当想要保护某个接口时，只需要加上Attribute：`[Authorize]`就可以了。现在来保护我们的`BlogController`下非查询接口，给增删改添加上`[Authorize]`，注意引用命名空间`Microsoft.AspNetCore.Authorization`。\n\n```CSharp\n...\n        ...\n        /// <summary>\n        /// 添加博客\n        /// </summary>\n        /// <param name=\"dto\"></param>\n        /// <returns></returns>\n        [HttpPost]\n        [Authorize]\n        public async Task<ServiceResult<string>> InsertPostAsync([FromBody] PostDto dto)\n        ...\n\n        /// <summary>\n        /// 删除博客\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <returns></returns>\n        [HttpDelete]\n        [Authorize]\n        public async Task<ServiceResult> DeletePostAsync([Required] int id)\n        ...\n\n        /// <summary>\n        /// 更新博客\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <param name=\"dto\"></param>\n        /// <returns></returns>\n        [HttpPut]\n        [Authorize]\n        public async Task<ServiceResult<string>> UpdatePostAsync([Required] int id, [FromBody] PostDto dto)\n        ...\n\n        /// <summary>\n        /// 查询博客\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <returns></returns>\n        [HttpGet]\n        public async Task<ServiceResult<PostDto>> GetPostAsync([Required] int id)\n        ...\n...\n```\n\n现在编译运行一下，调用上面的增删改看看能不能成功？\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522163621856-717767527.png)\n\n这时接口就会直接给我们返回一个状态码为401的错误，为了避免这种不友好的错误，我们可以添加一个中间件来处理我们的管道请求或者在`AddJwtBearer()`中处理我们的身份验证事件机制，当遇到错误的状态码时，我们还是返回我们之前的创建的模型，定义友好的返回错误，将在后面篇章中给出具体方法。\n\n可以看到公开的API和需要授权的API小绿锁是不一样的，公开的显示为黑色，需要授权的显示为灰色。\n\n如果需要在Swagger中调用我们的非公开API，要怎么做呢？点击我们的小绿锁将生成的token按照`Bearer {Token}`的方式填进去即可。\n\n![8](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522164813436-1844629567.png)\n\n注意不要点Logout，否则就退出了。\n\n![9](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522165315203-1321296014.png)\n\n可以看到当我们请求的时候，请求头上多了一个`authorization: Bearer {token}`，此时便大功告成了。当我们在web中调用的时候，也遵循这个规则即可。\n\n> 特别提示\n\n在我做授权的时候，token也生成成功了，也在Swagger中正确填写Bearer {token}了。调用接口的时候始终还是返回401，最终发现导致这个问题的原因是在配置Swagger小绿锁时一个错误名称导致的。\n\n![10](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200522170107298-1907573618.png)\n\n看他的描述为：A unique name for the scheme, as per the Swagger spec.(根据Swagger规范，该方案的唯一名称)\n\n如图，将其名称改为 \"oauth2\" ，便可以成功授权。本篇接入了GitHub，实现了认证和授权，用JWT的方式保护我们写的API，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n```\n\n```\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "GitHub",
      "abp vNext",
      "Swagger",
      "jwt",
      "Authorize"
    ],
    "createdAt": "2020-05-23 10:04:23"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录",
    "author": "阿星Plus",
    "url": "2020-05-25-blog_09",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n在开始之前，我们实现一个之前的遗留问题，这个问题是有人在GitHub Issues(https://github.com/Meowv/Blog/issues/8)上提出来的，就是当我们对Swagger进行分组，实现`IDocumentFilter`接口添加了文档描述信息后，切换分组时会显示不属于当前分组的Tag。\n\n经过研究和分析发现，是可以解决的，我不知道大家有没有更好的办法，我的实现方法请看：\n\n![0](https://img2020.cnblogs.com/blog/891843/202005/891843-20200523170024363-1101269881.png)\n\n```CSharp\n//SwaggerDocumentFilter.cs\n...\n        public void Apply(OpenApiDocument swaggerDoc, DocumentFilterContext context)\n        {\n            var tags = new List<OpenApiTag>{...}\n            \n            #region 实现添加自定义描述时过滤不属于同一个分组的API\n\n            var groupName = context.ApiDescriptions.FirstOrDefault().GroupName;\n\n            var apis = context.ApiDescriptions.GetType().GetField(\"_source\", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(context.ApiDescriptions) as IEnumerable<ApiDescription>;\n\n            var controllers = apis.Where(x => x.GroupName != groupName).Select(x => ((ControllerActionDescriptor)x.ActionDescriptor).ControllerName).Distinct();\n\n            swaggerDoc.Tags = tags.Where(x => !controllers.Contains(x.Name)).OrderBy(x => x.Name).ToList();\n\n            #endregion\n        }\n...\n```\n\n根据调试代码发现，我们可以从`context.ApiDescriptions`获取到当前显示的是哪一个分组下的API。\n\n然后使用`GetType().GetField(string name, BindingFlags bindingAttr)`获取到`_source`，当前项目的所有API，里面同时也包含了ABP默认生成的一些接口。\n\n再将API中不属于当前分组的API筛选掉，用Select查询出所有的Controller名称进行去重。\n\n因为`OpenApiTag`中的Name名称与Controller的Name是一致的，所以最后将包含`controllers`名称的tag查询出来取反，即可满足需求。\n\n---\n\n上一篇文章(https://www.cnblogs.com/meowv/p/12935693.html)集成了GitHub，使用JWT的方式完成了身份认证和授权，保护了我们写的API接口。\n\n本篇主要实现对项目中出现的异常仅需处理，当出现不可避免的错误时，或者未授权用户调用接口时，可以进行有效的监控和日志记录。\n\n目前调用未授权接口，会直接返回一个状态码为401的错误页面，这样显得太不友好，我们还是用之前写的统一返回模型来告诉调用者，你是未授权的，调不了我的接口，上篇也有提到过，我们将用两种方式来解决。\n\n**方式一** ：使用`AddJwtBearer()`扩展方法下面的`options.Events`事件机制。\n\n```CSharp\n//MeowvBlogHttpApiHostingModule.cs\n...\n\t//应用程序提供的对象，用于处理承载引发的事件，身份验证处理程序\n\toptions.Events = new JwtBearerEvents\n\t{\n\t    OnChallenge = async context =>\n\t    {\n\t        // 跳过默认的处理逻辑，返回下面的模型数据\n\t        context.HandleResponse();\n\t\n\t        context.Response.ContentType = \"application/json;charset=utf-8\";\n\t        context.Response.StatusCode = StatusCodes.Status200OK;\n\t\n\t        var result = new ServiceResult();\n\t        result.IsFailed(\"UnAuthorized\");\n\t\n\t        await context.Response.WriteAsync(result.ToJson());\n\t    }\n\t};\n...\n```\n\n在项目启动时，实例化了`OnChallenge`，如果用户调用未授权，将请求的状态码赋值为200，并返回模型数据。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200523172916427-827941643.png)\n\n如图所示，可以看到已经成功返回了一段比较友好的JSON数据。\n\n```json\n{\n  \"Code\": 1,\n  \"Message\": \"UnAuthorized\",\n  \"Success\": false,\n  \"Timestamp\": 1590226085318\n}\n```\n\n**方式二** ：使用中间件的方式。\n\n我们注释掉上面的代码，在`.HttpApi.Hosting`添加文件夹Middleware，新建一个中间件`ExceptionHandlerMiddleware.cs`\n\n```\nusing Meowv.Blog.ToolKits.Base;\nusing Meowv.Blog.ToolKits.Extensions;\nusing Microsoft.AspNetCore.Http;\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.HttpApi.Hosting.Middleware\n{\n    /// <summary>\n    /// 异常处理中间件\n    /// </summary>\n    public class ExceptionHandlerMiddleware\n    {\n        private readonly RequestDelegate next;\n\n        public ExceptionHandlerMiddleware(RequestDelegate next)\n        {\n            this.next = next;\n        }\n\n        /// <summary>\n        /// Invoke\n        /// </summary>\n        /// <param name=\"context\"></param>\n        /// <returns></returns>\n        public async Task Invoke(HttpContext context)\n        {\n            try\n            {\n                await next(context);\n            }\n            catch (Exception ex)\n            {\n                await ExceptionHandlerAsync(context, ex.Message);\n            }\n            finally\n            {\n                var statusCode = context.Response.StatusCode;\n                if (statusCode != StatusCodes.Status200OK)\n                {\n                    Enum.TryParse(typeof(HttpStatusCode), statusCode.ToString(), out object message);\n                    await ExceptionHandlerAsync(context, message.ToString());\n                }\n            }\n        }\n\n        /// <summary>\n        /// 异常处理，返回JSON\n        /// </summary>\n        /// <param name=\"context\"></param>\n        /// <param name=\"message\"></param>\n        /// <returns></returns>\n        private async Task ExceptionHandlerAsync(HttpContext context, string message)\n        {\n            context.Response.ContentType = \"application/json;charset=utf-8\";\n\n            var result = new ServiceResult();\n            result.IsFailed(message);\n\n            await context.Response.WriteAsync(result.ToJson());\n        }\n    }\n}\n```\n\n`RequestDelegate`是一种请求委托类型，用来处理HTTP请求的函数，返回的是`delegate`，实现异步的`Invoke`方法。\n\n这里我写了一个比较通用的方法，当出现异常时直接执行`ExceptionHandlerAsync()`方法，当没有异常发生时，在`finally`中判断当前请求状态，可能是200？404？401？等等，不管它是什么，反正不是200，获取到状态码枚举的Key值用来当作错误信息返回，最后也执行`ExceptionHandlerAsync()`方法，返回我们自定义的模型。\n\n写好了中间件，然后在`OnApplicationInitialization(...)`中使用它。\n\n```CSharp\npublic override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            ...\n            // 异常处理中间件\n            app.UseMiddleware<ExceptionHandlerMiddleware>();\n            ...\n        }\n```\n\n同样可以达到效果，相比之下他还支持状态非401的错误返回，比如我们访问一个不存在的页面：https://localhost:44388/aaa ，也可以友好的进行处理。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200523175616269-2001433886.png)\n\n当然这两种方式可以共存，互不影响。\n\n还有一种处理异常的方式，就是我们的过滤器Filter，abp已经默认为我们实现了全局的异常模块，详情可以看其文档：https://docs.abp.io/zh-Hans/abp/latest/Exception-Handling ，在这里，我准备移除abp提供的异常处理模块，自己实现一个。\n\n先看一下目前的异常显示情况，我们在`HelloWorldController`中写一个异常接口。\n\n```CSharp\n//HelloWorldController.cs\n...\n        [HttpGet]\n        [Route(\"Exception\")]\n        public string Exception()\n        {\n            throw new NotImplementedException(\"这是一个未实现的异常接口\");\n        }\n...\n```\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200523181756975-810381804.png)\n\n按理说，他应该会执行到我们写的`ExceptionHandlerMiddleware`中间件中去，但是被我们的Filter进行拦截了，现在我们移除默认的拦截器`AbpExceptionFilter`\n\n还是在模块类`MeowvBlogHttpApiHostingModule`，`ConfigureServices()`方法中。\n\n```CSharp\nConfigure<MvcOptions>(options =>\n{\n    var filterMetadata = options.Filters.FirstOrDefault(x => x is ServiceFilterAttribute attribute && attribute.ServiceType.Equals(typeof(AbpExceptionFilter)));\n\n    // 移除 AbpExceptionFilter\n    options.Filters.Remove(filterMetadata);\n});\n```\n\n从`options.Filters`中找到`AbpExceptionFilter`，然后Remove掉，此时再看一下有异常的接口。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200523182414745-1132702809.png)\n\n当我们注释掉我们的中间件时，他就会显示如下图这样。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200523182627715-1392661032.png)\n\n这个页面有没有很熟悉的感觉？相信做过.net core开发的都遇到过吧。\n\nok，现在为止已经完美显示了。但到这里还远远不够，说好的自己实现Filter呢？我们现在实现Filter又有什么用呢？我们可以在Filter中可以做一些日志记录。\n\n在`.HttpApi.Hosting`层添加文件夹Filters，新建一个`MeowvBlogExceptionFilter.cs`的Filter，他需要实现我们的`IExceptionFilter`接口的`OnExceptionAsync()`方法即可。\n\n```CSharp\n//MeowvBlogExceptionFilter.cs\nusing Meowv.Blog.ToolKits.Helper;\nusing Microsoft.AspNetCore.Mvc.Filters;\n\nnamespace Meowv.Blog.HttpApi.Hosting.Filters\n{\n    public class MeowvBlogExceptionFilter : IExceptionFilter\n    {\n        /// <summary>\n        /// 异常处理\n        /// </summary>\n        /// <param name=\"context\"></param>\n        /// <returns></returns>\n        public void OnException(ExceptionContext context)\n        {\n            // 日志记录\n            LoggerHelper.WriteToFile($\"{context.HttpContext.Request.Path}|{context.Exception.Message}\", context.Exception);\n        }\n    }\n}\n```\n\n`OnException(...)`方法很简单，这里只做了记录日志的操作，剩下的交给我们中间件去处理吧。\n\n注意，一定要在移除默认`AbpExceptionFilter`后，将我们自己实现的`MeowvBlogExceptionFilter`在模块类`ConfigureServices()`方法中注入到系统。\n\n```CSharp\n...\n\tConfigure<MvcOptions>(options =>\n\t{\n\t    ...\n\t    // 添加自己实现的 MeowvBlogExceptionFilter\n\t    options.Filters.Add(typeof(MeowvBlogExceptionFilter));\n\t});\n...\n```\n\n说到日志，就有很多种处理方式，**请选择你熟悉的方式**，我这里将使用`log4net`进行处理，仅供参考。\n\n在`.ToolKits`层添加`log4net`包，使用命令安装：`Install-Package log4net`，然后添加文件夹Helper，新建一个`LoggerHelper.cs`。\n\n```CSharp\n//LoggerHelper.cs\nusing log4net;\nusing log4net.Config;\nusing log4net.Repository;\nusing System;\nusing System.IO;\n\nnamespace Meowv.Blog.ToolKits.Helper\n{\n    public static class LoggerHelper\n    {\n        private static readonly ILoggerRepository Repository = LogManager.CreateRepository(\"NETCoreRepository\");\n        private static readonly ILog Log = LogManager.GetLogger(Repository.Name, \"NETCorelog4net\");\n\n        static LoggerHelper()\n        {\n            XmlConfigurator.Configure(Repository, new FileInfo(\"log4net.config\"));\n        }\n\n        /// <summary>\n        /// 写日志\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <param name=\"ex\"></param>\n        public static void WriteToFile(string message)\n        {\n            Log.Info(message);\n        }\n\n        /// <summary>\n        /// 写日志\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <param name=\"ex\"></param>\n        public static void WriteToFile(string message, Exception ex)\n        {\n            if (string.IsNullOrEmpty(message))\n                message = ex.Message;\n\n            Log.Error(message, ex);\n        }\n    }\n}\n```\n\n在`.HttpApi.Hosting`中添加log4net配置文件，`log4net.config`配置文件如下：\n\n```xml\n//log4net.config\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <configSections>\n    <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/>\n  </configSections>\n  <log4net debug=\"false\">\n\n    <appender name=\"info\" type=\"log4net.Appender.RollingFileAppender,log4net\">\n      <param name=\"File\" value=\"log4net/info/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"MaxSizeRollBackups\" value=\"-1\"/>\n      <param name=\"MaximumFileSize\" value=\"5MB\"/>\n      <param name=\"RollingStyle\" value=\"Composite\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\\\\HH&quot;.log&quot;\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n\n{\n\t&quot;system&quot;: &quot;Meowv.Blog&quot;,\n\t&quot;datetime&quot;: &quot;%d&quot;,\n\t&quot;description&quot;: &quot;%m&quot;,\n  &quot;level&quot;: &quot;%p&quot;,\n\t&quot;info&quot;: &quot;%exception&quot;\n}\" />\n      </layout>\n      <filter type=\"log4net.Filter.LevelRangeFilter\">\n        <levelMin value=\"INFO\" />\n        <levelMax value=\"INFO\" />\n      </filter>\n    </appender>\n\n    <appender name=\"error\" type=\"log4net.Appender.RollingFileAppender,log4net\">\n      <param name=\"File\" value=\"log4net/error/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"MaxSizeRollBackups\" value=\"-1\"/>\n      <param name=\"MaximumFileSize\" value=\"5MB\"/>\n      <param name=\"RollingStyle\" value=\"Composite\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\\\\HH&quot;.log&quot;\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n\n{\n\t&quot;system&quot;: &quot;Meowv.Blog&quot;,\n\t&quot;datetime&quot;: &quot;%d&quot;,\n\t&quot;description&quot;: &quot;%m&quot;,\n  &quot;level&quot;: &quot;%p&quot;,\n\t&quot;info&quot;: &quot;%exception&quot;\n}\" />\n      </layout>\n      <filter type=\"log4net.Filter.LevelRangeFilter\">\n        <levelMin value=\"ERROR\" />\n        <levelMax value=\"ERROR\" />\n      </filter>\n    </appender>\n\n    <root>\n      <level value=\"ALL\"></level>\n      <appender-ref ref=\"info\"/>\n      <appender-ref ref=\"error\"/>\n    </root>\n\n  </log4net>\n\n</configuration>\n```\n\n此时再去调用 .../HelloWorld/Exception，将会得到日志文件，内容是以JSON格式进行存储的。\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200523203231072-1120908287.png)\n\n关于Filter的更多用法可以参考微软官方文档：https://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters\n\n到这里，系统的异常处理和日志记录便完成了，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "Filter",
      "Middleware",
      "Log4net"
    ],
    "createdAt": "2020-05-25 08:48:25"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据",
    "author": "阿星Plus",
    "url": "2020-05-26-blog_10",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章(https://www.cnblogs.com/meowv/p/12943699.html)完成了项目的全局异常处理和日志记录。\n\n在日志记录中使用的静态方法有人指出写法不是很优雅，遂优化一下上一篇中日志记录的方法，具体操作如下：\n\n在`.ToolKits`层中新建扩展方法`Log4NetExtensions.cs`。\n\n```CSharp\n//Log4NetExtensions.cs\nusing log4net;\nusing log4net.Config;\nusing Microsoft.Extensions.Hosting;\nusing System.IO;\nusing System.Reflection;\n\nnamespace Meowv.Blog.ToolKits.Extensions\n{\n    public static class Log4NetExtensions\n    {\n        public static IHostBuilder UseLog4Net(this IHostBuilder hostBuilder)\n        {\n            var log4netRepository = LogManager.GetRepository(Assembly.GetEntryAssembly());\n            XmlConfigurator.Configure(log4netRepository, new FileInfo(\"log4net.config\"));\n\n            return hostBuilder;\n        }\n    }\n}\n```\n\n配置log4net，然后我们直接返回IHostBuilder对象，便于在`Main`方法中链式调用。\n\n```CSharp\n//Program.cs\nusing Meowv.Blog.ToolKits.Extensions;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.HttpApi.Hosting\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            await Host.CreateDefaultBuilder(args)\n                      .UseLog4Net()\n                      .ConfigureWebHostDefaults(builder =>\n                      {\n                          builder.UseIISIntegration()\n                                 .UseStartup<Startup>();\n                      }).UseAutofac().Build().RunAsync();\n        }\n    }\n}\n```\n\n然后修改`MeowvBlogExceptionFilter`过滤器，代码如下：\n\n```CSharp\n//MeowvBlogExceptionFilter.cs\nusing log4net;\nusing Microsoft.AspNetCore.Mvc.Filters;\n\nnamespace Meowv.Blog.HttpApi.Hosting.Filters\n{\n    public class MeowvBlogExceptionFilter : IExceptionFilter\n    {\n        private readonly ILog _log;\n\n        public MeowvBlogExceptionFilter()\n        {\n            _log = LogManager.GetLogger(typeof(MeowvBlogExceptionFilter));\n        }\n\n        /// <summary>\n        /// 异常处理\n        /// </summary>\n        /// <param name=\"context\"></param>\n        /// <returns></returns>\n        public void OnException(ExceptionContext context)\n        {\n            // 错误日志记录\n            _log.Error($\"{context.HttpContext.Request.Path}|{context.Exception.Message}\", context.Exception);\n        }\n    }\n}\n```\n\n可以删掉之前添加的`LoggerHelper.cs`类，运行一下，同样可以达到预期效果。\n\n---\n\n本篇将集成Redis，使用Redis来缓存数据，使用方法参考的微软官方文档：https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed\n\n关于Redis的介绍这里就不多说了，这里有一篇快速入门的文章：[Redis快速入门及使用](https://www.cnblogs.com/meowv/p/11310452.html)，对于不了解的同学可以看看。\n\n直入主题，先在`appsettings.json`配置Redis的连接字符串。\n\n```json\n//appsettings.json\n...\n  \"Caching\": {\n    \"RedisConnectionString\": \"127.0.0.1:6379,password=123456,ConnectTimeout=15000,SyncTimeout=5000\"\n  }\n...\n```\n\n对应的，在`AppSettings.cs`中读取。\n\n```CSharp\n//AppSettings.cs\n...\n        /// <summary>\n        /// Caching\n        /// </summary>\n        public static class Caching\n        {\n            /// <summary>\n            /// RedisConnectionString\n            /// </summary>\n            public static string RedisConnectionString => _config[\"Caching:RedisConnectionString\"];\n        }\n...\n```\n\n在`.Application.Caching`层添加包`Microsoft.Extensions.Caching.StackExchangeRedis`，然后在模块类`MeowvBlogApplicationCachingModule`中添加配置缓存实现。\n\n```CSharp\n//MeowvBlogApplicationCachingModule.cs\nusing Meowv.Blog.Domain;\nusing Meowv.Blog.Domain.Configurations;\nusing Microsoft.Extensions.DependencyInjection;\nusing Volo.Abp.Caching;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Application.Caching\n{\n    [DependsOn(\n        typeof(AbpCachingModule),\n        typeof(MeowvBlogDomainModule)\n    )]\n    public class MeowvBlogApplicationCachingModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            context.Services.AddStackExchangeRedisCache(options =>\n            {\n                options.Configuration = AppSettings.Caching.RedisConnectionString;\n                //options.InstanceName\n                //options.ConfigurationOptions\n            });\n        }\n    }\n}\n```\n\n`options.Configuration`是 Redis 的连接字符串。\n\n`options.InstanceNam`是 Redis 实例名称，这里没填。\n\n`options.ConfigurationOptions`是 Redis 的配置属性，如果配置了这个字，将优先于 Configuration 中的配置，同时它支持更多的选项。我这里也没填。\n\n紧接着我们就可以直接使用了，直接将`IDistributedCache`接口依赖关系注入即可。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200525143836366-1137949385.png)\n\n可以看到默认已经实现了这么多常用的接口，已经够我这个小项目用的了，同时在`Microsoft.Extensions.Caching.Distributed.DistributedCacheExtensions`中微软还给我们提供了很多扩展方法。\n\n于是，我们我就想到写一个新的扩展方法，可以同时处理获取和添加缓存的操作，当缓存存在时，直接返回，不存在时，添加缓存。\n\n新建`MeowvBlogApplicationCachingExtensions.cs`扩展方法，如下：\n\n```CSharp\n//MeowvBlogApplicationCachingExtensions.cs\nusing Meowv.Blog.ToolKits.Extensions;\nusing Microsoft.Extensions.Caching.Distributed;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Caching\n{\n    public static class MeowvBlogApplicationCachingExtensions\n    {\n        /// <summary>\n        /// 获取或添加缓存\n        /// </summary>\n        /// <typeparam name=\"TCacheItem\"></typeparam>\n        /// <param name=\"cache\"></param>\n        /// <param name=\"key\"></param>\n        /// <param name=\"factory\"></param>\n        /// <param name=\"minutes\"></param>\n        /// <returns></returns>\n        public static async Task<TCacheItem> GetOrAddAsync<TCacheItem>(this IDistributedCache cache, string key, Func<Task<TCacheItem>> factory, int minutes)\n        {\n            TCacheItem cacheItem;\n\n            var result = await cache.GetStringAsync(key);\n            if (string.IsNullOrEmpty(result))\n            {\n                cacheItem = await factory.Invoke();\n\n                var options = new DistributedCacheEntryOptions();\n                if (minutes != CacheStrategy.NEVER)\n                {\n                    options.AbsoluteExpiration = DateTimeOffset.Now.AddMinutes(minutes);\n                }\n\n                await cache.SetStringAsync(key, cacheItem.ToJson(), options);\n            }\n            else\n            {\n                cacheItem = result.FromJson<TCacheItem>();\n            }\n\n            return cacheItem;\n        }\n    }\n}\n```\n\n我们可以在`DistributedCacheEntryOptions`中可以配置我们的缓存过期时间，其中有一个判断条件，就是当`minutes = -1`的时候，不指定过期时间，那么我们的缓存就不会过期了。\n\n`GetStringAsync()`、`SetStringAsync()`是`DistributedCacheExtensions`的扩展方法，最终会将缓存项`cacheItem`转换成JSON格式进行存储。\n\n`CacheStrategy`是在`.Domain.Shared`层定义的缓存过期时间策略常量。\n\n```CSharp\n//MeowvBlogConsts.cs\n...\n        /// <summary>\n        /// 缓存过期时间策略\n        /// </summary>\n        public static class CacheStrategy\n        {\n            /// <summary>\n            /// 一天过期24小时\n            /// </summary>\n\n            public const int ONE_DAY = 1440;\n\n            /// <summary>\n            /// 12小时过期\n            /// </summary>\n\n            public const int HALF_DAY = 720;\n\n            /// <summary>\n            /// 8小时过期\n            /// </summary>\n\n            public const int EIGHT_HOURS = 480;\n\n            /// <summary>\n            /// 5小时过期\n            /// </summary>\n\n            public const int FIVE_HOURS = 300;\n\n            /// <summary>\n            /// 3小时过期\n            /// </summary>\n\n            public const int THREE_HOURS = 180;\n\n            /// <summary>\n            /// 2小时过期\n            /// </summary>\n\n            public const int TWO_HOURS = 120;\n\n            /// <summary>\n            /// 1小时过期\n            /// </summary>\n\n            public const int ONE_HOURS = 60;\n\n            /// <summary>\n            /// 半小时过期\n            /// </summary>\n\n            public const int HALF_HOURS = 30;\n\n            /// <summary>\n            /// 5分钟过期\n            /// </summary>\n            public const int FIVE_MINUTES = 5;\n\n            /// <summary>\n            /// 1分钟过期\n            /// </summary>\n            public const int ONE_MINUTE = 1;\n\n            /// <summary>\n            /// 永不过期\n            /// </summary>\n\n            public const int NEVER = -1;\n        }\n...\n```\n\n接下来去创建缓存接口类和实现类，然后再我们的引用服务层`.Application`中进行调用，拿上一篇中接入GitHub的几个接口来做新增缓存操作。\n\n和`.Application`层格式一样，在`.Application.Caching`中新建Authorize文件夹，添加缓存接口`IAuthorizeCacheService`和实现类`AuthorizeCacheService`。\n\n注意命名规范，实现类肯定要继承一个公共的`CachingServiceBase`基类。在`.Application.Caching`层根目录添加`MeowvBlogApplicationCachingServiceBase.cs`，继承`ITransientDependency`。\n\n```CSharp\n//MeowvBlogApplicationCachingServiceBase.cs\nusing Microsoft.Extensions.Caching.Distributed;\nusing Volo.Abp.DependencyInjection;\n\nnamespace Meowv.Blog.Application.Caching\n{\n    public class CachingServiceBase : ITransientDependency\n    {\n        public IDistributedCache Cache { get; set; }\n    }\n}\n```\n\n然后使用属性注入的方式，注入`IDistributedCache`。这样我们只要继承了基类：`CachingServiceBase`，就可以愉快的使用缓存了。\n\n添加要缓存的接口到`IAuthorizeCacheService`，在这里我们使用`Func()`方法，我们的接口返回什么类型由`Func()`来决定，于是添加三个接口如下：\n\n```CSharp\n//IAuthorizeCacheService.cs\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Caching.Authorize\n{\n    public interface IAuthorizeCacheService\n    {\n        /// <summary>\n        /// 获取登录地址(GitHub)\n        /// </summary>\n        /// <returns></returns>\n        Task<ServiceResult<string>> GetLoginAddressAsync(Func<Task<ServiceResult<string>>> factory);\n\n        /// <summary>\n        /// 获取AccessToken\n        /// </summary>\n        /// <param name=\"code\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<string>> GetAccessTokenAsync(string code, Func<Task<ServiceResult<string>>> factory);\n\n        /// <summary>\n        /// 登录成功，生成Token\n        /// </summary>\n        /// <param name=\"access_token\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<string>> GenerateTokenAsync(string access_token, Func<Task<ServiceResult<string>>> factory);\n    }\n}\n```\n\n是不是和`IAuthorizeService`代码很像，的确，我就是直接复制过来改的。\n\n在`AuthorizeCacheService`中实现接口。\n\n```CSharp\n//AuthorizeCacheService.cs\nusing Meowv.Blog.ToolKits.Base;\nusing Meowv.Blog.ToolKits.Extensions;\nusing System;\nusing System.Threading.Tasks;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogConsts;\n\nnamespace Meowv.Blog.Application.Caching.Authorize.Impl\n{\n    public class AuthorizeCacheService : CachingServiceBase, IAuthorizeCacheService\n    {\n        private const string KEY_GetLoginAddress = \"Authorize:GetLoginAddress\";\n\n        private const string KEY_GetAccessToken = \"Authorize:GetAccessToken-{0}\";\n\n        private const string KEY_GenerateToken = \"Authorize:GenerateToken-{0}\";\n\n        /// <summary>\n        /// 获取登录地址(GitHub)\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetLoginAddressAsync(Func<Task<ServiceResult<string>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_GetLoginAddress, factory, CacheStrategy.NEVER);\n        }\n\n        /// <summary>\n        /// 获取AccessToken\n        /// </summary>\n        /// <param name=\"code\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetAccessTokenAsync(string code, Func<Task<ServiceResult<string>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_GetAccessToken.FormatWith(code), factory, CacheStrategy.FIVE_MINUTES);\n        }\n\n        /// <summary>\n        /// 登录成功，生成Token\n        /// </summary>\n        /// <param name=\"access_token\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GenerateTokenAsync(string access_token, Func<Task<ServiceResult<string>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_GenerateToken.FormatWith(access_token), factory, CacheStrategy.ONE_HOURS);\n        }\n    }\n}\n```\n\n代码很简单，每个缓存都有固定KEY值，根据参数生成KEY，然后调用前面写的扩展方法，再给一个过期时间即可，可以看到KEY里面包含了冒号 `:`，这个冒号 `:` 可以起到类似于文件夹的操作，在界面化管理工具中可以很友好的查看。\n\n这样我们的缓存就搞定了，然后在`.Application`层对应的Service中进行调用。代码如下：\n\n```CSharp\n//AuthorizeService.cs\nusing Meowv.Blog.Application.Caching.Authorize;\nusing Meowv.Blog.Domain.Configurations;\nusing Meowv.Blog.ToolKits.Base;\nusing Meowv.Blog.ToolKits.Extensions;\nusing Meowv.Blog.ToolKits.GitHub;\nusing Microsoft.IdentityModel.Tokens;\nusing System;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Authorize.Impl\n{\n    public class AuthorizeService : ServiceBase, IAuthorizeService\n    {\n        private readonly IAuthorizeCacheService _authorizeCacheService;\n        private readonly IHttpClientFactory _httpClient;\n\n        public AuthorizeService(IAuthorizeCacheService authorizeCacheService,\n                                IHttpClientFactory httpClient)\n        {\n            _authorizeCacheService = authorizeCacheService;\n            _httpClient = httpClient;\n        }\n\n        /// <summary>\n        /// 获取登录地址(GitHub)\n        /// </summary>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetLoginAddressAsync()\n        {\n            return await _authorizeCacheService.GetLoginAddressAsync(async () =>\n            {\n                var result = new ServiceResult<string>();\n\n                var request = new AuthorizeRequest();\n                var address = string.Concat(new string[]\n                {\n                    GitHubConfig.API_Authorize,\n                    \"?client_id=\", request.Client_ID,\n                    \"&scope=\", request.Scope,\n                    \"&state=\", request.State,\n                    \"&redirect_uri=\", request.Redirect_Uri\n                });\n\n                result.IsSuccess(address);\n                return await Task.FromResult(result);\n            });\n        }\n\n        /// <summary>\n        /// 获取AccessToken\n        /// </summary>\n        /// <param name=\"code\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetAccessTokenAsync(string code)\n        {\n            var result = new ServiceResult<string>();\n\n            if (string.IsNullOrEmpty(code))\n            {\n                result.IsFailed(\"code为空\");\n                return result;\n            }\n\n            return await _authorizeCacheService.GetAccessTokenAsync(code, async () =>\n            {\n                var request = new AccessTokenRequest();\n\n                var content = new StringContent($\"code={code}&client_id={request.Client_ID}&redirect_uri={request.Redirect_Uri}&client_secret={request.Client_Secret}\");\n                content.Headers.ContentType = new MediaTypeHeaderValue(\"application/x-www-form-urlencoded\");\n\n                using var client = _httpClient.CreateClient();\n                var httpResponse = await client.PostAsync(GitHubConfig.API_AccessToken, content);\n\n                var response = await httpResponse.Content.ReadAsStringAsync();\n\n                if (response.StartsWith(\"access_token\"))\n                    result.IsSuccess(response.Split(\"=\")[1].Split(\"&\").First());\n                else\n                    result.IsFailed(\"code不正确\");\n\n                return result;\n            });\n        }\n\n        /// <summary>\n        /// 登录成功，生成Token\n        /// </summary>\n        /// <param name=\"access_token\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GenerateTokenAsync(string access_token)\n        {\n            var result = new ServiceResult<string>();\n\n            if (string.IsNullOrEmpty(access_token))\n            {\n                result.IsFailed(\"access_token为空\");\n                return result;\n            }\n\n            return await _authorizeCacheService.GenerateTokenAsync(access_token, async () =>\n            {\n                var url = $\"{GitHubConfig.API_User}?access_token={access_token}\";\n                using var client = _httpClient.CreateClient();\n                client.DefaultRequestHeaders.Add(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.14 Safari/537.36 Edg/83.0.478.13\");\n                var httpResponse = await client.GetAsync(url);\n                if (httpResponse.StatusCode != HttpStatusCode.OK)\n                {\n                    result.IsFailed(\"access_token不正确\");\n                    return result;\n                }\n\n                var content = await httpResponse.Content.ReadAsStringAsync();\n\n                var user = content.FromJson<UserResponse>();\n                if (user.IsNull())\n                {\n                    result.IsFailed(\"未获取到用户数据\");\n                    return result;\n                }\n\n                if (user.Id != GitHubConfig.UserId)\n                {\n                    result.IsFailed(\"当前账号未授权\");\n                    return result;\n                }\n\n                var claims = new[] {\n                    new Claim(ClaimTypes.Name, user.Name),\n                    new Claim(ClaimTypes.Email, user.Email),\n                    new Claim(JwtRegisteredClaimNames.Exp, $\"{new DateTimeOffset(DateTime.Now.AddMinutes(AppSettings.JWT.Expires)).ToUnixTimeSeconds()}\"),\n                    new Claim(JwtRegisteredClaimNames.Nbf, $\"{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}\")\n                };\n\n                var key = new SymmetricSecurityKey(AppSettings.JWT.SecurityKey.SerializeUtf8());\n                var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n                var securityToken = new JwtSecurityToken(\n                    issuer: AppSettings.JWT.Domain,\n                    audience: AppSettings.JWT.Domain,\n                    claims: claims,\n                    expires: DateTime.Now.AddMinutes(AppSettings.JWT.Expires),\n                    signingCredentials: creds);\n\n                var token = new JwtSecurityTokenHandler().WriteToken(securityToken);\n\n                result.IsSuccess(token);\n                return await Task.FromResult(result);\n            });\n        }\n    }\n}\n```\n\n直接return我们的缓存接口，当查询到Redis中存在KEY值的缓存就不会再走我们的具体的实现方法了。\n\n注意注意，千万不要忘了在`.Application`层的模块类中添加依赖缓存模块`MeowvBlogApplicationCachingModule`，不然就会报错报错报错(我就是忘了添加...)\n\n```CSharp\n//MeowvBlogApplicationCachingModule.cs\nusing Meowv.Blog.Domain;\nusing Meowv.Blog.Domain.Configurations;\nusing Microsoft.Extensions.DependencyInjection;\nusing Volo.Abp.Caching;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Application.Caching\n{\n    [DependsOn(\n        typeof(AbpCachingModule),\n        typeof(MeowvBlogDomainModule)\n    )]\n    public class MeowvBlogApplicationCachingModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            context.Services.AddStackExchangeRedisCache(options =>\n            {\n                options.Configuration = AppSettings.Caching.RedisConnectionString;\n            });\n        }\n    }\n}\n```\n\n此时项目的层级目录结构。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200525160645669-1689293018.png)\n\n好的，编译运行项目，现在去调用接口看看效果，为了真实，这里我先将我redis缓存数据全部干掉。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200525152759522-1692025683.png)\n\n访问接口，.../auth/url，成功返回数据，现在再去看看我们的redis。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200525153209228-630323052.png)\n\n成功将KEY为：Authorize:GetLoginAddress 添加进去了，这里直接使用RedisDesktopManager进行查看。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200525154927052-536134994.png)\n\n那么再次调用这个接口，只要没有过期，就会直接返回数据了，调试图如下：\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200525160919046-83009645.png)\n\n可以看到，是可以直接取到缓存数据的，其他接口大家自己试试吧，一样的效果。\n\n是不是很简单，用最少的代码集成Redis进行数据缓存，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n```\n\n```\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Redis",
      "abp vNext",
      "缓存"
    ],
    "createdAt": "2020-05-26 08:51:26"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理",
    "author": "阿星Plus",
    "url": "2020-05-27-blog_11",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章(https://www.cnblogs.com/meowv/p/12956696.html)成功使用了Redis缓存数据，大大提高博客的响应性能。\n\n接下来，将完成一个任务调度中心，关于定时任务有多种处理方式，如果你的需求比较简单，比如就是单纯的过多少时间循环执行某个操作，可以直接使用.net core中内置的实现方式，新建一个类继承`BackgroundService`，实现`ExecuteAsync()`既可。\n\n看一个例子，我们每过一秒输出一句HelloWorld，并写入日志中。\n\n在`.BackgroundJobs`中新建一个Jobs文件夹，添加`HelloWorldJob.cs`，并且继承自`BackgroundService`。\n\n```CSharp\n//HelloWorldJob.cs\nusing log4net;\nusing Microsoft.Extensions.Hosting;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs\n{\n    public class HelloWorldJob : BackgroundService\n    {\n        private readonly ILog _log;\n\n        public HelloWorldJob()\n        {\n            _log = LogManager.GetLogger(typeof(HelloWorldJob));\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                var msg = $\"CurrentTime:{ DateTime.Now}, Hello World!\";\n\n                Console.WriteLine(msg);\n\n                _log.Info(msg);\n\n                await Task.Delay(1000, stoppingToken);\n            }\n        }\n    }\n}\n```\n\n然后在`.HttpApi.Hosting`层模块类中的`ConfigureServices()`注入`context.Services.AddTransient<IHostedService, HelloWorldJob>();`使用，运行一下看看效果。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526095246645-194926676.png)\n\n可以看到已经成功输出了，你可以在`ExecuteAsync()`中做你的事件处理逻辑。这应该是最简单后台定时任务处理了，比较单一。\n\n在abp框架中，官方给我们提供了许多后台工作的集成方式，有兴趣的可以自行研究一下，文档地址：https://docs.abp.io/zh-Hans/abp/latest/Background-Jobs\n\n在本项目中，我将使用 Hangfire 来完成定时任务处理，为什么选择它呢？因为简单，开箱即用。下面进入正题，可以先将 `HelloWorldJob` 停掉。\n\n在`.BackgroundJobs`中添加nuget包：`Volo.Abp.BackgroundJobs.HangFire`、`Hangfire.MySql.Core`、`Hangfire.Dashboard.BasicAuthorization`、`Volo.Abp.AspNetCore`，然后添加项目引用：`.Domain`。\n\n在根目录新建模块类：`MeowvBlogBackgroundJobsModule.cs`，继承`AbpModule`，依赖`AbpBackgroundJobsHangfireModule`。\n\n```CSharp\n//MeowvBlogBackgroundJobsModule.cs\nusing Hangfire;\nusing Hangfire.MySql.Core;\nusing Meowv.Blog.Domain.Configurations;\nusing Meowv.Blog.Domain.Shared;\nusing Volo.Abp;\nusing Volo.Abp.BackgroundJobs.Hangfire;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.BackgroundJobs\n{\n    [DependsOn(typeof(AbpBackgroundJobsHangfireModule))]\n    public class MeowvBlogBackgroundJobsModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            context.Services.AddHangfire(config =>\n            {\n                config.UseStorage(\n                    new MySqlStorage(AppSettings.ConnectionStrings,\n                    new MySqlStorageOptions\n                    {\n                        TablePrefix = MeowvBlogConsts.DbTablePrefix + \"hangfire\"\n                    }));\n            });\n        }\n\n        public override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            var app = context.GetApplicationBuilder();\n\n            app.UseHangfireServer();\n            app.UseHangfireDashboard();\n        }\n    }\n}\n```\n\n在`ConfigureServices()`中添加配置，因为之前选用了MySQL，所以这里引用了`Hangfire.MySql.Core`这个包，相对于的其它数据库可以在nuget上寻找。\n\n在`new MySqlStorage()`中配置连接字符串，`new MySqlStorageOptions()`中配置表前缀，Hangfire会在第一次运行时，自动为我们创建表。\n\n然后在`OnApplicationInitialization()中`进行使用，`app.UseHangfireServer()`必须调用，如果你不需要界面显示可以不用`app.UseHangfireDashboard();`\n\n最后不要忘记，在`.HttpApi.Hosting`层模块类中依赖定时任务模块`MeowvBlogBackgroundJobsModule`。\n\n现在运行一下项目，打开地址：.../hangfire 看看。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526102511075-72937409.png)\n\n数据库默认已经为我们创建了hangfire所需的表。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526102611427-87251446.png)\n\n有一个地方要注意，就是在连接字符串中需要开启用户变量，修改一下`appsettings.json`中的连接字符串，在末尾添加：`Allow User Variables=True`。\n\n同时在`app.UseHangfireDashboard()`中，还支持很多配置项，现在我们这个定时任务是公开的，如果我们不想要外人访问，可以开启BasicAuth。\n\n现在配置文件中配置Hangfire的登录账号和密码。\n\n```json\n...\n\"Hangfire\": {\n    \"Login\": \"meowv\",\n    \"Password\": \"123456\"\n}\n...\n```\n\n```CSharp\n...\n/// <summary>\n/// Hangfire\n/// </summary>\npublic static class Hangfire\n{\n    public static string Login => _config[\"Hangfire:Login\"];\n\n    public static string Password => _config[\"Hangfire:Password\"];\n}\n...\n```\n\n开启方式也很简单，之前已经引用了`Hangfire.Dashboard.BasicAuthorization`这个包，直接看代码。\n\n```CSharp\napp.UseHangfireDashboard(options: new DashboardOptions\n{\n    Authorization = new[]\n    {\n        new BasicAuthAuthorizationFilter(new BasicAuthAuthorizationFilterOptions\n        {\n            RequireSsl = false,\n            SslRedirect = false,\n            LoginCaseSensitive = true,\n            Users = new []\n            {\n                new BasicAuthAuthorizationUser\n                {\n                    Login = AppSettings.Hangfire.Login,\n                    PasswordClear =  AppSettings.Hangfire.Password\n                }\n            }\n        })\n    },\n    DashboardTitle = \"任务调度中心\"\n});\n```\n\n`app.UseHangfireDashboard()`中可以自定义访问路径，我们这里没有传，就是用默认值。自定义界面的标题Title等等。更多参数可以自己看`DashboardOptions`，结合情况来使用，编译运行看看效果。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526103954756-1439446952.png)\n\n现在就需要输入我们配置的账号密码才可以进入Hangfire界面了。\n\n这样我们就集成好了Hangfire，并且还有了一个可视化的界面，接下来我们同样实现一个简单的定时任务看看效果。\n\n在Jobs文件夹添加一个接口：`IBackgroundJob`，让他继承`ITransientDependency`，实现依赖注入，同时定义一个方法`ExecuteAsync()`。\n\n```CSharp\n//IBackgroundJob.cs\nusing System.Threading.Tasks;\nusing Volo.Abp.DependencyInjection;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs\n{\n    public interface IBackgroundJob : ITransientDependency\n    {\n        /// <summary>\n        /// 执行任务\n        /// </summary>\n        /// <returns></returns>\n        Task ExecuteAsync();\n    }\n}\n```\n\n在Jobs文件夹新建文件夹Hangfire，添加`HangfireTestJob.cs`，继承`IBackgroundJob`实现`ExecuteAsync()`方法。\n\n```CSharp\n//HangfireTestJob.cs\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs.Hangfire\n{\n    public class HangfireTestJob : IBackgroundJob\n    {\n        public async Task ExecuteAsync()\n        {\n            Console.WriteLine(\"定时任务测试\");\n\n            await Task.CompletedTask;\n        }\n    }\n}\n```\n\n这样就完成了定时任务的逻辑，我们怎么来调用呢？新建一个扩展方法`MeowvBlogBackgroundJobsExtensions.cs`。\n\n```CSharp\n//MeowvBlogBackgroundJobsExtensions.cs\nusing Hangfire;\nusing Meowv.Blog.BackgroundJobs.Jobs.Hangfire;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\n\nnamespace Meowv.Blog.BackgroundJobs\n{\n    public static class MeowvBlogBackgroundJobsExtensions\n    {\n        public static void UseHangfireTest(this IServiceProvider service)\n        {\n            var job = service.GetService<HangfireTestJob>();\n\n            RecurringJob.AddOrUpdate(\"定时任务测试\", () => job.ExecuteAsync(), CronType.Minute());\n        }\n    }\n}\n```\n\n这里使用`IServiceProvider`解析服务，获取到我们的实列，所以我们可以在模块类中的`OnApplicationInitialization(...)`中直接调用此扩展方法。\n\n`RecurringJob.AddOrUpdate()`是定期作业按指定的计划触发任务，同时还有`Enqueue`、`Schedule`、`ContinueJobWith`等等，可以看一下Hangfire官方文档：https://docs.hangfire.io/en/latest/\n\nCronType是自定义的一个静态类，他帮我们自动生成了Cron表达式，这里表示一分钟执行一次，关于不懂Cron的同学，可以去自学一下，也许看看下面代码就懂了，也有许多Cron表达式在线生成的工具。\n\n```text\n# Example of job definition:\n# .---------------- minute (0 - 59)\n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...\n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat\n# |  |  |  |  |\n*/30 * * * * /bin/python /qix/spider/spider.py #每30分钟执行一次\n```\n\n直接在根目录添加`MeowvBlogCronType.cs`。\n\n```CSharp\n//MeowvBlogCronType.cs\nusing Hangfire;\nusing System;\n\nnamespace Meowv.Blog.BackgroundJobs\n{\n    /// <summary>\n    /// Cron类型\n    /// </summary>\n    public static class CronType\n    {\n        /// <summary>\n        /// 周期性为分钟的任务\n        /// </summary>\n        /// <param name=\"interval\">执行周期的间隔，默认为每分钟一次</param>\n        /// <returns></returns>\n        public static string Minute(int interval = 1)\n        {\n            return \"1 0/\" + interval.ToString() + \" * * * ? \";\n        }\n\n        /// <summary>\n        /// 周期性为小时的任务\n        /// </summary>\n        /// <param name=\"minute\">第几分钟开始，默认为第一分钟</param>\n        /// <param name=\"interval\">执行周期的间隔，默认为每小时一次</param>\n        /// <returns></returns>\n        public static string Hour(int minute = 1, int interval = 1)\n        {\n            return \"1 \" + minute + \" 0/\" + interval.ToString() + \" * * ? \";\n        }\n\n        /// <summary>\n        /// 周期性为天的任务\n        /// </summary>\n        /// <param name=\"hour\">第几小时开始，默认从1点开始</param>\n        /// <param name=\"minute\">第几分钟开始，默认从第1分钟开始</param>\n        /// <param name=\"interval\">执行周期的间隔，默认为每天一次</param>\n        /// <returns></returns>\n        public static string Day(int hour = 1, int minute = 1, int interval = 1)\n        {\n            return \"1 \" + minute.ToString() + \" \" + hour.ToString() + \" 1/\" + interval.ToString() + \" * ? \";\n        }\n\n        /// <summary>\n        /// 周期性为周的任务\n        /// </summary>\n        /// <param name=\"dayOfWeek\">星期几开始，默认从星期一点开始</param>\n        /// <param name=\"hour\">第几小时开始，默认从1点开始</param>\n        /// <param name=\"minute\">第几分钟开始，默认从第1分钟开始</param>\n        /// <returns></returns>\n        public static string Week(DayOfWeek dayOfWeek = DayOfWeek.Monday, int hour = 1, int minute = 1)\n        {\n            return Cron.Weekly(dayOfWeek, hour, minute);\n        }\n\n        /// <summary>\n        /// 周期性为月的任务\n        /// </summary>\n        /// <param name=\"day\">几号开始，默认从一号开始</param>\n        /// <param name=\"hour\">第几小时开始，默认从1点开始</param>\n        /// <param name=\"minute\">第几分钟开始，默认从第1分钟开始</param>\n        /// <returns></returns>\n        public static string Month(int day = 1, int hour = 1, int minute = 1)\n        {\n            return Cron.Monthly(day, hour, minute);\n        }\n\n        /// <summary>\n        /// 周期性为年的任务\n        /// </summary>\n        /// <param name=\"month\">几月开始，默认从一月开始</param>\n        /// <param name=\"day\">几号开始，默认从一号开始</param>\n        /// <param name=\"hour\">第几小时开始，默认从1点开始</param>\n        /// <param name=\"minute\">第几分钟开始，默认从第1分钟开始</param>\n        /// <returns></returns>\n        public static string Year(int month = 1, int day = 1, int hour = 1, int minute = 1)\n        {\n            return Cron.Yearly(month, day, hour, minute);\n        }\n    }\n}\n```\n\n接着就可以调用定时任务了。\n\n```CSharp\n//MeowvBlogBackgroundJobsModule.cs\n...\npublic override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n    var app = context.GetApplicationBuilder();\n    ...\n    var service = context.ServiceProvider;\n\n    service.UseHangfireTest();\n}\n...\n```\n\n通过`context.ServiceProvider`可以获取到`IServiceProvider`，然后直接调用扩展方法，是不是超级简单，现在编译运行项目看效果。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526111845847-929052251.png)\n\n可以看到已经有一个周期性的任务躺在那，每过一分钟都将执行一次，执行完成后如下图，可以很清楚的知道我们的任务当前状态。\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526112159577-191725383.png)\n\n关于任务是否真的运行成功，我们可以从输出看出。\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526113528778-1795082241.png)\n\n完美，本篇完成了Hangfire的集成，并实现了一个定时任务计划，有没有发现很简单，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "定时任务",
      "Hangfire"
    ],
    "createdAt": "2020-05-27 08:54:27"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射",
    "author": "阿星Plus",
    "url": "2020-05-28-blog_12",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇文章(https://www.cnblogs.com/meowv/p/12961014.html)集成了定时任务处理框架Hangfire，完成了一个简单的定时任务处理解决方案。\n\n本篇紧接着来玩一下AutoMapper，AutoMapper可以很方便的搞定我们对象到对象之间的映射关系处理，同时abp也帮我们是现实了`IObjectMapper`接口，先根据官方文档：https://docs.abp.io/zh-Hans/abp/latest/Object-To-Object-Mapping ，将AutoMapper添加依赖到项目中。\n\n在`.Application`层模块类中添加`AbpAutoMapperModule`模块依赖。\n\n```CSharp\n//MeowvBlogApplicationModule.cs\nusing Meowv.Blog.Application.Caching;\nusing Volo.Abp.AutoMapper;\nusing Volo.Abp.Identity;\nusing Volo.Abp.Modularity;\n\nnamespace Meowv.Blog.Application\n{\n    [DependsOn(\n        typeof(AbpIdentityApplicationModule),\n        typeof(AbpAutoMapperModule),\n        typeof(MeowvBlogApplicationCachingModule)\n    )]\n    public class MeowvBlogApplicationModule : AbpModule\n    {\n        public override void ConfigureServices(ServiceConfigurationContext context)\n        {\n            ...\n        }\n    }\n}\n```\n\n在本项目中，主要处理的就是实体和DTO之前的映射关系，以之前写的`BlogService.cs`中的增删改查为例，将`Post.cs`和`PostDto.cs`互相映射。\n\n先看`GetPostAsync(int id)`这个方法，之前的做法是手动创建对象，然后为其一个一个的赋值，可以想象当我们的字段超级多的时候，都得写一遍。现在有了AutoMapper，一句代码就可以搞定。\n\n```CSharp\npublic async Task<ServiceResult<PostDto>> GetPostAsync(int id)\n{\n    var result = new ServiceResult<PostDto>();\n\n    var post = await _postRepository.GetAsync(id);\n    if (post == null)\n    {\n        result.IsFailed(\"文章不存在\");\n        return result;\n    }\n\n    //var dto = new PostDto\n    //{\n    //    Title = post.Title,\n    //    Author = post.Author,\n    //    Url = post.Url,\n    //    Html = post.Html,\n    //    Markdown = post.Markdown,\n    //    CategoryId = post.CategoryId,\n    //    CreationTime = post.CreationTime\n    //};\n\n    var dto = ObjectMapper.Map<Post, PostDto>(post);\n\n    result.IsSuccess(dto);\n    return result;\n}\n```\n\n`ObjectMapper`在`ApplicationService`中已经被注入，我们的继承了`ServiceBase`，可以直接使用。\n\n到这里还没完，其中最重要的一步就是定义类与类之间的映射关系，AutoMapper提供了多种定义类之间映射的方法，有关详细信息请参阅AutoMapper的文档：https://docs.automapper.org/\n\n其中定义一种映射的方法是创建一个Profile 类，在`.Application`层添加`MeowvBlogAutoMapperProfile.cs`，直接继承`Profile`在构造函数中定义即可。\n\n```CSharp\n//MeowvBlogAutoMapperProfile.cs\nusing AutoMapper;\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.Domain.Blog;\n\nnamespace Meowv.Blog.Application\n{\n    public class MeowvBlogAutoMapperProfile : Profile\n    {\n        public MeowvBlogAutoMapperProfile()\n        {\n            CreateMap<Post, PostDto>();\n\n            CreateMap<PostDto, Post>().ForMember(x => x.Id, opt => opt.Ignore());\n        }\n    }\n}\n```\n\n定义两个规则，第一个：从`Post`映射到`PostDto`，因为`PostDto`所有属性在`Post`中都是存在的，所以直接`CreateMap<>`即可；第二个：从`PostDto`映射到`Post`，因为`Post`中存在Id属性，而在`PostDto`中是没有的，所以可以使用`ForMember(...)`来忽略掉Id属性。\n\n定义好映射规则后，在模块类中添加使用。\n\n```CSharp\n//MeowvBlogApplicationModule.cs\n...\n\tpublic override void ConfigureServices(ServiceConfigurationContext context)\n\t{\n\t    Configure<AbpAutoMapperOptions>(options =>\n\t    {\n\t        options.AddMaps<MeowvBlogApplicationModule>(validate: true);\n\t        options.AddProfile<MeowvBlogAutoMapperProfile>(validate: true);\n\t    });\n\t}\n...\n```\n\n使用同样的方式修改一下`InsertPostAsync(PostDto dto)`方法的代码。\n\n```CSharp\npublic async Task<ServiceResult<string>> InsertPostAsync(PostDto dto)\n{\n    var result = new ServiceResult<string>();\n\n    //var entity = new Post\n    //{\n    //    Title = dto.Title,\n    //    Author = dto.Author,\n    //    Url = dto.Url,\n    //    Html = dto.Html,\n    //    Markdown = dto.Markdown,\n    //    CategoryId = dto.CategoryId,\n    //    CreationTime = dto.CreationTime\n    //};\n\n    var entity = ObjectMapper.Map<PostDto, Post>(dto);\n\n    var post = await _postRepository.InsertAsync(entity);\n    if (post == null)\n    {\n        result.IsFailed(\"添加失败\");\n        return result;\n    }\n\n    result.IsSuccess(\"添加成功\");\n    return result;\n}\n```\n\n解放了双手，代码也变少了，真香，去测试一下用了对象映射后的接口是否好使。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200526170023482-1643288182.png)\n\n可以看到，结果也是可以出来的，后续都将按照上面的方法大量用到对象映射。\n\n顺便介绍`.HttpApi.Hosting`层几个配置属性。\n\n路由规则配置，默认Swagger中的路由是大写的，如果我想转成小写可以使用以下配置代码，都写在模块类`MeowvBlogHttpApiHostingModule.cs`中。\n\n```CSharp\npublic override void ConfigureServices(ServiceConfigurationContext context)\n{\n...\n\tcontext.Services.AddRouting(options =>\n\t{\n\t    // 设置URL为小写\n\t    options.LowercaseUrls = true;\n\t    // 在生成的URL后面添加斜杠\n\t    options.AppendTrailingSlash = true;\n\t});\n...\n}\n```\n\n使用HSTS的中间件，该中间件添加了严格传输安全头。\n\n```CSharp\npublic override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n    ...\n    app.UseHsts();\n    ...\n}\n```\n\n直接使用默认的跨域配置。\n\n```CSharp\npublic override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n    ...\n    app.UseCors();\n    ...\n}\n```\n\nHTTP请求转HTTPS。\n\n```CSharp\npublic override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n    ...\n    app.UseHttpsRedirection();\n    ...\n}\n```\n\n转发将标头代理到当前请求，配合 Nginx 使用，获取用户真实IP。\n\n```CSharp\npublic override void OnApplicationInitialization(ApplicationInitializationContext context)\n{\n    ...\n    pp.UseForwardedHeaders(new ForwardedHeadersOptions\n    {\n        ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto\n    });\n    ...\n}\n```\n\n本篇介绍了如何使用AutoMapper，搞定对象到对象间的映射，篇幅简短，内容比较简单，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "AutoMapper"
    ],
    "createdAt": "2020-05-28 08:49:28"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）",
    "author": "阿星Plus",
    "url": "2020-05-29-blog_13",
    "markdown": "\n\n## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇(https://www.cnblogs.com/meowv/p/12966092.html)文章使用AutoMapper来处理对象与对象之间的映射关系，本篇主要围绕定时任务和数据抓取相关的知识点并结合实际应用，在定时任务中循环处理爬虫任务抓取数据。\n\n开始之前可以删掉之前测试用的几个HelloWorld，没有什么实际意义，直接干掉吧。抓取数据我主要用到了，`HtmlAgilityPack`和`PuppeteerSharp`，一般情况下`HtmlAgilityPack`就可以完成大部分的数据抓取需求了，当在抓取动态网页的时候可以用到`PuppeteerSharp`，同时`PuppeteerSharp`还支持将图片保存为图片和PDF等牛逼的功能。\n\n关于这两个库就不多介绍了，不了解的请自行去学习。\n\n先在`.BackgroundJobs`层安装两大神器：`Install-Package HtmlAgilityPack`、`Install-Package PuppeteerSharp`。我在使用Package Manager安装包的时候一般都不喜欢指定版本号，因为这样默认是给我安装最新的版本。\n\n之前无意中发现爱思助手的网页版有很多手机壁纸(https://www.i4.cn/wper_4_0_1_1.html)，于是我就动了小心思，把所有手机壁纸全部抓取过来自嗨，可以看看我个人博客中的成品吧：https://meowv.com/wallpaper 😝😝😝\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200527140750600-1681789464.jpg)\n\n最开始我是用Python实现的，现在我们在.NET中抓它。\n\n我数了一下，一共有20个分类，直接在`.Domain.Shared`层添加一个壁纸分类的枚举`WallpaperEnum.cs`。\n\n```CSharp\n//WallpaperEnum.cs\nusing System.ComponentModel;\n\nnamespace Meowv.Blog.Domain.Shared.Enum\n{\n    public enum WallpaperEnum\n    {\n        [Description(\"美女\")]\n        Beauty = 1,\n\n        [Description(\"型男\")]\n        Sportsman = 2,\n\n        [Description(\"萌娃\")]\n        CuteBaby = 3,\n\n        [Description(\"情感\")]\n        Emotion = 4,\n\n        [Description(\"风景\")]\n        Landscape = 5,\n\n        [Description(\"动物\")]\n        Animal = 6,\n\n        [Description(\"植物\")]\n        Plant = 7,\n\n        [Description(\"美食\")]\n        Food = 8,\n\n        [Description(\"影视\")]\n        Movie = 9,\n\n        [Description(\"动漫\")]\n        Anime = 10,\n\n        [Description(\"手绘\")]\n        HandPainted = 11,\n\n        [Description(\"文字\")]\n        Text = 12,\n\n        [Description(\"创意\")]\n        Creative = 13,\n\n        [Description(\"名车\")]\n        Car = 14,\n\n        [Description(\"体育\")]\n        PhysicalEducation = 15,\n\n        [Description(\"军事\")]\n        Military = 16,\n\n        [Description(\"节日\")]\n        Festival = 17,\n\n        [Description(\"游戏\")]\n        Game = 18,\n\n        [Description(\"苹果\")]\n        Apple = 19,\n\n        [Description(\"其它\")]\n        Other = 20,\n    }\n}\n```\n\n查看原网页可以很清晰的看到，每一个分类对应了一个不同的URL，于是手动创建一个抓取的列表，列表内容包括URL和分类，然后我又想用多线程来访问URL，返回结果。新建一个通用的待抓项的类，起名为:`WallpaperJobItem.cs`，为了规范和后续的壁纸查询接口，我们放在`.Application.Contracts`层中。\n\n```CSharp\n//WallpaperJobItem.cs\nusing Meowv.Blog.Domain.Shared.Enum;\n\nnamespace Meowv.Blog.Application.Contracts.Wallpaper\n{\n    public class WallpaperJobItem<T>\n    {\n        /// <summary>\n        /// <see cref=\"Result\"/>\n        /// </summary>\n        public T Result { get; set; }\n\n        /// <summary>\n        /// 类型\n        /// </summary>\n        public WallpaperEnum Type { get; set; }\n    }\n}\n```\n\n`WallpaperJobItem<T>`接受一个参数T，Result的类型由T决定，在`.BackgroundJobs`层Jobs文件夹中新建一个任务，起名叫做：`WallpaperJob.cs`吧。老样子，继承`IBackgroundJob`。\n\n```CSharp\n//WallpaperJob.cs\nusing Meowv.Blog.Application.Contracts.Wallpaper;\nusing Meowv.Blog.Domain.Shared.Enum;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs.Wallpaper\n{\n    public class WallpaperJob : IBackgroundJob\n    {\n        public async Task ExecuteAsync()\n        {\n            var wallpaperUrls = new List<WallpaperJobItem<string>>\n            {\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_1_1.html\", Type = WallpaperEnum.Beauty },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_58_1.html\", Type = WallpaperEnum.Sportsman },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_66_1.html\", Type = WallpaperEnum.CuteBaby },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_4_1.html\", Type = WallpaperEnum.Emotion },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_3_1.html\", Type = WallpaperEnum.Landscape },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_9_1.html\", Type = WallpaperEnum.Animal },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_13_1.html\", Type = WallpaperEnum.Plant },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_64_1.html\", Type = WallpaperEnum.Food },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_11_1.html\", Type = WallpaperEnum.Movie },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_5_1.html\", Type = WallpaperEnum.Anime },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_34_1.html\", Type = WallpaperEnum.HandPainted },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_65_1.html\", Type = WallpaperEnum.Text },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_2_1.html\",  Type = WallpaperEnum.Creative },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_10_1.html\", Type = WallpaperEnum.Car },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_14_1.html\", Type = WallpaperEnum.PhysicalEducation },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_63_1.html\", Type = WallpaperEnum.Military },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_17_1.html\", Type = WallpaperEnum.Festival },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_15_1.html\", Type = WallpaperEnum.Game },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_12_1.html\", Type = WallpaperEnum.Apple },\n                new WallpaperJobItem<string> { Result = \"https://www.i4.cn/wper_4_19_7_1.html\", Type = WallpaperEnum.Other }\n            };\n        }\n    }\n}\n```\n\n先构建一个要抓取的列表 wallpaperUrls，这里准备用 `HtmlAgilityPack`，默认只抓取第一页最新的数据。\n\n```CSharp\npublic async Task RunAsync()\n{\n    ...\n    \n    var web = new HtmlWeb();\n    var list_task = new List<Task<WallpaperJobItem<HtmlDocument>>>();\n\n    wallpaperUrls.ForEach(item =>\n    {\n        var task = Task.Run(async () =>\n        {\n            var htmlDocument = await web.LoadFromWebAsync(item.Result);\n            return new WallpaperJobItem<HtmlDocument>\n            {\n                Result = htmlDocument,\n                Type = item.Type\n            };\n        });\n        list_task.Add(task);\n    });\n    Task.WaitAll(list_task.ToArray());\n}\n```\n\n上面这段代码，先new了一个`HtmlWeb`对象，我们主要用这个对象去加载我们的URL。\n\n`web.LoadFromWebAsync(...)`，它会返回一个`HtmlDocument`对象，这样就和上面的list_task对应起来，从而也应证了前面添加的`WallpaperJobItem`是通用的一个待抓项的类。\n\n循环处理 wallpaperUrls，等待所有请求完成。这样就拿到了20个`HtmlDocument`，和它的分类，接下来就可以去处理list_task就行了。\n\n在开始处理之前，要想好抓到的图片数据存放在哪里？我这里还是选择存在数据库中，因为有了之前的自定义仓储之增删改查的经验，可以很快的处理这件事情。\n\n添加实体类、自定义仓储、DbSet、Code-First等一些列操作，就不一一介绍了，我相信看过之前文章的人都能完成这一步。\n\nWallpaper实体类包含主键Guid，标题Title，图片地址Url，类型Type，和一个创建时间CreateTime。\n\n自定义仓储包含一个批量插入的方法：`BulkInsertAsync(...)`。\n\n贴一下完成后的图片，就不上代码了，如果需要可以去GitHub获取。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200527150720962-813684172.png)\n\n回到`WallpaperJob`，因为我们要抓取的是图片，所以获取到HTML中的img标签就可以了。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200527151349223-1289224079.png)\n\n查看源代码发现图片是一个列表呈现的，并且被包裹在`//article[@id='wper']/div[@class='jbox']/div[@class='kbox']`下面，学过XPath语法的就很容易了，关于XPath语法这里也不做介绍了，对于不会的这里有一篇快速入门的文章：https://www.cnblogs.com/meowv/p/11310538.html 。\n\n利用XPath Helper工具我们在浏览器上模拟一下选择的节点是否正确。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200527151912268-1871222782.png)\n\n使用`//article[@id='wper']/div[@class='jbox']/div[@class='kbox']/div/a/img`可以成功将图片高亮，说明我们的语法是正确的。\n\n```CSharp\npublic async Task RunAsync()\n{\n    ...\n\n    var wallpapers = new List<Wallpaper>();\n\n    foreach (var list in list_task)\n    {\n        var item = await list;\n\n        var imgs = item.Result.DocumentNode.SelectNodes(\"//article[@id='wper']/div[@class='jbox']/div[@class='kbox']/div/a/img[1]\").ToList();\n        imgs.ForEach(x =>\n        {\n            wallpapers.Add(new Wallpaper\n            {\n                Url = x.GetAttributeValue(\"data-big\", \"\"),\n                Title = x.GetAttributeValue(\"title\", \"\"),\n                Type = (int)item.Type,\n                CreateTime = x.Attributes[\"data-big\"].Value.Split(\"/\").Last().Split(\"_\").First().TryToDateTime()\n            });\n        });\n    }\n    ...\n}\n```\n\n在 foreach 循环中先拿到当前循环的Item对象，即`WallpaperJobItem<HtmlDocument>`。\n\n通过`.DocumentNode.SelectNodes()`语法获取到图片列表，因为在a标签下面有两个img标签，取第一个即可。\n\n`GetAttributeValue()`是`HtmlAgilityPack`的扩展方法，用于直接获取属性值。\n\n在看图片的时候，发现图片地址的规则是根据时间戳生成的，于是用`TryToDateTime()`扩展方法将其处理转换成时间格式。\n\n这样我们就将所有图片按分类存进了列表当中，接下来调用批量插入方法。\n\n在构造函数中注入自定义仓储`IWallpaperRepository`。\n\n```CSharp\n...\n        private readonly IWallpaperRepository _wallpaperRepository;\n\n        public WallpaperJob(IWallpaperRepository wallpaperRepository)\n        {\n            _wallpaperRepository = wallpaperRepository;\n        }\n...\n```\n\n```CSharp\n...\n\tvar urls = (await _wallpaperRepository.GetListAsync()).Select(x => x.Url);\n\twallpapers = wallpapers.Where(x => !urls.Contains(x.Url)).ToList();\n\tif (wallpapers.Any())\n\t{\n\t    await _wallpaperRepository.BulkInsertAsync(wallpapers);\n\t}\n```\n\n因为抓取的图片可能存在重复的情况，我们需要做一个去重处理，先查询到数据库中的所有的URL列表，然后在判断抓取到的url是否存在，最后调用`BulkInsertAsync(...)`批量插入方法。\n\n这样就完成了数据抓取的全部逻辑，在保存数据到数据库之后我们可以进一步操作，比如：写日志、发送邮件通知等等，这里大家自由发挥吧。\n\n写一个扩展方法每隔3小时执行一次。\n\n```CSharp\n...\n        public static void UseWallpaperJob(this IServiceProvider service)\n        {\n            var job = service.GetService<WallpaperJob>();\n            RecurringJob.AddOrUpdate(\"壁纸数据抓取\", () => job.ExecuteAsync(), CronType.Hour(1, 3));\n        }\n...\n```\n\n最后在模块内中调用。\n\n```CSharp\n...\n        public override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            ...\n            service.UseWallpaperJob();\n        }\n```\n\n编译运行，打开Hangfire界面手动执行看看效果。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200527154809552-1453497072.png)\n\n完美，数据库已经存入了不少数据了，还是要提醒一下：爬虫有风险，抓数需谨慎。\n\nHangfire定时处理爬虫任务，用`HtmlAgilityPack`抓取数据后存入数据库，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "xpath",
      "abp vNext",
      "定时任务"
    ],
    "createdAt": "2020-05-29 08:49:29"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）",
    "author": "阿星Plus",
    "url": "2020-05-30-blog_14",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇使用`HtmlAgilityPack`抓取壁纸数据成功将图片存入数据库，本篇继续来完成一个全网各大平台的热点新闻数据的抓取。\n\n同样的，可以先预览一下我个人博客中的成品：https://meowv.com/hot 😝😝😝，和抓取壁纸的套路一样，大同小异。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528112520264-1501746108.png)\n\n本次要抓取的源有18个，分别是博客园、V2EX、SegmentFault、掘金、微信热门、豆瓣精选、IT之家、36氪、百度贴吧、百度热搜、微博热搜、知乎热榜、知乎日报、网易新闻、GitHub、抖音热点、抖音视频、抖音正能量。\n\n还是将数据存入数据库，按部就班先将实体类和自定义仓储创建好，实体取名`HotNews`。贴一下代码：\n\n```CSharp\n//HotNews.cs\nusing System;\nusing Volo.Abp.Domain.Entities;\n\nnamespace Meowv.Blog.Domain.HotNews\n{\n    public class HotNews : Entity<Guid>\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string Url { get; set; }\n\n        /// <summary>\n        /// SourceId\n        /// </summary>\n        public int SourceId { get; set; }\n\n        /// <summary>\n        /// 创建时间\n        /// </summary>\n        public DateTime CreateTime { get; set; }\n    }\n}\n```\n\n剩下的大家自己完成，最终数据库生成一张空的数据表，meowv_hotnews 。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528101807134-35560335.png)\n\n然后还是将我们各大平台放到一个枚举类`HotNewsEnum.cs`中。\n\n```CSharp\n//HotNewsEnum.cs\nusing System.ComponentModel;\n\nnamespace Meowv.Blog.Domain.Shared.Enum\n{\n    public enum HotNewsEnum\n    {\n        [Description(\"博客园\")]\n        cnblogs = 1,\n\n        [Description(\"V2EX\")]\n        v2ex = 2,\n\n        [Description(\"SegmentFault\")]\n        segmentfault = 3,\n\n        [Description(\"掘金\")]\n        juejin = 4,\n\n        [Description(\"微信热门\")]\n        weixin = 5,\n\n        [Description(\"豆瓣精选\")]\n        douban = 6,\n\n        [Description(\"IT之家\")]\n        ithome = 7,\n\n        [Description(\"36氪\")]\n        kr36 = 8,\n\n        [Description(\"百度贴吧\")]\n        tieba = 9,\n\n        [Description(\"百度热搜\")]\n        baidu = 10,\n\n        [Description(\"微博热搜\")]\n        weibo = 11,\n\n        [Description(\"知乎热榜\")]\n        zhihu = 12,\n\n        [Description(\"知乎日报\")]\n        zhihudaily = 13,\n\n        [Description(\"网易新闻\")]\n        news163 = 14,\n\n        [Description(\"GitHub\")]\n        github = 15,\n\n        [Description(\"抖音热点\")]\n        douyin_hot = 16,\n\n        [Description(\"抖音视频\")]\n        douyin_video = 17,\n\n        [Description(\"抖音正能量\")]\n        douyin_positive = 18\n    }\n}\n```\n\n和上一篇抓取壁纸一样，做一些准备工作。\n\n在`.Application.Contracts`层添加`HotNewsJobItem<T>`，在`.BackgroundJobs`层添加`HotNewsJob`用来处理爬虫逻辑，用构造函数方式注入仓储`IHotNewsRepository`。\n\n```CSharp\n//HotNewsJobItem.cs\nusing Meowv.Blog.Domain.Shared.Enum;\n\nnamespace Meowv.Blog.Application.Contracts.HotNews\n{\n    public class HotNewsJobItem<T>\n    {\n        /// <summary>\n        /// <see cref=\"Result\"/>\n        /// </summary>\n        public T Result { get; set; }\n\n        /// <summary>\n        /// 来源\n        /// </summary>\n        public HotNewsEnum Source { get; set; }\n    }\n}\n```\n\n```CSharp\n//HotNewsJob.CS\nusing Meowv.Blog.Domain.HotNews.Repositories;\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs.HotNews\n{\n    public class HotNewsJob : IBackgroundJob\n    {\n        private readonly IHttpClientFactory _httpClient;\n        private readonly IHotNewsRepository _hotNewsRepository;\n\n        public HotNewsJob(IHttpClientFactory httpClient,\n                          IHotNewsRepository hotNewsRepository)\n        {\n            _httpClient = httpClient;\n            _hotNewsRepository = hotNewsRepository;\n        }\n\n        public async Task ExecuteAsync()\n        {\n            throw new NotImplementedException();\n        }\n    }\n}\n```\n\n接下来明确数据源地址，因为以上数据源有的返回是HTML，有的直接返回JSON数据。为了方便调用，我这里还注入了`IHttpClientFactory`。\n\n整理好的待抓取数据源列表是这样的。\n\n```CSharp\n...\nvar hotnewsUrls = new List<HotNewsJobItem<string>>\n{\n    new HotNewsJobItem<string> { Result = \"https://www.cnblogs.com\", Source = HotNewsEnum.cnblogs },\n    new HotNewsJobItem<string> { Result = \"https://www.v2ex.com/?tab=hot\", Source = HotNewsEnum.v2ex },\n    new HotNewsJobItem<string> { Result = \"https://segmentfault.com/hottest\", Source = HotNewsEnum.segmentfault },\n    new HotNewsJobItem<string> { Result = \"https://web-api.juejin.im/query\", Source = HotNewsEnum.juejin },\n    new HotNewsJobItem<string> { Result = \"https://weixin.sogou.com\", Source = HotNewsEnum.weixin },\n    new HotNewsJobItem<string> { Result = \"https://www.douban.com/group/explore\", Source = HotNewsEnum.douban },\n    new HotNewsJobItem<string> { Result = \"https://www.ithome.com\", Source = HotNewsEnum.ithome },\n    new HotNewsJobItem<string> { Result = \"https://36kr.com/newsflashes\", Source = HotNewsEnum.kr36 },\n    new HotNewsJobItem<string> { Result = \"http://tieba.baidu.com/hottopic/browse/topicList\", Source = HotNewsEnum.tieba },\n    new HotNewsJobItem<string> { Result = \"http://top.baidu.com/buzz?b=341\", Source = HotNewsEnum.baidu },\n    new HotNewsJobItem<string> { Result = \"https://s.weibo.com/top/summary/summary\", Source = HotNewsEnum.weibo },\n    new HotNewsJobItem<string> { Result = \"https://www.zhihu.com/api/v3/feed/topstory/hot-lists/total?limit=50&desktop=true\", Source = HotNewsEnum.zhihu },\n    new HotNewsJobItem<string> { Result = \"https://daily.zhihu.com\", Source = HotNewsEnum.zhihudaily },\n    new HotNewsJobItem<string> { Result = \"http://news.163.com/special/0001386F/rank_whole.html\", Source = HotNewsEnum.news163 },\n    new HotNewsJobItem<string> { Result = \"https://github.com/trending\", Source = HotNewsEnum.github },\n    new HotNewsJobItem<string> { Result = \"https://www.iesdouyin.com/web/api/v2/hotsearch/billboard/word\", Source = HotNewsEnum.douyin_hot },\n    new HotNewsJobItem<string> { Result = \"https://www.iesdouyin.com/web/api/v2/hotsearch/billboard/aweme\", Source = HotNewsEnum.douyin_video },\n    new HotNewsJobItem<string> { Result = \"https://www.iesdouyin.com/web/api/v2/hotsearch/billboard/aweme/?type=positive\", Source = HotNewsEnum.douyin_positive },\n};\n...\n```\n\n其中有几个比较特殊的，掘金、百度热搜、网易新闻。\n\n掘金需要发送Post请求，返回的是JSON数据，并且需要指定特有的请求头和请求数据，所以使用`IHttpClientFactory`创建了`HttpClient`对象。\n\n百度热搜、网易新闻两个老大哥玩套路，网页编码是GB2312的，所以要专门为其指定编码方式，不然取到的数据都是乱码。\n\n```CSharp\n...\nvar web = new HtmlWeb();\nvar list_task = new List<Task<HotNewsJobItem<object>>>();\n\nhotnewsUrls.ForEach(item =>\n{\n    var task = Task.Run(async () =>\n    {\n        var obj = new object();\n\n        if (item.Source == HotNewsEnum.juejin)\n        {\n            using var client = _httpClient.CreateClient();\n            client.DefaultRequestHeaders.Add(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.14 Safari/537.36 Edg/83.0.478.13\");\n            client.DefaultRequestHeaders.Add(\"X-Agent\", \"Juejin/Web\");\n            var data = \"{\\\"extensions\\\":{\\\"query\\\":{ \\\"id\\\":\\\"21207e9ddb1de777adeaca7a2fb38030\\\"}},\\\"operationName\\\":\\\"\\\",\\\"query\\\":\\\"\\\",\\\"variables\\\":{ \\\"first\\\":20,\\\"after\\\":\\\"\\\",\\\"order\\\":\\\"THREE_DAYS_HOTTEST\\\"}}\";\n            var buffer = data.SerializeUtf8();\n            var byteContent = new ByteArrayContent(buffer);\n            byteContent.Headers.ContentType = new MediaTypeHeaderValue(\"application/json\");\n\n            var httpResponse = await client.PostAsync(item.Result, byteContent);\n            obj = await httpResponse.Content.ReadAsStringAsync();\n        }\n        else\n        {\n            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);\n            obj = await web.LoadFromWebAsync(item.Result, (item.Source == HotNewsEnum.baidu || item.Source == HotNewsEnum.news163) ? Encoding.GetEncoding(\"GB2312\") : Encoding.UTF8);\n        }\n\n        return new HotNewsJobItem<object>\n        {\n            Result = obj,\n            Source = item.Source\n        };\n    });\n    list_task.Add(task);\n});\nTask.WaitAll(list_task.ToArray());\n```\n\n循环 hotnewsUrls ，可以看到`HotNewsJobItem`我们返回的是object类型，因为有JSON又有HtmlDocument对象。所以这里为了能够统一接收，就是用了object。\n\n针对掘金做了单独处理，使用`HttpClient`发送Post请求，返回JSON字符串数据。\n\n针对百度热搜和网易新闻，使用`Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);`注册编码提供程序，然后在`web.LoadFromWebAsync(...)`加载网页数据的时候指定网页编码，我使用了一个三元表达式来处理。\n\n完成上面这一步，就可以循环 list_task，使用XPath语法，或者解析JSON数据，去拿到数据了。\n\n```CSharp\n...\nvar hotNews = new List<HotNews>();\nforeach (var list in list_task)\n{\n    var item = await list;\n    var sourceId = (int)item.Source;\n\n    ...\n\n    if (hotNews.Any())\n    {\n        await _hotNewsRepository.DeleteAsync(x => true);\n        await _hotNewsRepository.BulkInsertAsync(hotNews);\n    }\n}\n```\n\n这个爬虫同样很简单，只要拿到标题和链接即可，所以主要目标是寻找到页面上的a标签列表。这个我觉得也没必要一个个去分析了，直接上代码。\n\n```CSharp\n// 博客园\n if (item.Source == HotNewsEnum.cnblogs)\n {\n     var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='post_item_body']/h3/a\").ToList();\n     nodes.ForEach(x =>\n     {\n         hotNews.Add(new HotNews\n         {\n             Title = x.InnerText,\n             Url = x.GetAttributeValue(\"href\", \"\"),\n             SourceId = sourceId,\n             CreateTime = DateTime.Now\n         });\n     });\n }\n```\n\n```CSharp\n// V2EX\nif (item.Source == HotNewsEnum.v2ex)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//span[@class='item_title']/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = $\"https://www.v2ex.com{x.GetAttributeValue(\"href\", \"\")}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// SegmentFault\n if (item.Source == HotNewsEnum.segmentfault)\n {\n     var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='news__item-info clearfix']/a\").Where(x => x.InnerText.IsNotNullOrEmpty()).ToList();\n     nodes.ForEach(x =>\n     {\n         hotNews.Add(new HotNews\n         {\n             Title = x.SelectSingleNode(\".//h4\").InnerText,\n             Url = $\"https://segmentfault.com{x.GetAttributeValue(\"href\", \"\")}\",\n             SourceId = sourceId,\n             CreateTime = DateTime.Now\n         });\n     });\n }\n```\n\n```CSharp\n// 掘金\nif (item.Source == HotNewsEnum.juejin)\n{\n    var obj = JObject.Parse((string)item.Result);\n    var nodes = obj[\"data\"][\"articleFeed\"][\"items\"][\"edges\"];\n    foreach (var node in nodes)\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = node[\"node\"][\"title\"].ToString(),\n            Url = node[\"node\"][\"originalUrl\"].ToString(),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    }\n}\n```\n\n```CSharp\n// 微信热门\nif (item.Source == HotNewsEnum.weixin)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//ul[@class='news-list']/li/div[@class='txt-box']/h3/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = x.GetAttributeValue(\"href\", \"\"),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 豆瓣精选\nif (item.Source == HotNewsEnum.douban)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='channel-item']/div[@class='bd']/h3/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = x.GetAttributeValue(\"href\", \"\"),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// IT之家\nif (item.Source == HotNewsEnum.ithome)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='lst lst-2 hot-list']/div[1]/ul/li/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = x.GetAttributeValue(\"href\", \"\"),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 36氪\nif (item.Source == HotNewsEnum.kr36)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='hotlist-main']/div[@class='hotlist-item-toptwo']/a[2]|//div[@class='hotlist-main']/div[@class='hotlist-item-other clearfloat']/div[@class='hotlist-item-other-info']/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = $\"https://36kr.com{x.GetAttributeValue(\"href\", \"\")}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 百度贴吧\nif (item.Source == HotNewsEnum.tieba)\n{\n    var obj = JObject.Parse(((HtmlDocument)item.Result).ParsedText);\n    var nodes = obj[\"data\"][\"bang_topic\"][\"topic_list\"];\n    foreach (var node in nodes)\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = node[\"topic_name\"].ToString(),\n            Url = node[\"topic_url\"].ToString().Replace(\"amp;\", \"\"),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    }\n}\n```\n\n```CSharp\n// 百度热搜\nif (item.Source == HotNewsEnum.baidu)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//table[@class='list-table']//tr/td[@class='keyword']/a[@class='list-title']\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = x.GetAttributeValue(\"href\", \"\"),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 微博热搜\nif (item.Source == HotNewsEnum.weibo)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//table/tbody/tr/td[2]/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = $\"https://s.weibo.com{x.GetAttributeValue(\"href\", \"\").Replace(\"#\", \"%23\")}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 知乎热榜\nif (item.Source == HotNewsEnum.zhihu)\n{\n    var obj = JObject.Parse(((HtmlDocument)item.Result).ParsedText);\n    var nodes = obj[\"data\"];\n    foreach (var node in nodes)\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = node[\"target\"][\"title\"].ToString(),\n            Url = $\"https://www.zhihu.com/question/{node[\"target\"][\"id\"]}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    }\n}\n```\n\n```CSharp\n// 知乎日报\nif (item.Source == HotNewsEnum.zhihudaily)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='box']/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = $\"https://daily.zhihu.com{x.GetAttributeValue(\"href\", \"\")}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 网易新闻\nif (item.Source == HotNewsEnum.news163)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//div[@class='area-half left']/div[@class='tabBox']/div[@class='tabContents active']/table//tr/td[1]/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText,\n            Url = x.GetAttributeValue(\"href\", \"\"),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// GitHub\nif (item.Source == HotNewsEnum.github)\n{\n    var nodes = ((HtmlDocument)item.Result).DocumentNode.SelectNodes(\"//article[@class='Box-row']/h1/a\").ToList();\n    nodes.ForEach(x =>\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = x.InnerText.Trim().Replace(\"\\n\", \"\").Replace(\" \", \"\"),\n            Url = $\"https://github.com{x.GetAttributeValue(\"href\", \"\")}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    });\n}\n```\n\n```CSharp\n// 抖音热点\nif (item.Source == HotNewsEnum.douyin_hot)\n{\n    var obj = JObject.Parse(((HtmlDocument)item.Result).ParsedText);\n    var nodes = obj[\"word_list\"];\n    foreach (var node in nodes)\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = node[\"word\"].ToString(),\n            Url = $\"#{node[\"hot_value\"]}\",\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    }\n}\n```\n\n```CSharp\n// 抖音视频 & 抖音正能量\nif (item.Source == HotNewsEnum.douyin_video || item.Source == HotNewsEnum.douyin_positive)\n{\n    var obj = JObject.Parse(((HtmlDocument)item.Result).ParsedText);\n    var nodes = obj[\"aweme_list\"];\n    foreach (var node in nodes)\n    {\n        hotNews.Add(new HotNews\n        {\n            Title = node[\"aweme_info\"][\"desc\"].ToString(),\n            Url = node[\"aweme_info\"][\"share_url\"].ToString(),\n            SourceId = sourceId,\n            CreateTime = DateTime.Now\n        });\n    }\n}\n```\n\n将`item.Result`转换成指定类型，最终拿到数据后，我们先删除所有数据后再批量插入。\n\n然后新建扩展方法`UseHotNewsJob()`，在模块类中调用。\n\n```CSharp\n//MeowvBlogBackgroundJobsExtensions.cs\n...\n        /// <summary>\n        /// 每日热点数据抓取\n        /// </summary>\n        /// <param name=\"context\"></param>\n        public static void UseHotNewsJob(this IServiceProvider service)\n        {\n            var job = service.GetService<HotNewsJob>();\n\n            RecurringJob.AddOrUpdate(\"每日热点数据抓取\", () => job.ExecuteAsync(), CronType.Hour(1, 2));\n        }\n...\n```\n\n指定定时任务为每2小时运行一次。\n\n```CSharp\n...\n        public override void OnApplicationInitialization(ApplicationInitializationContext context)\n        {\n            ...\n            var service = context.ServiceProvider;\n            ...\n            service.UseHotNewsJob();\n        }\n```\n\n编译运行，此时周期性作业就会出现我们的定时任务了。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528111458591-1545091514.png)\n\n默认时间没到是不会执行的，我们手动执行等待一会看看效果。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528111904656-2025782870.png)\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528111836302-683698784.png)\n\n执行完成后，成功将所有热点数据保存在数据库中，说明我们的爬虫已经搞定了，并且Hangfire会按照给定的规则去循环执行，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "定时任务",
      "HtmlAgilityPack"
    ],
    "createdAt": "2020-05-30 11:12:30"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）",
    "author": "阿星Plus",
    "url": "2020-06-01-blog_15",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了全网各大平台的热点新闻数据的抓取，本篇继续围绕抓取完成后的操作做一个提醒。当每次抓取完数据后，自动发送邮件进行提醒。\n\n在开始正题之前还是先玩一玩之前的说到却没有用到的一个库`PuppeteerSharp`。\n\n`PuppeteerSharp`：Headless Chrome .NET API ，它运用最多的应该是自动化测试和抓取异步加载的网页数据，更多介绍可以看GitHub：https://github.com/hardkoded/puppeteer-sharp 。\n\n我这里主要来试试它的异步抓取功能，同时它还能帮我们生成网页截图或者PDF。\n\n如果没有安装可以先安装一下，在`.BackgroundJobs`层安装`PuppeteerSharp`：`Install-Package PuppeteerSharp`\n\n在Jobs文件夹下新建一个`PuppeteerTestJob.cs`，继承`IBackgroundJob`，同样是在`ExecuteAsync()`方法中执行操作。\n\n```CSharp\n//PuppeteerTestJob.cs\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs.PuppeteerTest\n{\n    public class PuppeteerTestJob : IBackgroundJob\n    {\n        public async Task ExecuteAsync()\n        {\n            throw new NotImplementedException();\n        }\n    }\n}\n```\n\n使用 `await new BrowserFetcher().DownloadAsync(BrowserFetcher.DefaultRevision);` 第一次检测到没有浏览器文件会默认帮我们下载 chromium 浏览器。\n\n`DownloadAsync(...)`可以指定 Chromium 版本，`BrowserFetcher.DefaultRevision` 下载当前默认最稳定的版本。\n\n然后配置浏览器启动的方式。\n\n```CSharp\nusing var browser = await Puppeteer.LaunchAsync(new LaunchOptions\n{\n    Headless = true,\n    Args = new string[] { \"--no-sandbox\" }\n});\n```\n\n感兴趣的可以自己看看`LaunchOptions`有哪些参数，我这里指定了`Headless = true` 以无头模式运行浏览器，然后加了一个启动参数 \"--no-sandbox\"。针对Linux环境下，如果是运行在 root 权限下，在启动 Puppeteer 时要添加 \"--no-sandbox\" 参数，否则 Chromium 会启动失败。\n\n我们打开一个异步加载的网页，然后获取到页面加载完后的HTML，以我个人博客中的某个单页为例：https://meowv.com/wallpaper 。\n\n```CSharp\n//PuppeteerTestJob.cs\nusing PuppeteerSharp;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BackgroundJobs.Jobs.PuppeteerTest\n{\n    public class PuppeteerTestJob : IBackgroundJob\n    {\n        public async Task ExecuteAsync()\n        {\n            await new BrowserFetcher().DownloadAsync(BrowserFetcher.DefaultRevision);\n\n            using var browser = await Puppeteer.LaunchAsync(new LaunchOptions\n            {\n                Headless = true,\n                Args = new string[] { \"--no-sandbox\" }\n            });\n\n            using var page = await browser.NewPageAsync();\n\n            await page.SetViewportAsync(new ViewPortOptions\n            {\n                Width = 1920,\n                Height = 1080\n            });\n\n            var url = \"https://meowv.com/wallpaper\";\n            await page.GoToAsync(url, WaitUntilNavigation.Networkidle0);\n\n            var content = await page.GetContentAsync();\n        }\n    }\n}\n```\n\n`page.SetViewportAsync()`设置网页预览大小，`page.GoToAsync()`语法打开网页，`WaitUntilNavigation.Networkidle0`等待网页加载完毕，使用`page.GetContentAsync()`获取到HTML。\n\n新建扩展方法，调用这个`PuppeteerTestJob`的`ExecuteAsync()`方法，调试看看效果。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528174921815-891976044.png)\n\nHTML已经出来了，此时该干嘛就干嘛就可以了。\n\n第一次运行可能会很慢，因为如果你本地不存在 Chromium 是会去帮我们下载的，因为网络原因可能会下载的很慢，所以推荐大家手动下载。\n\n可以使用淘宝的源：https://npm.taobao.org/mirrors/chromium-browser-snapshots/ 。\n\n要注意的是，下载完成后的解压的路径不能出错，默认下载地址是在启动目录下面。\n\nWindows：`..\\.local-chromium\\Win64-706915\\chrome-win` 、 Linux：`../.local-chromium/Linux-706915/chrome-linux`\n\n接下来试试生成PDF和保存图片功能，使用方式也很简单。\n\n```CSharp\nawait page.PdfAsync(\"meowv.pdf\",new PdfOptions { });\nawait page.ScreenshotAsync(\"meowv.png\", new ScreenshotOptions\n{\n    FullPage = true,\n    Type = ScreenshotType.Png\n});\n```\n\n这里只做简单的展示，`page.PdfAsync()`直接生成PDF文件，同时还有很多方法可以自己调用`page.`试试，`PdfOptions`选项中可以设置各种参数。\n\n`page.ScreenshotAsync()`保存图片，`ScreenshotOptions`中FullPage可以设置保存图片为全屏模式，图片格式为Png类型。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200528221651792-817779840.png)\n\n可以看到项目根目录已经生成了图片和PDF，感觉去试试吧。\n\n接下里来实现发送邮件的功能。\n\n我这里发邮件的账号是用的腾讯企业邮箱，也可以用普通邮箱开通SMTP服务即可。\n\n在`appsettings.json`配置收发邮件的账号等信息。\n\n```json\n//appsettings.json\n  \"Email\": {\n    \"Host\": \"smtp.exmail.qq.com\",\n    \"Port\": 465,\n    \"UseSsl\": true,\n    \"From\": {\n      \"Username\": \"123@meowv.com\",\n      \"Password\": \"[Password]\",\n      \"Name\": \"MEOWV.COM\",\n      \"Address\": \"123@meowv.com\"\n    },\n    \"To\": [\n      {\n        \"Name\": \"test1\",\n        \"Address\": \"test1@meowv.com\"\n      },\n      {\n        \"Name\": \"test2\",\n        \"Address\": \"test2@meowv.com\"\n      }\n    ]\n  }\n```\n\n然后再`AppSettings`中读取配置的项。\n\n```CSharp\n//AppSettings.cs\npublic static class Email\n{\n    /// <summary>\n    /// Host\n    /// </summary>\n    public static string Host => _config[\"Email:Host\"];\n\n    /// <summary>\n    /// Port\n    /// </summary>\n    public static int Port => Convert.ToInt32(_config[\"Email:Port\"]);\n\n    /// <summary>\n    /// UseSsl\n    /// </summary>\n    public static bool UseSsl => Convert.ToBoolean(_config[\"Email:UseSsl\"]);\n\n    /// <summary>\n    /// From\n    /// </summary>\n    public static class From\n    {\n        /// <summary>\n        /// Username\n        /// </summary>\n        public static string Username => _config[\"Email:From:Username\"];\n\n        /// <summary>\n        /// Password\n        /// </summary>\n        public static string Password => _config[\"Email:From:Password\"];\n\n        /// <summary>\n        /// Name\n        /// </summary>\n        public static string Name => _config[\"Email:From:Name\"];\n\n        /// <summary>\n        /// Address\n        /// </summary>\n        public static string Address => _config[\"Email:From:Address\"];\n    }\n\n    /// <summary>\n    /// To\n    /// </summary>\n    public static IDictionary<string, string> To\n    {\n        get\n        {\n            var dic = new Dictionary<string, string>();\n\n            var emails = _config.GetSection(\"Email:To\");\n            foreach (IConfigurationSection section in emails.GetChildren())\n            {\n                var name = section[\"Name\"];\n                var address = section[\"Address\"];\n\n                dic.Add(name, address);\n            }\n            return dic;\n        }\n    }\n}\n```\n\n分别介绍下每项的含义：\n\n- `Host`：发送邮件服务器地址。\n- `Port`：服务器地址端口号。\n- `UseSsl`：是否使用SSL方式。\n- `From`：发件人的账号密码，名称及邮箱地址，一般邮箱地址和账号是相同的。\n- `To`：收件人邮箱列表，也包含名称和邮箱地址。\n\n收件人邮箱列表我将其读取为`IDictionary<string, string>`了，key是名称，value是邮箱地址。\n\n接着在`.ToolKits`层添加一个`EmailHelper.cs`，收发邮件我选择了`MailKit`和`MailKit`两个库，没有安装的先安装一下，`Install-Package MailKit`、`Install-Package MimeKit`。\n\n直接新建一个发送邮件的方法`SendAsync()`，按照要求将基本的配置信息填进去，然后直接调用即可。\n\n```CSharp\n//EmailHelper.cs\nusing MailKit.Net.Smtp;\nusing Meowv.Blog.Domain.Configurations;\nusing MimeKit;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.ToolKits.Helper\n{\n    public static class EmailHelper\n    {\n        /// <summary>\n        /// 发送Email\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <returns></returns>\n        public static async Task SendAsync(MimeMessage message)\n        {\n            if (!message.From.Any())\n            {\n                message.From.Add(new MailboxAddress(AppSettings.Email.From.Name, AppSettings.Email.From.Address));\n            }\n            if (!message.To.Any())\n            {\n                var address = AppSettings.Email.To.Select(x => new MailboxAddress(x.Key, x.Value));\n                message.To.AddRange(address);\n            }\n\n            using var client = new SmtpClient\n            {\n                ServerCertificateValidationCallback = (s, c, h, e) => true\n            };\n            client.AuthenticationMechanisms.Remove(\"XOAUTH2\");\n\n            await client.ConnectAsync(AppSettings.Email.Host, AppSettings.Email.Port, AppSettings.Email.UseSsl);\n            await client.AuthenticateAsync(AppSettings.Email.From.Username, AppSettings.Email.From.Password);\n            await client.SendAsync(message);\n            await client.DisconnectAsync(true);\n        }\n    }\n}\n```\n\n`SendAsync(...)`接收一个参数`MimeMessage`对象，这样就完成了一个通用的发邮件方法，接着我们去需要发邮件的地方构造`MimeMessage`，调用`SendAsync()`。\n\n```CSharp\n//WallpaperJob.cs\n...\n    // 发送Email\n    var message = new MimeMessage\n    {\n        Subject = \"【定时任务】壁纸数据抓取任务推送\",\n        Body = new BodyBuilder\n        {\n            HtmlBody = $\"本次抓取到{wallpapers.Count()}条数据，时间:{DateTime.Now:yyyy-MM-dd HH:mm:ss}\"\n        }.ToMessageBody()\n    };\n    await EmailHelper.SendAsync(message);\n...\n```\n\n```CSharp\n//HotNewsJob.cs\n...\n    // 发送Email\n    var message = new MimeMessage\n    {\n        Subject = \"【定时任务】每日热点数据抓取任务推送\",\n        Body = new BodyBuilder\n        {\n            HtmlBody = $\"本次抓取到{hotNews.Count()}条数据，时间:{DateTime.Now:yyyy-MM-dd HH:mm:ss}\"\n        }.ToMessageBody()\n    };\n    await EmailHelper.SendAsync(message);\n...\n```\n\n分别在两个爬虫脚本中添加发送Email，`MimeMessage`中设置了邮件主题`Subject`，正文`Body`，最后调用`await EmailHelper.SendAsync(message)`执行发送邮件操作。\n\n编译运行执行两个定时任务，看看能否收到邮件提醒。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529100724534-474654264.png)\n\n成功了，邮箱收到了两条提醒。\n\n还有一种比较特殊的用法，也介绍一下，如果想要发送带图片的邮件怎么操作呢？注意不是附件，是将图片内嵌在邮箱中。\n\n一般常规都是有邮件模板的，将图片的具体地址插入到img标签中，这就不说了，这里选择另外一种方式。以前面添加的`PuppeteerTestJob`为例，正好我们生成了一张图片的。将这种图片以邮件的形式发出去。\n\n```CSharp\npublic class PuppeteerTestJob : IBackgroundJob\n{\n    public async Task ExecuteAsync()\n    {\n        var path = Path.Combine(Path.GetTempPath(), \"meowv.png\");\n        \n        ...\n        \n        await page.ScreenshotAsync(path, new ScreenshotOptions\n        {\n            FullPage = true,\n            Type = ScreenshotType.Png\n        });\n\n        // 发送带图片的Email\n        var builder = new BodyBuilder();\n\n        var image = builder.LinkedResources.Add(path);\n        image.ContentId = MimeUtils.GenerateMessageId();\n\n        builder.HtmlBody = \"当前时间:{0}.<img src=\\\"cid:{1}\\\"/>\".FormatWith(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"), image.ContentId);\n\n        var message = new MimeMessage\n        {\n            Subject = \"【定时任务】每日热点数据抓取任务推送\",\n            Body = builder.ToMessageBody()\n        };\n        await EmailHelper.SendAsync(message);\n    }\n}\n```\n\n先确定我们生成图片的路径 path ，将图片生成Message-Id，然后赋值给ContentId，给模板中`<img src=\\\"cid:{1}\\\"/>`图片标签`cid`赋上值在调用发送邮件方法即可。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529102657347-356768984.jpg)\n\n成功收到邮件，搞定了，你学会了吗？😁😁😁\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "定时任务",
      "PuppeteerSharp",
      "MailKit"
    ],
    "createdAt": "2020-06-01 09:02:01"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）",
    "author": "阿星Plus",
    "url": "2020-06-02-blog_16",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n从本篇就开始博客页面的接口开发了，其实这些接口我是不想用文字来描述的，太枯燥太无趣了。全是CRUD，谁还不会啊，用得着我来讲吗？想想为了不半途而废，为了之前立的Flag，还是咬牙坚持吧。\n\n## 准备工作\n\n现在博客数据库中的数据是比较混乱的，为了看起来像那么回事，显得正式一点，我先手动搞点数据进去。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529144651901-307322670.png)\n\n搞定了种子数据，就可以去愉快的写接口了，我这里将根据我现在的[博客](https://meowv.com)页面去分析所需要接口，感兴趣的去点点。\n\n为了让接口看起来清晰，一目了然，删掉之前在`IBlogService`中添加的所有接口，将5个自定义仓储全部添加至`BlogService`中，然后用`partial`修饰。\n\n```CSharp\n//IBlogService.cs\npublic partial interface IBlogService\n{\n}\n\n//BlogService.cs\nusing Meowv.Blog.Application.Caching.Blog;\nusing Meowv.Blog.Domain.Blog.Repositories;\n\nnamespace Meowv.Blog.Application.Blog.Impl\n{\n    public partial class BlogService : ServiceBase, IBlogService\n    {\n        private readonly IBlogCacheService _blogCacheService;\n        private readonly IPostRepository _postRepository;\n        private readonly ICategoryRepository _categoryRepository;\n        private readonly ITagRepository _tagRepository;\n        private readonly IPostTagRepository _postTagRepository;\n        private readonly IFriendLinkRepository _friendLinksRepository;\n\n        public BlogService(IBlogCacheService blogCacheService,\n                           IPostRepository postRepository,\n                           ICategoryRepository categoryRepository,\n                           ITagRepository tagRepository,\n                           IPostTagRepository postTagRepository,\n                           IFriendLinkRepository friendLinksRepository)\n        {\n            _blogCacheService = blogCacheService;\n            _postRepository = postRepository;\n            _categoryRepository = categoryRepository;\n            _tagRepository = tagRepository;\n            _postTagRepository = postTagRepository;\n            _friendLinksRepository = friendLinksRepository;\n        }\n    }\n}\n```\n\n在Blog文件夹下依次添加接口：`IBlogService.Post.cs`、`IBlogService.Category.cs`、`IBlogService.Tag.cs`、`IBlogService.FriendLink.cs`、`IBlogService.Admin.cs`。\n\n在Blog/Impl文件夹下添加实现类：`IBlogService.Post.cs`、`BlogService.Category.cs`、`BlogService.Tag.cs`、`BlogService.FriendLink.cs`、`BlogService.Admin.cs`。\n\n同上，`.Application.Caching`层也按照这个样子添加。\n\n注意都需要添加partial修饰为局部的接口和实现类，所有文章相关的接口放在`IBlogService.Post.cs`中，分类放在`IBlogService.Category.cs`，标签放在`IBlogService.Tag.cs`，友链放在`IBlogService.FriendLink.cs`，后台增删改所有接口放在`IBlogService.Admin.cs`，最终效果图如下：\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529163242712-475151910.png)\n\n## 文章列表页\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529145439535-529721135.png)\n\n分析：列表带分页，以文章发表的年份分组，所需字段：标题、链接、时间、年份。\n\n在`.Application.Contracts`层Blog文件夹下添加返回的模型：`QueryPostDto.cs`。\n\n```CSharp\n//QueryPostDto.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryPostDto\n    {\n        /// <summary>\n        /// 年份\n        /// </summary>\n        public int Year { get; set; }\n\n        /// <summary>\n        /// Posts\n        /// </summary>\n        public IEnumerable<PostBriefDto> Posts { get; set; }\n    }\n}\n```\n\n模型为一个年份和一个文章列表，文章列表模型：`PostBriefDto.cs`。\n\n```CSharp\n//PostBriefDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class PostBriefDto\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string Url { get; set; }\n\n        /// <summary>\n        /// 年份\n        /// </summary>\n        public int Year { get; set; }\n\n        /// <summary>\n        /// 创建时间\n        /// </summary>\n        public string CreationTime { get; set; }\n    }\n}\n```\n\n搞定，因为返回时间为英文格式，所以`CreationTime `给了字符串类型。\n\n在`IBlogService.Post.cs`中添加接口分页查询文章列表`QueryPostsAsync`，肯定需要接受俩参数分页页码和分页数量。还是去添加一个公共模型`PagingInput`吧，在`.Application.Contracts`下面。\n\n```CSharp\n//PagingInput.cs\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Meowv.Blog.Application.Contracts\n{\n    /// <summary>\n    /// 分页输入参数\n    /// </summary>\n    public class PagingInput\n    {\n        /// <summary>\n        /// 页码\n        /// </summary>\n        [Range(1, int.MaxValue)]\n        public int Page { get; set; } = 1;\n\n        /// <summary>\n        /// 限制条数\n        /// </summary>\n        [Range(10, 30)]\n        public int Limit { get; set; } = 10;\n    }\n}\n```\n\n`Page`设置默认值为1，`Limit`设置默认值为10，`Range Attribute`设置参数可输入大小限制，于是这个分页查询文章列表的接口就是这个样子的。\n\n```CSharp\n//IBlogService.Post.cs\npublic partial interface IBlogService\n{\n    /// <summary>\n    /// 分页查询文章列表\n    /// </summary>\n    /// <param name=\"input\"></param>\n    /// <returns></returns>\n    Task<ServiceResult<PagedList<QueryPostDto>>> QueryPostsAsync(PagingInput input);\n}\n```\n\n`ServiceResult`和`PagedList`是之前添加的统一返回模型，紧接着就去添加一个分页查询文章列表缓存接口，和上面是对应的。\n\n```CSharp\n//IBlogCacheService.Post.cs\nusing Meowv.Blog.Application.Contracts;\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Caching.Blog\n{\n    public partial interface IBlogCacheService\n    {\n        /// <summary>\n        /// 分页查询文章列表\n        /// </summary>\n        /// <param name=\"input\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<PagedList<QueryPostDto>>> QueryPostsAsync(PagingInput input, Func<Task<ServiceResult<PagedList<QueryPostDto>>>> factory);\n    }\n}\n```\n\n分别实现这两个接口。\n\n```CSharp\n//BlogCacheService.Post.cs\npublic partial class BlogCacheService\n{\n    private const string KEY_QueryPosts = \"Blog:Post:QueryPosts-{0}-{1}\";\n\n    /// <summary>\n    /// 分页查询文章列表\n    /// </summary>\n    /// <param name=\"input\"></param>\n    /// <param name=\"factory\"></param>\n    /// <returns></returns>\n    public async Task<ServiceResult<PagedList<QueryPostDto>>> QueryPostsAsync(PagingInput input, Func<Task<ServiceResult<PagedList<QueryPostDto>>>> factory)\n    {\n        return await Cache.GetOrAddAsync(KEY_QueryPosts.FormatWith(input.Page, input.Limit), factory, CacheStrategy.ONE_DAY);\n    }\n}\n```\n\n```CSharp\n//BlogService.Post.cs\n/// <summary>\n/// 分页查询文章列表\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<PagedList<QueryPostDto>>> QueryPostsAsync(PagingInput input)\n{\n    return await _blogCacheService.QueryPostsAsync(input, async () =>\n    {\n        var result = new ServiceResult<PagedList<QueryPostDto>>();\n\n        var count = await _postRepository.GetCountAsync();\n\n        var list = _postRepository.OrderByDescending(x => x.CreationTime)\n                                  .PageByIndex(input.Page, input.Limit)\n                                  .Select(x => new PostBriefDto\n                                  {\n                                      Title = x.Title,\n                                      Url = x.Url,\n                                      Year = x.CreationTime.Year,\n                                      CreationTime = x.CreationTime.TryToDateTime()\n                                  }).GroupBy(x => x.Year)\n                                  .Select(x => new QueryPostDto\n                                  {\n                                      Year = x.Key,\n                                      Posts = x.ToList()\n                                  }).ToList();\n\n        result.IsSuccess(new PagedList<QueryPostDto>(count.TryToInt(), list));\n        return result;\n    });\n}\n```\n\n`PageByIndex(...)`、`TryToDateTime()`是`.ToolKits`层添加的扩展方法，先查询总数，然后根据时间倒序，分页，筛选出所需字段，根据年份分组，输出，结束。\n\n在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 分页查询文章列表\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"posts\")]\npublic async Task<ServiceResult<PagedList<QueryPostDto>>> QueryPostsAsync([FromQuery] PagingInput input)\n{\n    return await _blogService.QueryPostsAsync(input);\n}\n```\n\n`[FromQuery]`设置input为从URL进行查询参数，编译运行看效果。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529165143066-1796425504.png)\n\n已经可以查询出数据，并且缓存至Redis中。\n\n## 获取文章详情\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200529223127521-1917832043.png)\n\n分析：文章详情页，文章的标题、作者、发布时间、所属分类、标签列表、文章内容(HTML和MarkDown)、链接、上下篇的标题和链接。\n\n创建返回模型：`PostDetailDto.cs`\n\n```CSharp\n//PostDetailDto.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class PostDetailDto\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 作者\n        /// </summary>\n        public string Author { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string Url { get; set; }\n\n        /// <summary>\n        /// HTML\n        /// </summary>\n        public string Html { get; set; }\n\n        /// <summary>\n        /// Markdown\n        /// </summary>\n        public string Markdown { get; set; }\n\n        /// <summary>\n        /// 创建时间\n        /// </summary>\n        public string CreationTime { get; set; }\n\n        /// <summary>\n        /// 分类\n        /// </summary>\n        public CategoryDto Category { get; set; }\n\n        /// <summary>\n        /// 标签列表\n        /// </summary>\n        public IEnumerable<TagDto> Tags { get; set; }\n\n        /// <summary>\n        /// 上一篇\n        /// </summary>\n        public PostForPagedDto Previous { get; set; }\n\n        /// <summary>\n        /// 下一篇\n        /// </summary>\n        public PostForPagedDto Next { get; set; }\n    }\n}\n```\n\n同时添加`CategoryDto`、`TagDto`、`PostForPagedDto`。\n\n```CSharp\n//CategoryDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class CategoryDto\n    {\n        /// <summary>\n        /// 分类名称\n        /// </summary>\n        public string CategoryName { get; set; }\n\n        /// <summary>\n        /// 展示名称\n        /// </summary>\n        public string DisplayName { get; set; }\n    }\n}\n\n//TagDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class TagDto\n    {\n        /// <summary>\n        /// 标签名称\n        /// </summary>\n        public string TagName { get; set; }\n\n        /// <summary>\n        /// 展示名称\n        /// </summary>\n        public string DisplayName { get; set; }\n    }\n}\n\n//PostForPagedDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class PostForPagedDto\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string Url { get; set; }\n    }\n}\n```\n\n添加获取文章详情接口和缓存的接口。\n\n```CSharp\n//IBlogService.Post.cs\npublic partial interface IBlogService\n{\n    /// <summary>\n    /// 根据URL获取文章详情\n    /// </summary>\n    /// <param name=\"url\"></param>\n    /// <returns></returns>\n    Task<ServiceResult<PostDetailDto>> GetPostDetailAsync(string url);\n}\n```\n\n```CSharp\n//IBlogCacheService.Post.cs\npublic partial interface IBlogCacheService\n{\n    /// <summary>\n    /// 根据URL获取文章详情\n    /// </summary>\n    /// <param name=\"url\"></param>\n    /// <returns></returns>\n    Task<ServiceResult<PostDetailDto>> GetPostDetailAsync(string url, Func<Task<ServiceResult<PostDetailDto>>> factory);\n}\n```\n\n分别实现这两个接口。\n\n```CSharp\n//BlogCacheService.Post.cs\npublic partial class BlogCacheService\n{\n    private const string KEY_GetPostDetail = \"Blog:Post:GetPostDetail-{0}\";\n\n    /// <summary>\n    /// 根据URL获取文章详情\n    /// </summary>\n    /// <param name=\"url\"></param>\n    /// <param name=\"factory\"></param>\n    /// <returns></returns>\n    public async Task<ServiceResult<PostDetailDto>> GetPostDetailAsync(string url, Func<Task<ServiceResult<PostDetailDto>>> factory)\n    {\n        return await Cache.GetOrAddAsync(KEY_GetPostDetail.FormatWith(url), factory, CacheStrategy.ONE_DAY);\n    }\n}\n```\n\n```CSharp\n//BlogService.Post.cs\n/// <summary>\n/// 根据URL获取文章详情\n/// </summary>\n/// <param name=\"url\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<PostDetailDto>> GetPostDetailAsync(string url)\n{\n    return await _blogCacheService.GetPostDetailAsync(url, async () =>\n    {\n        var result = new ServiceResult<PostDetailDto>();\n\n        var post = await _postRepository.FindAsync(x => x.Url.Equals(url));\n\n        if (null == post)\n        {\n            result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"URL\", url));\n            return result;\n        }\n\n        var category = await _categoryRepository.GetAsync(post.CategoryId);\n\n        var tags = from post_tags in await _postTagRepository.GetListAsync()\n                   join tag in await _tagRepository.GetListAsync()\n                   on post_tags.TagId equals tag.Id\n                   where post_tags.PostId.Equals(post.Id)\n                   select new TagDto\n                   {\n                       TagName = tag.TagName,\n                       DisplayName = tag.DisplayName\n                   };\n\n        var previous = _postRepository.Where(x => x.CreationTime > post.CreationTime).Take(1).FirstOrDefault();\n        var next = _postRepository.Where(x => x.CreationTime < post.CreationTime).OrderByDescending(x => x.CreationTime).Take(1).FirstOrDefault();\n\n        var postDetail = new PostDetailDto\n        {\n            Title = post.Title,\n            Author = post.Author,\n            Url = post.Url,\n            Html = post.Html,\n            Markdown = post.Markdown,\n            CreationTime = post.CreationTime.TryToDateTime(),\n            Category = new CategoryDto\n            {\n                CategoryName = category.CategoryName,\n                DisplayName = category.DisplayName\n            },\n            Tags = tags,\n            Previous = previous == null ? null : new PostForPagedDto\n            {\n                Title = previous.Title,\n                Url = previous.Url\n            },\n            Next = next == null ? null : new PostForPagedDto\n            {\n                Title = next.Title,\n                Url = next.Url\n            }\n        };\n\n        result.IsSuccess(postDetail);\n        return result;\n    });\n}\n```\n\n`ResponseText.WHAT_NOT_EXIST`是定义在`MeowvBlogConsts.cs`的常量。\n\n`TryToDateTime()`和列表查询中的扩展方法一样，转换时间为想要的格式。\n\n简单说一下查询逻辑，先根据参数url，查询是否存在数据，如果文章不存在则返回错误消息。\n\n然后根据 `post.CategoryId` 就可以查询到当前文章的分类名称。\n\n联合查询post_tags和tag两张表，指定查询条件post.Id，查询当前文章的所有标签。\n\n最后上下篇的逻辑也很简单，上一篇取大于当前文章发布时间的第一篇，下一篇取时间倒序排序并且小于当前文章发布时间的第一篇文章。\n\n最后将所有查询到的数据赋值给输出对象，返回，结束。\n\n在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n /// 根据URL获取文章详情\n /// </summary>\n /// <param name=\"url\"></param>\n /// <returns></returns>\n [HttpGet]\n [Route(\"post\")]\n public async Task<ServiceResult<PostDetailDto>> GetPostDetailAsync(string url)\n {\n     return await _blogService.GetPostDetailAsync(url);\n }\n```\n\n编译运行，然后输入URL查询一条文章详情数据。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200530152153982-2471646.png)\n\n成功输出预期内容，缓存同时也是ok的。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "WebApi"
    ],
    "createdAt": "2020-06-02 08:56:02"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）",
    "author": "阿星Plus",
    "url": "2020-06-03-blog_17",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://www.cnblogs.com/meowv/p/12896177.html)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://www.cnblogs.com/meowv/p/12896898.html)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://www.cnblogs.com/meowv/p/12909558.html)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://www.cnblogs.com/meowv/p/12913676.html)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://www.cnblogs.com/meowv/p/12916613.html)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://www.cnblogs.com/meowv/p/12924409.html)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://www.cnblogs.com/meowv/p/12924859.html)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://www.cnblogs.com/meowv/p/12935693.html)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://www.cnblogs.com/meowv/p/12943699.html)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://www.cnblogs.com/meowv/p/12956696.html)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://www.cnblogs.com/meowv/p/12961014.html)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://www.cnblogs.com/meowv/p/12966092.html)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://www.cnblogs.com/meowv/p/12971041.html)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://www.cnblogs.com/meowv/p/12974439.html)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://www.cnblogs.com/meowv/p/12980301.html)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://www.cnblogs.com/meowv/p/12987623.html)**\n\n---\n\n上篇文章完成了两个接口：文章列表页、文章详情页，本篇继续。\n\n## 分类列表\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200530205934508-1023085331.png)\n\n分析：这里多了一个统计文章数量的字段，可以直接新建一个模型`QueryCategoryDto.cs`继承`CategoryDto`。\n\n```CSharp\n//QueryCategoryDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryCategoryDto : CategoryDto\n    {\n        /// <summary>\n        /// 总数\n        /// </summary>\n        public int Count { get; set; }\n    }\n}\n```\n\n添加查询分类列表接口和缓存接口。\n\n```CSharp\n//IBlogService.Category.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog\n{\n    public partial interface IBlogService\n    {\n        /// <summary>\n        /// 查询分类列表\n        /// </summary>\n        /// <returns></returns>\n        Task<ServiceResult<IEnumerable<QueryCategoryDto>>> QueryCategoriesAsync();\n    }\n}\n```\n\n```CSharp\n//IBlogCacheService.Category.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Caching.Blog\n{\n    public partial interface IBlogCacheService\n    {\n        /// <summary>\n        /// 查询分类列表\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<IEnumerable<QueryCategoryDto>>> QueryCategoriesAsync(Func<Task<ServiceResult<IEnumerable<QueryCategoryDto>>>> factory);\n    }\n}\n```\n\n分别实现这两个接口。\n\n```CSharp\n//BlogCacheService.Category.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogConsts;\n\nnamespace Meowv.Blog.Application.Caching.Blog.Impl\n{\n    public partial class BlogCacheService\n    {\n        private const string KEY_QueryCategories = \"Blog:Category:QueryCategories\";\n\n        /// <summary>\n        /// 查询分类列表\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<QueryCategoryDto>>> QueryCategoriesAsync(Func<Task<ServiceResult<IEnumerable<QueryCategoryDto>>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_QueryCategories, factory, CacheStrategy.ONE_DAY);\n        }\n    }\n}\n```\n\n```CSharp\n//BlogService.Category.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog.Impl\n{\n    public partial class BlogService\n    {\n        /// <summary>\n        /// 查询分类列表\n        /// </summary>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<QueryCategoryDto>>> QueryCategoriesAsync()\n        {\n            return await _blogCacheService.QueryCategoriesAsync(async () =>\n            {\n                var result = new ServiceResult<IEnumerable<QueryCategoryDto>>();\n\n                var list = from category in await _categoryRepository.GetListAsync()\n                           join posts in await _postRepository.GetListAsync()\n                           on category.Id equals posts.CategoryId\n                           group category by new\n                           {\n                               category.CategoryName,\n                               category.DisplayName\n                           } into g\n                           select new QueryCategoryDto\n                           {\n                               CategoryName = g.Key.CategoryName,\n                               DisplayName = g.Key.DisplayName,\n                               Count = g.Count()\n                           };\n\n                result.IsSuccess(list);\n                return result;\n            });\n        }\n    }\n}\n```\n\n缓存就不说了，查询分类列表，联合查询文章和分类两张表，关联字段为CategoryId，然后分组，计算出对应的数量，在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 查询分类列表\n/// </summary>\n/// <returns></returns>\n[HttpGet]\n[Route(\"categories\")]\npublic async Task<ServiceResult<IEnumerable<QueryCategoryDto>>> QueryCategoriesAsync()\n{\n    return await _blogService.QueryCategoriesAsync();\n}\n```\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200530221606938-125033028.png)\n\n## 标签列表\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200530210035938-936314470.png)\n\n分析：和分类列表差不多，新建模型`QueryTagDto.cs`继承`TagDto`。\n\n```CSharp\n//QueryTagDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryTagDto : TagDto\n    {\n        /// <summary>\n        /// 总数\n        /// </summary>\n        public int Count { get; set; }\n    }\n}\n```\n\n添加查询标签列表接口和缓存接口。\n\n```CSharp\n//IBlogCacheService.Tag.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Caching.Blog\n{\n    public partial interface IBlogCacheService\n    {\n        /// <summary>\n        /// 查询标签列表\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<IEnumerable<QueryTagDto>>> QueryTagsAsync(Func<Task<ServiceResult<IEnumerable<QueryTagDto>>>> factory);\n    }\n}\n```\n\n```CSharp\n//IBlogService.Tag.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog\n{\n    public partial interface IBlogService\n    {\n        /// <summary>\n        /// 查询标签列表\n        /// </summary>\n        /// <returns></returns>\n        Task<ServiceResult<IEnumerable<QueryTagDto>>> QueryTagsAsync();\n    }\n}\n```\n\n分别实现这两个接口。\n\n```CSharp\n//BlogCacheService.Tag.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogConsts;\n\nnamespace Meowv.Blog.Application.Caching.Blog.Impl\n{\n    public partial class BlogCacheService\n    {\n        private const string KEY_QueryTags = \"Blog:Tag:QueryTags\";\n\n        /// <summary>\n        /// 查询标签列表\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<QueryTagDto>>> QueryTagsAsync(Func<Task<ServiceResult<IEnumerable<QueryTagDto>>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_QueryTags, factory, CacheStrategy.ONE_DAY);\n        }\n    }\n}\n```\n\n```CSharp\n//BlogService.Tag.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog.Impl\n{\n    public partial class BlogService\n    {\n        /// <summary>\n        /// 查询标签列表\n        /// </summary>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<QueryTagDto>>> QueryTagsAsync()\n        {\n            return await _blogCacheService.QueryTagsAsync(async () =>\n            {\n                var result = new ServiceResult<IEnumerable<QueryTagDto>>();\n\n                var list = from tags in await _tagRepository.GetListAsync()\n                           join post_tags in await _postTagRepository.GetListAsync()\n                           on tags.Id equals post_tags.TagId\n                           group tags by new\n                           {\n                               tags.TagName,\n                               tags.DisplayName\n                           } into g\n                           select new QueryTagDto\n                           {\n                               TagName = g.Key.TagName,\n                               DisplayName = g.Key.DisplayName,\n                               Count = g.Count()\n                           };\n\n                result.IsSuccess(list);\n                return result;\n            });\n        }\n    }\n}\n```\n\n查询标签列表需要联合查询tags和post_tags，根据TagId进行关联，然后分组从而获取标签下文章的总数，在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 查询标签列表\n/// </summary>\n/// <returns></returns>\n[HttpGet]\n[Route(\"tags\")]\npublic async Task<ServiceResult<IEnumerable<QueryTagDto>>> QueryTagsAsync()\n{\n    return await _blogService.QueryTagsAsync();\n}\n```\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200531203709733-747030904.png)\n\n## 分类名称&文章列表\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200531204711870-406154660.png)\n\n分析：此页面下包含两个接口，查询分类的名称和当前分类下的文章列表，和文章列表不同的是，它不带分页。分类包含两个字段，分类名称和展示名称，我们要把真正的名称查询出来展示在页面上。\n\n### 分类名称\n\n不需要给他添加返回模型，直接返回一个string类型即可，同时给一个查询参数name，添加获取分类名称接口和缓存接口。\n\n```CSharp\n//IBlogService.Category.cs\n/// <summary>\n/// 获取分类名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\nTask<ServiceResult<string>> GetCategoryAsync(string name);\n```\n\n```CSharp\n//IBlogCacheService.Category.cs\n/// <summary>\n/// 获取分类名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <param name=\"factory\"></param>\n/// <returns></returns>\nTask<ServiceResult<string>> GetCategoryAsync(string name, Func<Task<ServiceResult<string>>> factory);\n```\n\n实现这两个接口。\n\n```CSharp\n//BlogCacheService.Category.cs\n...\n    public partial class BlogCacheService\n    {\n        private const string KEY_GetCategory = \"Blog:Category:GetCategory-{0}\";\n\n        /// <summary>\n        /// 获取分类名称\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetCategoryAsync(string name, Func<Task<ServiceResult<string>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_GetCategory.FormatWith(name), factory, CacheStrategy.ONE_DAY);\n        }\n    }\n...\n```\n\n```CSharp\n//BlogService.Category.cs\n/// <summary>\n/// 获取分类名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<string>> GetCategoryAsync(string name)\n{\n    return await _blogCacheService.GetCategoryAsync(name, async () =>\n    {\n        var result = new ServiceResult<string>();\n\n        var category = await _categoryRepository.FindAsync(x => x.DisplayName.Equals(name));\n        if (null == category)\n        {\n            result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"分类\", name));\n            return result;\n        }\n\n        result.IsSuccess(category.CategoryName);\n        return result;\n    });\n}\n```\n\n`FormatWith()`是扩展方法，`ResponseText.WHAT_NOT_EXIST`是之前说过的常量，直接查询是否存在当前name的分类，如果不存在给出错误提示，存在的话，则只返回分类名称，在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 获取分类名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"category\")]\npublic async Task<ServiceResult<string>> GetCategoryAsync(([Required] string name)\n{\n    return await _blogService.GetCategoryAsync(name);\n}\n```\n\n`[Required]`Attribute 指定参数name必填。\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200531211747782-1793939137.png)\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200531211754464-1880035472.png)\n\n### 文章列表\n\n通过分类名称查询文章列表和分页查询文章列表返回模型是一样的，只是不用分页，所以直接返回一个列表就可以了，添加通过分类名称查询文章列表和缓存的接口。\n\n```CSharp\n//IBlogService.Post.cs\n/// <summary>\n/// 通过分类名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByCategoryAsync(string name);\n```\n\n```CSharp\n//IBlogCacheService.Post.cs\n/// <summary>\n/// 通过分类名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <param name=\"factory\"></param>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByCategoryAsync(string name, Func<Task<ServiceResult<IEnumerable<QueryPostDto>>>> factory);\n```\n\n分别实现这两个接口。\n\n```CSharp\n//BlogCacheService.Post.cs\n...\n    public partial class BlogCacheService\n    {\n        private const string KEY_QueryPostsByCategory = \"Blog:Post:QueryPostsByCategory-{0}\";\n\n        /// <summary>\n        /// 通过分类名称查询文章列表\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByCategoryAsync(string name, Func<Task<ServiceResult<IEnumerable<QueryPostDto>>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_QueryPostsByCategory.FormatWith(name), factory, CacheStrategy.ONE_DAY);\n        }\n    }\n...\n```\n\n```CSharp\n//BlogService.Post.cs\n/// <summary>\n/// 通过分类名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByCategoryAsync(string name)\n{\n    return await _blogCacheService.QueryPostsByCategoryAsync(name, async () =>\n    {\n        var result = new ServiceResult<IEnumerable<QueryPostDto>>();\n\n        var list = (from posts in await _postRepository.GetListAsync()\n                    join categories in await _categoryRepository.GetListAsync()\n                    on posts.CategoryId equals categories.Id\n                    where categories.DisplayName.Equals(name)\n                    orderby posts.CreationTime descending\n                    select new PostBriefDto\n                    {\n                        Title = posts.Title,\n                        Url = posts.Url,\n                        Year = posts.CreationTime.Year,\n                        CreationTime = posts.CreationTime.TryToDateTime()\n                    })\n                   .GroupBy(x => x.Year)\n                   .Select(x => new QueryPostDto\n                   {\n                       Year = x.Key,\n                       Posts = x.ToList()\n                   });\n\n        result.IsSuccess(list);\n        return result;\n    });\n}\n```\n\n这个逻辑和分页查询文章列表是差不多的，联合查询文章表和分类表，关联字段为CategoryId，指定查询条件`categories.DisplayName==name`，以CreationTime倒序排序，年份分组，筛选出所需字段返回，在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 通过分类名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"posts/category\")]\npublic async Task<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByCategoryAsync([Required] string name)\n{\n    return await _blogService.QueryPostsByCategoryAsync(name);\n}\n```\n\n![8](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200531220321132-1666394468.png)\n\n## 标签名称&文章列表\n\n![9](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202005/891843-20200531204717274-1679439636.png)\n\n分析：此页面和分类页一样，包含两个接口，查询标签的名称和当前标签下的文章列表。\n\n### 标签名称\n\n添加获取标签名称接口和缓存接口，`GetTagAsync()`。\n\n```CSharp\n//IBlogService.Tag.cs\n/// <summary>\n/// 获取标签名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\nTask<ServiceResult<string>> GetTagAsync(string name);\n```\n\n```CSharp\n//IBlogCacheService.Tag.cs\n/// <summary>\n/// 获取标签名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <param name=\"factory\"></param>\n/// <returns></returns>\nTask<ServiceResult<string>> GetTagAsync(string name, Func<Task<ServiceResult<string>>> factory);\n```\n\n实现这两个接口。\n\n```CSharp\n//BlogCacheService.Tag.cs\n...\n    public partial class BlogCacheService\n    {\n        private const string KEY_GetTag = \"Blog:Tag:GetTag-{0}\";\n\n        /// <summary>\n        /// 获取标签名称\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<string>> GetTagAsync(string name, Func<Task<ServiceResult<string>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_GetTag.FormatWith(name), factory, CacheStrategy.ONE_DAY);\n        }\n    }\n...\n```\n\n```CSharp\n//BlogService.Tag.cs\n/// <summary>\n/// 获取标签名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<string>> GetTagAsync(string name)\n{\n    return await _blogCacheService.GetTagAsync(name, async () =>\n    {\n        var result = new ServiceResult<string>();\n\n        var tag = await _tagRepository.FindAsync(x => x.DisplayName.Equals(name));\n        if (null == tag)\n        {\n            result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"标签\", name));\n            return result;\n        }\n\n        result.IsSuccess(tag.TagName);\n        return result;\n    });\n}\n```\n\n`FormatWith()`是扩展方法，`ResponseText.WHAT_NOT_EXIST`是之前说过的常量，直接查询是否存在当前name的分类，如果不存在给出错误提示，存在的话，则只返回分类名称，在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 获取标签名称\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"tag\")]\npublic async Task<ServiceResult<string>> GetTagAsync(string name)\n{\n    return await _blogService.GetTagAsync(name);\n}\n```\n\n`[Required]`Attribute 指定参数name必填。\n\n![10](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200601160443559-1169185098.png)\n\n![11](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200601160449415-1542518908.png)\n\n### 文章列表\n\n和上面一模一样的，添加通过标签名称查询文章列表接口和缓存接口。\n\n```CSharp\n//IBlogService.Post.cs\n/// <summary>\n/// 通过标签名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByTagAsync(string name);\n```\n\n```CSharp\n//IBlogCacheService.Post.cs\n/// <summary>\n/// 通过标签名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <param name=\"factory\"></param>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByTagAsync(string name, Func<Task<ServiceResult<IEnumerable<QueryPostDto>>>> factory);\n```\n\n分别实现这两个接口。\n\n```CSharp\n//BlogCacheService.Post.cs\n...\n    public partial class BlogCacheService\n    {\n        private const string KEY_QueryPostsByTag = \"Blog:Post:QueryPostsByTag-{0}\";\n\n        /// <summary>\n        /// 通过标签名称查询文章列表\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByTagAsync(string name, Func<Task<ServiceResult<IEnumerable<QueryPostDto>>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_QueryPostsByTag.FormatWith(name), factory, CacheStrategy.ONE_DAY);\n        }\n    }\n...\n```\n\n```CSharp\n//BlogService.Post.cs\n/// <summary>\n/// 通过标签名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByTagAsync(string name)\n{\n    return await _blogCacheService.QueryPostsByTagAsync(name, async () =>\n    {\n        var result = new ServiceResult<IEnumerable<QueryPostDto>>();\n\n        var list = (from post_tags in await _postTagRepository.GetListAsync()\n                    join tags in await _tagRepository.GetListAsync()\n                    on post_tags.TagId equals tags.Id\n                    join posts in await _postRepository.GetListAsync()\n                    on post_tags.PostId equals posts.Id\n                    where tags.DisplayName.Equals(name)\n                    orderby posts.CreationTime descending\n                    select new PostBriefDto\n                    {\n                        Title = posts.Title,\n                        Url = posts.Url,\n                        Year = posts.CreationTime.Year,\n                        CreationTime = posts.CreationTime.TryToDateTime()\n                    })\n                    .GroupBy(x => x.Year)\n                    .Select(x => new QueryPostDto\n                    {\n                        Year = x.Key,\n                        Posts = x.ToList()\n                    });\n\n        result.IsSuccess(list);\n        return result;\n    });\n}\n```\n\n这个查询有点特殊，联合查询了3张表，先查post_tags和tags，关联字段TagId，再根据PostId查询posts，指定查询条件tags.DisplayName==name，以CreationTime倒序排序，年份分组，筛选出所需字段返回，在BlogController中添加API。\n\n```CSharp\n/// <summary>\n/// 通过标签名称查询文章列表\n/// </summary>\n/// <param name=\"name\"></param>\n/// <returns></returns>\n[HttpGet]\n[Route(\"posts/tag\")]\npublic async Task<ServiceResult<IEnumerable<QueryPostDto>>> QueryPostsByTagAsync(string name)\n{\n    return await _blogService.QueryPostsByTagAsync(name);\n}\n```\n\n![12](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200601163237731-1951619840.png)\n\n至此，基本上完成了博客前端所需的所有查询接口，就还剩下友链的查询，大家可以自己完成，后面如果需要什么新的接口再回头来写就好了。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "WebApi"
    ],
    "createdAt": "2020-06-03 08:23:03"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）",
    "author": "阿星Plus",
    "url": "2020-06-05-blog_18",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://www.cnblogs.com/meowv/p/12896177.html)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://www.cnblogs.com/meowv/p/12896898.html)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://www.cnblogs.com/meowv/p/12909558.html)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://www.cnblogs.com/meowv/p/12913676.html)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://www.cnblogs.com/meowv/p/12916613.html)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://www.cnblogs.com/meowv/p/12924409.html)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://www.cnblogs.com/meowv/p/12924859.html)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://www.cnblogs.com/meowv/p/12935693.html)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://www.cnblogs.com/meowv/p/12943699.html)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://www.cnblogs.com/meowv/p/12956696.html)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://www.cnblogs.com/meowv/p/12961014.html)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://www.cnblogs.com/meowv/p/12966092.html)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://www.cnblogs.com/meowv/p/12971041.html)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://www.cnblogs.com/meowv/p/12974439.html)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://www.cnblogs.com/meowv/p/12980301.html)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://www.cnblogs.com/meowv/p/12987623.html)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://www.cnblogs.com/meowv/p/12994914.html)**\n\n---\n\n上篇文章完成了分类和标签页面相关的共6个接口，本篇继续来写博客增删改查API的业务。\n\n供前端查询用的接口还剩下一个，这里先补上。\n\n## 友链列表\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200601170002317-1723090056.png)\n\n分析：返回标题和对应的链接即可，传输对象`FriendLinkDto.cs`。\n\n```CSharp\n//FriendLinkDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class FriendLinkDto\n    {\n        /// <summary>\n        /// 标题\n        /// </summary>\n        public string Title { get; set; }\n\n        /// <summary>\n        /// 链接\n        /// </summary>\n        public string LinkUrl { get; set; }\n    }\n}\n```\n\n添加查询友链列表接口和缓存接口。\n\n```CSharp\n//IBlogService.FriendLink.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog\n{\n    public partial interface IBlogService\n    {\n        /// <summary>\n        /// 查询友链列表\n        /// </summary>\n        /// <returns></returns>\n        Task<ServiceResult<IEnumerable<FriendLinkDto>>> QueryFriendLinksAsync();\n    }\n}\n```\n\n```CSharp\n//IBlogCacheService.FriendLink.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Caching.Blog\n{\n    public partial interface IBlogCacheService\n    {\n        /// <summary>\n        /// 查询友链列表\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<IEnumerable<FriendLinkDto>>> QueryFriendLinksAsync(Func<Task<ServiceResult<IEnumerable<FriendLinkDto>>>> factory);\n    }\n}\n```\n\n接下来，实现他们。\n\n```CSharp\n//BlogCacheService.FriendLink.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogConsts;\n\nnamespace Meowv.Blog.Application.Caching.Blog.Impl\n{\n    public partial class BlogCacheService\n    {\n        private const string KEY_QueryFriendLinks = \"Blog:FriendLink:QueryFriendLinks\";\n\n        /// <summary>\n        /// 查询友链列表\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<FriendLinkDto>>> QueryFriendLinksAsync(Func<Task<ServiceResult<IEnumerable<FriendLinkDto>>>> factory)\n        {\n            return await Cache.GetOrAddAsync(KEY_QueryFriendLinks, factory, CacheStrategy.ONE_DAY);\n        }\n    }\n}\n```\n\n```CSharp\n//BlogService.FriendLink.cs\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.Domain.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog.Impl\n{\n    public partial class BlogService\n    {\n        /// <summary>\n        /// 查询友链列表\n        /// </summary>\n        /// <returns></returns>\n        public async Task<ServiceResult<IEnumerable<FriendLinkDto>>> QueryFriendLinksAsync()\n        {\n            return await _blogCacheService.QueryFriendLinksAsync(async () =>\n            {\n                var result = new ServiceResult<IEnumerable<FriendLinkDto>>();\n\n                var friendLinks = await _friendLinksRepository.GetListAsync();\n                var list = ObjectMapper.Map<IEnumerable<FriendLink>, IEnumerable<FriendLinkDto>>(friendLinks);\n\n                result.IsSuccess(list);\n                return result;\n            });\n        }\n    }\n}\n```\n\n直接查询所有的友链数据，这里使用前面讲到的AutoMapper处理对象映射，将`IEnumerable<FriendLink>`转换为`IEnumerable<FriendLinkDto>`。\n\n在`MeowvBlogAutoMapperProfile.cs`中添加一条配置：`CreateMap<FriendLink, FriendLinkDto>();`，在`BlogController`中添加API。\n\n```CSharp\n/// <summary>\n/// 查询友链列表\n/// </summary>\n/// <returns></returns>\n[HttpGet]\n[Route(\"friendlinks\")]\npublic async Task<ServiceResult<IEnumerable<FriendLinkDto>>> QueryFriendLinksAsync()\n{\n    return await _blogService.QueryFriendLinksAsync();\n}\n```\n\n编译运行，打开查询友链的API，此时没数据，手动添加几条数据进去再试试吧。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200601172550001-1793416839.png)\n\n## 文章管理\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200601213047469-759323607.png)\n\n后台文章管理包含：文章列表、新增、更新、删除文章，接下来依次完成这些接口。\n\n### 文章列表\n\n这里的文章列表和前台的文章列表差不多，就是多了一个Id，以供编辑和删除使用，所以可以新建一个模型类`QueryPostForAdminDto`继承`QueryPostDto`，添加`PostBriefForAdminDto`继承`PostBriefDto`同时新增一个字段主键Id。\n\n在`QueryPostForAdminDto`中隐藏基类成员`Posts`，使用新的接收类型：`IEnumerable<PostBriefForAdminDto>`。\n\n```CSharp\n//PostBriefForAdminDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class PostBriefForAdminDto : PostBriefDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```CSharp\n//QueryPostForAdminDto.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryPostForAdminDto : QueryPostDto\n    {\n        /// <summary>\n        /// Posts\n        /// </summary>\n        public new IEnumerable<PostBriefForAdminDto> Posts { get; set; }\n    }\n}\n```\n\n添加分页查询文章列表的接口：`QueryPostsForAdminAsync()`，关于后台的一些接口就不添加缓存了。\n\n```CSharp\n//IBlogService.Admin.cs\nusing Meowv.Blog.Application.Contracts;\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog\n{\n    public partial interface IBlogService\n    {\n        /// <summary>\n        /// 分页查询文章列表\n        /// </summary>\n        /// <param name=\"input\"></param>\n        /// <returns></returns>\n        Task<ServiceResult<PagedList<QueryPostForAdminDto>>> QueryPostsForAdminAsync(PagingInput input);\n    }\n}\n```\n\n然后实现这个接口。\n\n```CSharp\n//BlogService.Admin.cs\nusing Meowv.Blog.Application.Contracts;\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing Meowv.Blog.ToolKits.Extensions;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.Application.Blog.Impl\n{\n    public partial class BlogService\n    {\n        /// <summary>\n        /// 分页查询文章列表\n        /// </summary>\n        /// <param name=\"input\"></param>\n        /// <returns></returns>\n        public async Task<ServiceResult<PagedList<QueryPostForAdminDto>>> QueryPostsForAdminAsync(PagingInput input)\n        {\n            var result = new ServiceResult<PagedList<QueryPostForAdminDto>>();\n\n            var count = await _postRepository.GetCountAsync();\n\n            var list = _postRepository.OrderByDescending(x => x.CreationTime)\n                                      .PageByIndex(input.Page, input.Limit)\n                                      .Select(x => new PostBriefForAdminDto\n                                      {\n                                          Id = x.Id,\n                                          Title = x.Title,\n                                          Url = x.Url,\n                                          Year = x.CreationTime.Year,\n                                          CreationTime = x.CreationTime.TryToDateTime()\n                                      })\n                                      .GroupBy(x => x.Year)\n                                      .Select(x => new QueryPostForAdminDto\n                                      {\n                                          Year = x.Key,\n                                          Posts = x.ToList()\n                                      }).ToList();\n\n            result.IsSuccess(new PagedList<QueryPostForAdminDto>(count.TryToInt(), list));\n            return result;\n        }\n    }\n}\n```\n\n实现逻辑也非常简单和之前一样，就是在`Select`的时候多了一个`Id`，添加一个新的Controller：`BlogController.Admin.cs`，添加这个接口。\n\n```CSharp\n//BlogController.Admin.cs\nusing Meowv.Blog.Application.Contracts;\nusing Meowv.Blog.Application.Contracts.Blog;\nusing Meowv.Blog.ToolKits.Base;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Threading.Tasks;\nusing static Meowv.Blog.Domain.Shared.MeowvBlogConsts;\n\nnamespace Meowv.Blog.HttpApi.Controllers\n{\n    public partial class BlogController\n    {\n        /// <summary>\n        /// 分页查询文章列表\n        /// </summary>\n        /// <param name=\"input\"></param>\n        /// <returns></returns>\n        [HttpGet]\n        [Authorize]\n        [Route(\"admin/posts\")]\n        [ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\n        public async Task<ServiceResult<PagedList<QueryPostForAdminDto>>> QueryPostsForAdminAsync([FromQuery] PagingInput input)\n        {\n            return await _blogService.QueryPostsForAdminAsync(input);\n        }\n    }\n}\n```\n\n因为是后台的接口，所以加上`AuthorizeAttribute`，指定接口组为`GroupName_v2`，参数方式为`[FromQuery]`。\n\n当没有进行授权的时候，是无法访问接口的。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200602101442280-748284116.png)\n\n### 新增文章\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200602102546980-1951417062.png)\n\n在做新增文章的时候要注意几点，不是单纯的添加文章数据就结束了，要指定文章分类，添加文章的标签。添加标签我这里是从标签库中去取得数据，只存标签Id，所以添加标签的时候就可能存在添加了标签库中已有的标签。\n\n新建一个新增和更新文章的通用输出参数模型类，起名：`EditPostInput`，继承`PostDto`，然后添加标签Tags字段，返回类型`IEnumerable<string>`。\n\n```CSharp\n//EditPostInput.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.Application.Contracts.Blog.Params\n{\n    public class EditPostInput : PostDto\n    {\n        /// <summary>\n        /// 标签列表\n        /// </summary>\n        public IEnumerable<string> Tags { get; set; }\n    }\n}\n```\n\n添加新增文章的接口：`InsertPostAsync`。\n\n```CSharp\n/// <summary>\n/// 新增文章\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> InsertPostAsync(EditPostInput input);\n```\n\n然后去实现这个接口，实现之前，配置AutoMapper实体映射。\n\n```CSharp\nCreateMap<EditPostInput, Post>().ForMember(x => x.Id, opt => opt.Ignore());\n```\n\n将`EditPostInput`转换为`Post`，并且忽略`Id`字段。\n\n```CSharp\n/// <summary>\n/// 新增文章\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> InsertPostAsync(EditPostInput input)\n{\n    var result = new ServiceResult();\n\n    var post = ObjectMapper.Map<EditPostInput, Post>(input);\n    post.Url = $\"{post.CreationTime.ToString(\" yyyy MM dd \").Replace(\" \", \"/\")}{post.Url}/\";\n    await _postRepository.InsertAsync(post);\n\n    var tags = await _tagRepository.GetListAsync();\n\n    var newTags = input.Tags\n                       .Where(item => !tags.Any(x => x.TagName.Equals(item)))\n                       .Select(item => new Tag\n                       {\n                           TagName = item,\n                           DisplayName = item\n                       });\n    await _tagRepository.BulkInsertAsync(newTags);\n\n    var postTags = input.Tags.Select(item => new PostTag\n    {\n        PostId = post.Id,\n        TagId = _tagRepository.FirstOrDefault(x => x.TagName == item).Id\n    });\n    await _postTagRepository.BulkInsertAsync(postTags);\n\n    result.IsSuccess(ResponseText.INSERT_SUCCESS);\n    return result;\n}\n```\n\nURL字段，根据创建时间按照`yyyy/MM/dd/name/`格式拼接。\n\n然后找出是否有新标签，有的话批量添加至标签表。\n\n再根据`input.Tags`构建`PostTag`列表，也进行批量保存，这样才算是新增好一篇文章，最后输出`ResponseText.INSERT_SUCCESS`常量，提示成功。\n\n在`BlogController.Admin.cs`添加API。\n\n```CSharp\n/// <summary>\n/// 新增文章\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPost]\n[Authorize]\n[Route(\"post\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> InsertPostAsync([FromBody] EditPostInput input)\n{\n    return await _blogService.InsertPostAsync(input);\n}\n```\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200602112430082-1494392218.png)\n\n### 更新文章\n\n更新操作和新增操作输入参数一样，只新增一个Id用来标识更新那篇文章，添加`UpdatePostAsync`更新文章接口。\n\n```CSharp\n/// <summary>\n/// 更新文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> UpdatePostAsync(int id, EditPostInput input);\n```\n\n同样的实现这个接口。\n\n```CSharp\n/// <summary>\n/// 更新文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> UpdatePostAsync(int id, EditPostInput input)\n{\n    var result = new ServiceResult();\n\n    var post = await _postRepository.GetAsync(id);\n    post.Title = input.Title;\n    post.Author = input.Author;\n    post.Url = $\"{input.CreationTime.ToString(\" yyyy MM dd \").Replace(\" \", \"/\")}{input.Url}/\";\n    post.Html = input.Html;\n    post.Markdown = input.Markdown;\n    post.CreationTime = input.CreationTime;\n    post.CategoryId = input.CategoryId;\n\n    await _postRepository.UpdateAsync(post);\n\n    var tags = await _tagRepository.GetListAsync();\n\n    var oldPostTags = from post_tags in await _postTagRepository.GetListAsync()\n                      join tag in await _tagRepository.GetListAsync()\n                      on post_tags.TagId equals tag.Id\n                      where post_tags.PostId.Equals(post.Id)\n                      select new\n                      {\n                          post_tags.Id,\n                          tag.TagName\n                      };\n\n    var removedIds = oldPostTags.Where(item => !input.Tags.Any(x => x == item.TagName) &&\n                                               tags.Any(t => t.TagName == item.TagName))\n                                .Select(item => item.Id);\n    await _postTagRepository.DeleteAsync(x => removedIds.Contains(x.Id));\n\n    var newTags = input.Tags\n                       .Where(item => !tags.Any(x => x.TagName == item))\n                       .Select(item => new Tag\n                       {\n                           TagName = item,\n                           DisplayName = item\n                       });\n    await _tagRepository.BulkInsertAsync(newTags);\n\n    var postTags = input.Tags\n                        .Where(item => !oldPostTags.Any(x => x.TagName == item))\n                        .Select(item => new PostTag\n                        {\n                            PostId = id,\n                            TagId = _tagRepository.FirstOrDefault(x => x.TagName == item).Id\n                        });\n    await _postTagRepository.BulkInsertAsync(postTags);\n\n    result.IsSuccess(ResponseText.UPDATE_SUCCESS);\n    return result;\n}\n```\n\n`ResponseText.UPDATE_SUCCESS`是常量更新成功。\n\n先根据Id查询到数据库中的这篇文章数据，然后根据input参数，修改需要修改的数据，最后保存。\n\n注意的是，如果修改的时候修改了标签，有可能新增也有可能删除，也许会又有新增又有删除。\n\n这时候就需要注意，这里做了一个比较通用的方法，找到数据库中当前文章Id的所有Tags，然后根据参数`input.Tags`可以找出被删掉的标签的PostTags的Id，调用删除方法删掉即可，同时也可以获取到新增的标签，批量进行保存。\n\n完成上面操作后，才保存新加标签与文章对应的数据，最后提示更新成功，在`BlogController.Admin`添加API。\n\n```CSharp\n/// <summary>\n/// 更新文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPut]\n[Authorize]\n[Route(\"post\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> UpdatePostAsync([Required] int id, [FromBody] EditPostInput input)\n{\n    return await _blogService.UpdatePostAsync(id, input);\n}\n```\n\n`[HttpPut]`指定请求方式为`put`请求，一般需要修改用put，添加用post。\n\n`[Required]`指定参数id必填且是FromQuery的方式，input为`[FromBody]`。\n\n更新一下上面新增的数据试试。\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200602221038444-846665879.png)\n\n![8](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200602221351347-498118468.png)\n\n### 删除文章\n\n删除相对来说就非常简单了，一般删除都会做逻辑删除，就是避免某些手残删除了，有找回的余地，我们这里就直接Delete了，也没什么重要数据。\n\n添加接口：`DeletePostAsync`。\n\n```CSharp\n/// <summary>\n/// 删除文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nTask<ServiceResult> DeletePostAsync(int id);\n```\n\n实现接口。\n\n```CSharp\n/// <summary>\n/// 删除文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> DeletePostAsync(int id)\n{\n    var result = new ServiceResult();\n\n    var post = await _postRepository.GetAsync(id);\n    if (null == post)\n    {\n        result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"Id\", id));\n        return result;\n    }\n\n    await _postRepository.DeleteAsync(id);\n    await _postTagRepository.DeleteAsync(x => x.PostId == id);\n\n    result.IsSuccess(ResponseText.DELETE_SUCCESS);\n    return result;\n}\n```\n\n删除的时候同样去查询一下数据，来判断是否存在。\n\n`ResponseText.DELETE_SUCCESS`是添加的常量删除成功，删除成功同时也要将post_tags表的标签对应关系也干掉才算完整，在BlogController.Admin添加API。\n\n```CSharp\n/// <summary>\n/// 删除文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\n[HttpDelete]\n[Authorize]\n[Route(\"post\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> DeletePostAsync([Required] int id)\n{\n    return await _blogService.DeletePostAsync(id);\n}\n```\n\n`[HttpDelete]`指定请求方式是删除资源，`[Required]`指定参数Id必填。\n\n删掉上面添加的文章看看效果。\n\n![9](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200602223007548-1633020549.png)\n\n至此，完成了博客文章的增删改接口，未完待续...\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "WebApi"
    ],
    "createdAt": "2020-06-05 08:47:05"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）",
    "author": "阿星Plus",
    "url": "2020-06-06-blog_19",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://www.cnblogs.com/meowv/p/12896177.html)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://www.cnblogs.com/meowv/p/12896898.html)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://www.cnblogs.com/meowv/p/12909558.html)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://www.cnblogs.com/meowv/p/12913676.html)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://www.cnblogs.com/meowv/p/12916613.html)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://www.cnblogs.com/meowv/p/12924409.html)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://www.cnblogs.com/meowv/p/12924859.html)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://www.cnblogs.com/meowv/p/12935693.html)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://www.cnblogs.com/meowv/p/12943699.html)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://www.cnblogs.com/meowv/p/12956696.html)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://www.cnblogs.com/meowv/p/12961014.html)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://www.cnblogs.com/meowv/p/12966092.html)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://www.cnblogs.com/meowv/p/12971041.html)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://www.cnblogs.com/meowv/p/12974439.html)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://www.cnblogs.com/meowv/p/12980301.html)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://www.cnblogs.com/meowv/p/12987623.html)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://www.cnblogs.com/meowv/p/12994914.html)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://www.cnblogs.com/meowv/p/13039883.html)**\n\n---\n\n上篇文章完成了文章增删改的接口和友情链接列表的接口，本篇继续。\n\n善于思考的同学肯定发现，在执行增删改操作后，Redis缓存中的数据还是存在的，也就意味着查询接口返回的数据还是旧的，所以在写接口之前，先完成一下清缓存的操作。\n\n## 移除缓存\n\n移除缓存我这里找了一个新的包：`Caching.CSRedis`，选他是因为微软的包`Microsoft.Extensions.Caching.StackExchangeRedis`没有给我们实现批量删除的功能。\n\n`Caching.CSRedis`开源地址，https://github.com/2881099/csredis 在这不做过多介绍，感兴趣的自己去看。\n\n在`.Application.Caching`层添加包`Caching.CSRedis`，`Install-Package Caching.CSRedis`，然后在模块类`MeowvBlogApplicationCachingModule`中进行配置。\n\n```CSharp\n//MeowvBlogApplicationCachingModule.cs\n...\npublic override void ConfigureServices(ServiceConfigurationContext context)\n{\n    ...\n\n    var csredis = new CSRedis.CSRedisClient(AppSettings.Caching.RedisConnectionString);\n    RedisHelper.Initialization(csredis);\n\n    context.Services.AddSingleton<IDistributedCache>(new CSRedisCache(RedisHelper.Instance));\n}\n...\n```\n\n直接新建一个移除缓存的接口：`ICacheRemoveService`，添加移除缓存的方法`RemoveAsync()`。代码较少，可以直接写在缓存基类`CachingServiceBase`中。\n\n```CSharp\npublic interface ICacheRemoveService\n{\n    /// <summary>\n    /// 移除缓存\n    /// </summary>\n    /// <param name=\"key\"></param>\n    /// <param name=\"cursor\"></param>\n    /// <returns></returns>\n    Task RemoveAsync(string key, int cursor = 0);\n}\n```\n\n然后可以在基类中实现这个接口。\n\n```CSharp\npublic async Task RemoveAsync(string key, int cursor = 0)\n{\n    var scan = await RedisHelper.ScanAsync(cursor);\n    var keys = scan.Items;\n\n    if (keys.Any() && key.IsNotNullOrEmpty())\n    {\n        keys = keys.Where(x => x.StartsWith(key)).ToArray();\n\n        await RedisHelper.DelAsync(keys);\n    }\n}\n```\n\n简单说一下这个操作过程，使用`ScanAsync()`获取到所有的Redis key值，返回的是一个string数组，然后根据参数找到符合此前缀的所有key，最后调用`DelAsync(keys)`删除缓存。\n\n在需要有移除缓存功能的接口上继承`ICacheRemoveService`，这里就是`IBlogCacheService`。\n\n```CSharp\n//IBlogCacheService.cs\nnamespace Meowv.Blog.Application.Caching.Blog\n{\n    public partial interface IBlogCacheService : ICacheRemoveService\n    {\n    }\n}\n```\n\n在基类中已经实现了这个接口，所以现在所有继承基类的缓存实现类都可以调用移除缓存方法了。\n\n在`MeowvBlogConsts`中添加缓存前缀的常量。\n\n```CSharp\n//MeowvBlogConsts.cs\n/// <summary>\n/// 缓存前缀\n/// </summary>\npublic static class CachePrefix\n{\n    public const string Authorize = \"Authorize\";\n\n    public const string Blog = \"Blog\";\n\n    public const string Blog_Post = Blog + \":Post\";\n\n    public const string Blog_Tag = Blog + \":Tag\";\n\n    public const string Blog_Category = Blog + \":Category\";\n\n    public const string Blog_FriendLink = Blog + \":FriendLink\";\n}\n```\n\n然后在`BlogService.Admin.cs`服务执行增删改后调用移除缓存的方法。\n\n```CSharp\n//BlogService.Admin.cs\n\n// 执行清除缓存操作\nawait _blogCacheService.RemoveAsync(CachePrefix.Blog_Post);\n```\n\n因为是小项目，采用这种策略直接删除缓存，这样就搞定了当在执行增删改操作后，前台接口可以实时查询出最后的结果。\n\n## 文章详情\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200604135933251-1454347843.png)\n\n当我们修改文章数据的时候，是需要把当前数据库中的数据带出来显示在界面上的，因为有可能只是个别地方需要修改，所以这还需要一个查询文章详情的接口，当然这里的详情和前端的是不一样的，这里是需要根据Id主键去查询。\n\n添加模型类`PostForAdminDto.cs`，直接继承`PostDto`，然后添加一个Tags列表就行，==，好像和上一篇文章中的`EditPostInput`字段是一模一样的。顺手将`EditPostInput`改一下吧，具体代码如下：\n\n```CSharp\n//PostForAdminDto.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class PostForAdminDto : PostDto\n    {\n        /// <summary>\n        /// 标签列表\n        /// </summary>\n        public IEnumerable<string> Tags { get; set; }\n    }\n}\n\n//EditPostInput.cs\nnamespace Meowv.Blog.Application.Contracts.Blog.Params\n{\n    public class EditPostInput : PostForAdminDto\n    {\n    }\n}\n```\n\n在`IBlogService.Admin.cs`中添加接口。\n\n```CSharp\n/// <summary>\n/// 获取文章详情\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nTask<ServiceResult<PostForAdminDto>> GetPostForAdminAsync(int id);\n```\n\n实现这个接口。\n\n```CSharp\n/// <summary>\n/// 获取文章详情\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<PostForAdminDto>> GetPostForAdminAsync(int id)\n{\n    var result = new ServiceResult<PostForAdminDto>();\n\n    var post = await _postRepository.GetAsync(id);\n\n    var tags = from post_tags in await _postTagRepository.GetListAsync()\n               join tag in await _tagRepository.GetListAsync()\n               on post_tags.TagId equals tag.Id\n               where post_tags.PostId.Equals(post.Id)\n               select tag.TagName;\n\n    var detail = ObjectMapper.Map<Post, PostForAdminDto>(post);\n    detail.Tags = tags;\n    detail.Url = post.Url.Split(\"/\").Where(x => !string.IsNullOrEmpty(x)).Last();\n\n    result.IsSuccess(detail);\n    return result;\n}\n```\n\n先根据Id查出文章数据，再通过联合查询找出标签数据。\n\n```CSharp\nCreateMap<Post, PostForAdminDto>().ForMember(x => x.Tags, opt => opt.Ignore());\n```\n\n新建一条AutoMapper配置，将`Post`转换成`PostForAdminDto`，忽略Tags。\n\n然后将查出来的标签、Url赋值给DTO，输出即可。在`BlogController.Admin`中添加API。\n\n```CSharp\n/// <summary>\n/// 获取文章详情\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\n[HttpGet]\n[Authorize]\n[Route(\"admin/post\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult<PostForAdminDto>> GetPostForAdminAsync([Required] int id)\n{\n    return await _blogService.GetPostForAdminAsync(id);\n}\n```\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200604144612021-1493627466.png)\n\n至此，完成了关于文章的所有接口。\n\n接下来按照以上方式依次完成分类、标签、友链的增删改查接口，我觉得如果你有跟着我一起做，剩下的可以自己完成。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "WebApi"
    ],
    "createdAt": "2020-06-06 09:21:06"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）",
    "author": "阿星Plus",
    "url": "2020-06-08-blog_20",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://www.cnblogs.com/meowv/p/12896177.html)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://www.cnblogs.com/meowv/p/12896898.html)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://www.cnblogs.com/meowv/p/12909558.html)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://www.cnblogs.com/meowv/p/12913676.html)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://www.cnblogs.com/meowv/p/12916613.html)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://www.cnblogs.com/meowv/p/12924409.html)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://www.cnblogs.com/meowv/p/12924859.html)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://www.cnblogs.com/meowv/p/12935693.html)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://www.cnblogs.com/meowv/p/12943699.html)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://www.cnblogs.com/meowv/p/12956696.html)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://www.cnblogs.com/meowv/p/12961014.html)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://www.cnblogs.com/meowv/p/12966092.html)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://www.cnblogs.com/meowv/p/12971041.html)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://www.cnblogs.com/meowv/p/12974439.html)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://www.cnblogs.com/meowv/p/12980301.html)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://www.cnblogs.com/meowv/p/12987623.html)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://www.cnblogs.com/meowv/p/12994914.html)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://www.cnblogs.com/meowv/p/13039883.html)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://www.cnblogs.com/meowv/p/13043084.html)**\n\n---\n\n上篇文章完成了文章详情页数据查询和清除缓存的功能。\n\n本篇继续完成分类、标签、友情链接的后台操作接口，还是那句话，这些纯CRUD的内容，建议还是自己动手完成比较好，本篇将不再啰嗦，直接贴代码，以供参考。\n\n## 分类\n\n添加接口：查询分类列表`QueryCategoriesForAdminAsync()`、新增分类`InsertCategoryAsync(...)`、更新分类`UpdateCategoryAsync(...)`、删除分类`DeleteCategoryAsync(...)`\n\n```CSharp\n#region Categories\n\n/// <summary>\n/// 查询分类列表\n/// </summary>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> QueryCategoriesForAdminAsync();\n\n/// <summary>\n/// 新增分类\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> InsertCategoryAsync(EditCategoryInput input);\n\n/// <summary>\n/// 更新分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> UpdateCategoryAsync(int id, EditCategoryInput input);\n\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nTask<ServiceResult> DeleteCategoryAsync(int id);\n\n#endregion Categories\n```\n\n查询分类列表需要返回的模型类`QueryCategoryForAdminDto.cs`。\n\n```CSharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n新增分类和更新分类需要的输入参数`EditCategoryInput.cs`，直接继承`CategoryDto`即可。\n\n```CSharp\n//EditCategoryInput.cs\nnamespace Meowv.Blog.Application.Contracts.Blog.Params\n{\n    public class EditCategoryInput : CategoryDto\n    {\n    }\n}\n```\n\n分别实现这几个接口。\n\n```CSharp\n/// <summary>\n/// 查询分类列表\n/// </summary>\n/// <returns></returns>\npublic async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> QueryCategoriesForAdminAsync()\n{\n    var result = new ServiceResult<IEnumerable<QueryCategoryForAdminDto>>();\n\n    var posts = await _postRepository.GetListAsync();\n\n    var categories = _categoryRepository.GetListAsync().Result.Select(x => new QueryCategoryForAdminDto\n    {\n        Id = x.Id,\n        CategoryName = x.CategoryName,\n        DisplayName = x.DisplayName,\n        Count = posts.Count(p => p.CategoryId == x.Id)\n    });\n\n    result.IsSuccess(categories);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 新增分类\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> InsertCategoryAsync(EditCategoryInput input)\n{\n    var result = new ServiceResult();\n\n    var category = ObjectMapper.Map<EditCategoryInput, Category>(input);\n    await _categoryRepository.InsertAsync(category);\n\n    result.IsSuccess(ResponseText.INSERT_SUCCESS);\n    return result;\n}\n```\n\n这里需要一条AutoMapper配置，将`EditCategoryInput`转换为`Category`，忽略Id字段。\n\n```CSharp\nCreateMap<EditCategoryInput, Category>().ForMember(x => x.Id, opt => opt.Ignore());\n```\n\n```CSharp\n/// <summary>\n/// 更新分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> UpdateCategoryAsync(int id, EditCategoryInput input)\n{\n    var result = new ServiceResult();\n\n    var category = await _categoryRepository.GetAsync(id);\n    category.CategoryName = input.CategoryName;\n    category.DisplayName = input.DisplayName;\n\n    await _categoryRepository.UpdateAsync(category);\n\n    result.IsSuccess(ResponseText.UPDATE_SUCCESS);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> DeleteCategoryAsync(int id)\n{\n    var result = new ServiceResult();\n\n    var category = await _categoryRepository.FindAsync(id);\n    if (null == category)\n    {\n        result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"Id\", id));\n        return result;\n    }\n\n    await _categoryRepository.DeleteAsync(id);\n\n    result.IsSuccess(ResponseText.DELETE_SUCCESS);\n    return result;\n}\n```\n\n在`BlogController.Admin.cs`中添加接口。\n\n```CSharp\n#region Categories\n\n/// <summary>\n/// 查询分类列表\n/// </summary>\n/// <returns></returns>\n[HttpGet]\n[Authorize]\n[Route(\"admin/categories\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> QueryCategoriesForAdminAsync()\n{\n    return await _blogService.QueryCategoriesForAdminAsync();\n}\n\n/// <summary>\n/// 新增分类\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPost]\n[Authorize]\n[Route(\"category\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> InsertCategoryAsync([FromBody] EditCategoryInput input)\n{\n    return await _blogService.InsertCategoryAsync(input);\n}\n\n/// <summary>\n/// 更新分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPut]\n[Authorize]\n[Route(\"category\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> UpdateCategoryAsync([Required] int id, [FromBody] EditCategoryInput input)\n{\n    return await _blogService.UpdateCategoryAsync(id, input);\n}\n\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\n[HttpDelete]\n[Authorize]\n[Route(\"category\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> DeleteCategoryAsync([Required] int id)\n{\n    return await _blogService.DeleteCategoryAsync(id);\n}\n\n#endregion Categories\n```\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200605101020914-137049974.png)\n\n## 标签\n\n添加接口：查询标签列表`QueryTagsForAdminAsync()`、新增标签`InsertTagAsync(...)`、更新标签`UpdateTagAsync(...)`、删除标签`DeleteTagAsync(...)`\n\n```CSharp\n#region Tags\n\n/// <summary>\n/// 查询标签列表\n/// </summary>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryTagForAdminDto>>> QueryTagsForAdminAsync();\n\n/// <summary>\n/// 新增标签\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> InsertTagAsync(EditTagInput input);\n\n/// <summary>\n/// 更新标签\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> UpdateTagAsync(int id, EditTagInput input);\n\n/// <summary>\n/// 删除标签\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nTask<ServiceResult> DeleteTagAsync(int id);\n\n#endregion Tags\n```\n\n查询标签列表需要返回的模型类`QueryTagForAdminDto.cs`。\n\n```CSharp\n//QueryTagForAdminDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryTagForAdminDto : QueryTagDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n新增标签和更新标签需要的输入参数`EditTagInput.cs`，直接继承`TagDto`即可。\n\n```CSharp\n//EditTagInput.cs\nnamespace Meowv.Blog.Application.Contracts.Blog.Params\n{\n    public class EditTagInput : TagDto\n    {\n    }\n}\n```\n\n分别实现这几个接口。\n\n```CSharp\n/// <summary>\n/// 查询标签列表\n/// </summary>\n/// <returns></returns>\npublic async Task<ServiceResult<IEnumerable<QueryTagForAdminDto>>> QueryTagsForAdminAsync()\n{\n    var result = new ServiceResult<IEnumerable<QueryTagForAdminDto>>();\n\n    var post_tags = await _postTagRepository.GetListAsync();\n\n    var tags = _tagRepository.GetListAsync().Result.Select(x => new QueryTagForAdminDto\n    {\n        Id = x.Id,\n        TagName = x.TagName,\n        DisplayName = x.DisplayName,\n        Count = post_tags.Count(p => p.TagId == x.Id)\n    });\n\n    result.IsSuccess(tags);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 新增标签\n/// </summary>\n/// <param name=\"dto\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> InsertTagAsync(EditTagInput input)\n{\n    var result = new ServiceResult();\n\n    var tag = ObjectMapper.Map<EditTagInput, Tag>(input);\n    await _tagRepository.InsertAsync(tag);\n\n    result.IsSuccess(ResponseText.INSERT_SUCCESS);\n    return result;\n}\n```\n\n这里需要一条AutoMapper配置，将`EditCategoryInput`转换为`Tag`，忽略Id字段。\n\n```CSharp\nCreateMap<EditTagInput, Tag>().ForMember(x => x.Id, opt => opt.Ignore());\n```\n\n```CSharp\n/// <summary>\n/// 更新标签\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"dto\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> UpdateTagAsync(int id, EditTagInput input)\n{\n    var result = new ServiceResult();\n\n    var tag = await _tagRepository.GetAsync(id);\n    tag.TagName = input.TagName;\n    tag.DisplayName = input.DisplayName;\n\n    await _tagRepository.UpdateAsync(tag);\n\n    result.IsSuccess(ResponseText.UPDATE_SUCCESS);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 删除标签\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> DeleteTagAsync(int id)\n{\n    var result = new ServiceResult();\n\n    var tag = await _tagRepository.FindAsync(id);\n    if (null == tag)\n    {\n        result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"Id\", id));\n        return result;\n    }\n\n    await _tagRepository.DeleteAsync(id);\n    await _postTagRepository.DeleteAsync(x => x.TagId == id);\n\n    result.IsSuccess(ResponseText.DELETE_SUCCESS);\n    return result;\n}\n```\n\n在`BlogController.Admin.cs`中添加接口。\n\n```CSharp\n#region Tags\n\n/// <summary>\n/// 查询标签列表\n/// </summary>\n/// <returns></returns>\n[HttpGet]\n[Authorize]\n[Route(\"admin/tags\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult<IEnumerable<QueryTagForAdminDto>>> QueryTagsForAdminAsync()\n{\n    return await _blogService.QueryTagsForAdminAsync();\n}\n\n/// <summary>\n/// 新增标签\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPost]\n[Authorize]\n[Route(\"tag\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> InsertTagAsync([FromBody] EditTagInput input)\n{\n    return await _blogService.InsertTagAsync(input);\n}\n\n/// <summary>\n/// 更新标签\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPut]\n[Authorize]\n[Route(\"tag\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> UpdateTagAsync([Required] int id, [FromBody] EditTagInput input)\n{\n    return await _blogService.UpdateTagAsync(id, input);\n}\n\n/// <summary>\n/// 删除标签\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\n[HttpDelete]\n[Authorize]\n[Route(\"tag\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> DeleteTagAsync([Required] int id)\n{\n    return await _blogService.DeleteTagAsync(id);\n}\n\n#endregion Tags\n```\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200605101101841-106276175.png)\n\n## 友链\n\n添加接口：查询友链列表`QueryFriendLinksForAdminAsync()`、新增友链`InsertFriendLinkAsync(...)`、更新友链`UpdateFriendLinkAsync(...)`、删除友链`DeleteFriendLinkAsync(...)`\n\n```CSharp\n#region FriendLinks\n\n/// <summary>\n/// 查询友链列表\n/// </summary>\n/// <returns></returns>\nTask<ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>>> QueryFriendLinksForAdminAsync();\n\n/// <summary>\n/// 新增友链\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> InsertFriendLinkAsync(EditFriendLinkInput input);\n\n/// <summary>\n/// 更新友链\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\nTask<ServiceResult> UpdateFriendLinkAsync(int id, EditFriendLinkInput input);\n\n/// <summary>\n/// 删除友链\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nTask<ServiceResult> DeleteFriendLinkAsync(int id);\n\n#endregion FriendLinks\n```\n\n查询友链列表需要返回的模型类`QueryFriendLinkForAdminDto.cs`。\n\n```CSharp\n//QueryFriendLinkForAdminDto.cs\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class QueryFriendLinkForAdminDto : FriendLinkDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n新增友链和更新友链需要的输入参数`EditFriendLinkInput.cs`，直接继承`FriendLinkDto`即可。\n\n```CSharp\n//EditFriendLinkInput .cs\nnamespace Meowv.Blog.Application.Contracts.Blog.Params\n{\n    public class EditFriendLinkInput : FriendLinkDto\n    {\n    }\n}\n```\n\n分别实现这几个接口。\n\n```CSharp\n/// <summary>\n/// 查询友链列表\n/// </summary>\n/// <returns></returns>\npublic async Task<ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>>> QueryFriendLinksForAdminAsync()\n{\n    var result = new ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>>();\n\n    var friendLinks = await _friendLinksRepository.GetListAsync();\n\n    var dto = ObjectMapper.Map<List<FriendLink>, IEnumerable<QueryFriendLinkForAdminDto>>(friendLinks);\n\n    result.IsSuccess(dto);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 新增友链\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> InsertFriendLinkAsync(EditFriendLinkInput input)\n{\n    var result = new ServiceResult();\n\n    var friendLink = ObjectMapper.Map<EditFriendLinkInput, FriendLink>(input);\n    await _friendLinksRepository.InsertAsync(friendLink);\n\n    // 执行清除缓存操作\n    await _blogCacheService.RemoveAsync(CachePrefix.Blog_FriendLink);\n\n    result.IsSuccess(ResponseText.INSERT_SUCCESS);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 更新友链\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> UpdateFriendLinkAsync(int id, EditFriendLinkInput input)\n{\n    var result = new ServiceResult();\n\n    var friendLink = await _friendLinksRepository.GetAsync(id);\n    friendLink.Title = input.Title;\n    friendLink.LinkUrl = input.LinkUrl;\n\n    await _friendLinksRepository.UpdateAsync(friendLink);\n\n    // 执行清除缓存操作\n    await _blogCacheService.RemoveAsync(CachePrefix.Blog_FriendLink);\n\n    result.IsSuccess(ResponseText.UPDATE_SUCCESS);\n    return result;\n}\n```\n\n```CSharp\n/// <summary>\n/// 删除友链\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult> DeleteFriendLinkAsync(int id)\n{\n    var result = new ServiceResult();\n\n    var friendLink = await _friendLinksRepository.FindAsync(id);\n    if (null == friendLink)\n    {\n        result.IsFailed(ResponseText.WHAT_NOT_EXIST.FormatWith(\"Id\", id));\n        return result;\n    }\n\n    await _friendLinksRepository.DeleteAsync(id);\n\n    // 执行清除缓存操作\n    await _blogCacheService.RemoveAsync(CachePrefix.Blog_FriendLink);\n\n    result.IsSuccess(ResponseText.DELETE_SUCCESS);\n    return result;\n}\n```\n\n其中查询友链列表和新增友链中有两条AutoMapper配置。\n\n```CSharp\nCreateMap<FriendLink, QueryFriendLinkForAdminDto>();\n\nCreateMap<EditFriendLinkInput, FriendLink>().ForMember(x => x.Id, opt => opt.Ignore());\n```\n\n在`BlogController.Admin.cs`中添加接口。\n\n```CSharp\n#region FriendLinks\n\n/// <summary>\n/// 查询友链列表\n/// </summary>\n/// <returns></returns>\n[HttpGet]\n[Authorize]\n[Route(\"admin/friendlinks\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>>> QueryFriendLinksForAdminAsync()\n{\n    return await _blogService.QueryFriendLinksForAdminAsync();\n}\n\n/// <summary>\n/// 新增友链\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPost]\n[Authorize]\n[Route(\"friendlink\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> InsertFriendLinkAsync([FromBody] EditFriendLinkInput input)\n{\n    return await _blogService.InsertFriendLinkAsync(input);\n}\n\n/// <summary>\n/// 更新友链\n/// </summary>\n/// <param name=\"id\"></param>\n/// <param name=\"input\"></param>\n/// <returns></returns>\n[HttpPut]\n[Authorize]\n[Route(\"friendlink\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> UpdateFriendLinkAsync([Required] int id, [FromBody] EditFriendLinkInput input)\n{\n    return await _blogService.UpdateFriendLinkAsync(id, input);\n}\n\n/// <summary>\n/// 删除友链\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\n[HttpDelete]\n[Authorize]\n[Route(\"friendlink\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult> DeleteFriendLinkAsync([Required] int id)\n{\n    return await _blogService.DeleteFriendLinkAsync(id);\n}\n\n#endregion\n```\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200605101143054-44406883.png)\n\n## Next\n\n截止本篇，**基于 abp vNext 和 .NET Core 开发博客项目** 系列的后台API部分便全部开发完成了。\n\n本博客项目系列是我一边写代码一边记录后的成果，并不是开发完成后再拿出来写的，涉及到东西也不是很多，对于新手入门来说应该是够了的，如果你从中有所收获请多多转发分享。\n\n在此，希望大家可以关注一下我的微信公众号：『**阿星Plus**』，文章将会首发在公众号中。\n\n现在有了API，大家可以选择自己熟悉的方式去开发前端界面，比如目前我博客的线上版本就是用的 ASP.NET Core Web ，感兴趣的可以去 `release` 分支查看。\n\n关于前端部分，看到有人呼吁vue，说实话前端技术不是很厉害，本职主要是后端开发，可能达不到预期效果。\n\n所以我准备入坑 [Blazor](http://blazor.net/) 😂，接下来就现学现卖吧，一起学习一起做项目一起进步，加油💪\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext",
      "WebApi"
    ],
    "createdAt": "2020-06-08 08:57:08"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）",
    "author": "阿星Plus",
    "url": "2020-06-09-blog_21",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://www.cnblogs.com/meowv/p/12896177.html)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://www.cnblogs.com/meowv/p/12896898.html)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://www.cnblogs.com/meowv/p/12909558.html)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://www.cnblogs.com/meowv/p/12913676.html)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://www.cnblogs.com/meowv/p/12916613.html)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://www.cnblogs.com/meowv/p/12924409.html)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://www.cnblogs.com/meowv/p/12924859.html)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://www.cnblogs.com/meowv/p/12935693.html)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://www.cnblogs.com/meowv/p/12943699.html)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://www.cnblogs.com/meowv/p/12956696.html)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://www.cnblogs.com/meowv/p/12961014.html)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://www.cnblogs.com/meowv/p/12966092.html)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://www.cnblogs.com/meowv/p/12971041.html)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://www.cnblogs.com/meowv/p/12974439.html)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://www.cnblogs.com/meowv/p/12980301.html)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://www.cnblogs.com/meowv/p/12987623.html)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://www.cnblogs.com/meowv/p/12994914.html)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://www.cnblogs.com/meowv/p/13039883.html)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://www.cnblogs.com/meowv/p/13043084.html)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://www.cnblogs.com/meowv/p/13046603.html)**\n\n---\n\n## 前言\n\n从今天开始将使用 Blazor 完成博客的前端开发，如果你不了解 [Blazor](https://blazor.net/) ，建议你还是去微软官网学习学习基础知识。本篇不做普及，因为这是实战系列，重点是完成项目开发。\n\n还有，在开始 Blazor 实战之前，建议动手完成之前的系列文章，这样更有连贯性，不至于懵圈。\n\n因为我也是第一次使用 Blazor 开发项目，所以无法保证代码的最优性，如果有不对的地方，或者有更好的做法，欢迎大家指正，谢谢。\n\n接下来，我将现学现做带来一个完整的博客项目，来吧，Just do it 。\n\n我这里选择的是 Blazor WebAssembly，需要你有 .NET Core 3.1 的开发环境，并且你还要有 Visual Studio 2019 IDE。\n\n给大家看看我的开发环境，终端工具是：Window Terminal ，配置一下用起来太爽了，五星强烈推荐。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200607205414486-945023053.png)\n\n## 搭建\n\n> Blazor WebAssembly 是一个单页应用框架，可用它通过 .NET 生成交互式客户端 Web 应用。 Blazor WebAssembly 使用开放的 Web 标准（没有插件或代码转换），适用于移动浏览器等各种新式 Web 浏览器。\n> ...\n\n不啰嗦了，直接开干吧，在项目中新建 Blazor Web 应用。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200607205832925-1719016827.png)\n\n然后将项目设置为启动项目，Ctrl+F5 运行一下看看，官网默认示例我这里也懒得说了，直接进入主题吧。\n\n## 改造\n\n我这里使用的UI还是我目前博客的样式，你可以选择任意你喜欢的UI界面，这部分就随意了，不是本实战系列的重点，所以有关样式这些东西我就直接 Ctrl CV 了。\n\n替换下面css代码到 wwwroot/css/app.css 中。\n\n<details>\n\n<summary>点击查看代码</summary>\n\n```css\n*,\n*:after,\n*:before {\n\t-webkit-box-sizing: border-box;\n\t-moz-box-sizing: border-box;\n\tbox-sizing: border-box;\n}\n\nhtml {\n\tline-height: 1.15;\n\t-webkit-text-size-adjust: 100%;\n}\n\nbody {\n\tmargin: 0;\n}\n\nh1 {\n\tfont-size: 2em;\n\tmargin: 0.67em 0;\n}\n\nhr {\n\tbox-sizing: content-box;\n\theight: 0;\n\toverflow: visible;\n}\n\npre {\n\tfont-family: monospace, monospace;\n\tfont-size: 1em;\n}\n\na {\n\tbackground-color: transparent;\n}\n\nabbr[title] {\n\tborder-bottom: none;\n\ttext-decoration: underline;\n\ttext-decoration: underline dotted;\n}\n\nb,\nstrong {\n\tfont-weight: bolder;\n}\n\ncode,\nkbd,\nsamp {\n\tfont-family: monospace, monospace;\n\tfont-size: 1em;\n}\n\nsmall {\n\tfont-size: 80%;\n}\n\nsub,\nsup {\n\tfont-size: 75%;\n\tline-height: 0;\n\tposition: relative;\n\tvertical-align: baseline;\n}\n\nsub {\n\tbottom: -0.25em;\n}\n\nsup {\n\ttop: -0.5em;\n}\n\nimg {\n\tborder-style: none;\n}\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n\tfont-family: inherit;\n\tfont-size: 100%;\n\tline-height: 1.15;\n\tmargin: 0;\n}\n\nbutton,\ninput {\n\toverflow: visible;\n}\n\nbutton,\nselect {\n\ttext-transform: none;\n}\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n\t-webkit-appearance: button;\n}\n\nbutton::-moz-focus-inner,\n [type=\"button\"]::-moz-focus-inner,\n [type=\"reset\"]::-moz-focus-inner,\n [type=\"submit\"]::-moz-focus-inner {\n\tborder-style: none;\n\tpadding: 0;\n}\n\nbutton:-moz-focusring,\n [type=\"button\"]-moz-focusring,\n [type=\"reset\"]-moz-focusring,\n [type=\"submit\"]-moz-focusring {\n\toutline: 1px dotted ButtonText;\n}\n\nfieldset {\n\tpadding: 0.35em 0.75em 0.625em;\n}\n\nlegend {\n\tbox-sizing: border-box;\n\tcolor: inherit;\n\tdisplay: table;\n\tmax-width: 100%;\n\tpadding: 0;\n\twhite-space: normal;\n}\n\nprogress {\n\tvertical-align: baseline;\n}\n\ntextarea {\n\toverflow: auto;\n}\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n\tbox-sizing: border-box;\n\tpadding: 0;\n}\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n\theight: auto;\n}\n\n[type=\"search\"] {\n\t-webkit-appearance: textfield;\n\toutline-offset: -2px;\n}\n\n [type=\"search\"]::-webkit-search-decoration {\n\t-webkit-appearance: none;\n}\n\n::-webkit-file-upload-button {\n\t-webkit-appearance: button;\n\tfont: inherit;\n}\n\ndetails {\n\tdisplay: block;\n}\n\nsummary {\n\tdisplay: list-item;\n}\n\ntemplate {\n\tdisplay: none;\n}\n\n[hidden] {\n\tdisplay: none;\n}\n\n@font-face {\n\tfont-family: 'Fira Code Medium';\n src: url('https://static.meowv.com/fonts/FiraCode-Medium.woff2') format('woff2'), url(\"https://static.meowv.com/fonts/FiraCode-Medium.woff\") format(\"woff\");\n font-weight: 500;\n font-style: normal;\n}\n\nhtml {\n\tfont-family: 'Fira Code Medium', Microsoft Yahei, monospace;\n\toverflow-x: hidden;\n}\n\nhtml::-webkit-scrollbar {\n\twidth: 5px;\n\theight: 5px;\n}\n\nhtml::-webkit-scrollbar-thumb {\n\theight: 20px;\n\tbackground-color: #5A9600;\n}\n\nhtml::-webkit-scrollbar-thumb:hover {\n\tbackground-color: #5A9600;\n}\n\nbody {\n\tfont-size: 11pt;\n\tfont-weight: normal;\n\tline-height: 2em;\n\tbackground-color: #fff;\n\tcolor: #161209;\n\ttransition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;\n}\n\nbody:before {\n\tcontent: \"\";\n\tbackground-repeat: no-repeat;\n\tbackground-position: center;\n\topacity: 0.05;\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\tz-index: -1;\n}\n\nbody.dark-theme {\n\tbackground-color: #292a2d;\n\tcolor: #a9a9b3;\n\ttransition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;\n}\n\na {\n\tcolor: #161209;\n\ttext-decoration: none;\n\ttransition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;\n\tcursor: pointer;\n}\n\na:hover {\n\tcolor: #5A9600;\n\ttext-decoration: none;\n\ttransition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;\n}\n\n.dark-theme a {\n\tcolor: #a9a9b3;\n\ttext-decoration: none;\n\ttransition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;\n}\n\n.dark-theme a:hover {\n\tcolor: #fff;\n\ttext-decoration: none;\n\ttransition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;\n}\n\n.wrapper {\n\tdisplay: flex;\n\tflex-direction: column;\n\tmin-height: 100vh;\n\twidth: 100%;\n}\n\n.navbar {\n\theight: 4rem;\n\tline-height: 4rem;\n\twidth: 100%;\n}\n\n.navbar .container {\n\twidth: auto;\n\tmax-width: 1200px;\n\ttext-align: center;\n\tmargin: 0 auto;\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.main {\n\tflex-grow: 1;\n\tflex-shrink: 0;\n\tflex-basis: auto;\n}\n\n.container {\n\tpadding-left: 1em;\n\tpadding-right: 1em;\n}\n\n.footer {\n\twidth: 100%;\n\ttext-align: center;\n}\n\n\n/*input css begin*/\n\n* {\n\t-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n\tdisplay: none;\n\twidth: 0;\n\theight: 0;\n\tvisibility: hidden;\n}\n\ninput[type=\"checkbox\"]:checked + label:after {\n\ttransition: all 0.3s ease-in;\n}\n\ninput[type=\"checkbox\"]:not(:checked) + label:after {\n\ttransition: all 0.3s ease-out;\n}\n\ninput[type=\"checkbox\"]:checked + label,\n input[type=\"checkbox\"]:not(:checked) + label {\n\ttransition: all 0.3s ease-in-out;\n}\n\ninput[type=\"checkbox\"]:checked + label:before,\n input[type=\"checkbox\"]:checked + label i:before,\n input[type=\"checkbox\"]:not(:checked) + label i:before,\n input[type=\"checkbox\"]:checked + label i:after,\n input[type=\"checkbox\"]:not(:checked) + label i:after,\n input[type=\"checkbox\"]:not(:checked) + label:before {\n\ttransition: all 0.3s ease-in-out;\n}\n\ninput[type=\"radio\"]:checked + label:after,\n input[type=\"radio\"]:not(:checked) + label:after {\n\ttransition: all 0.3s ease-in-out;\n}\n\n.switch_default + label {\n\tbackground-color: #e6e6e6;\n\tborder-radius: 7px;\n\tcursor: pointer;\n\tdisplay: inline-block;\n\theight: 14px;\n\tposition: relative;\n\tbox-shadow: 0.2px 0.2px 1px 0.5px rgb(180, 180, 180);\n\twidth: 30px;\n}\n\n.switch_default + label:after {\n\tbackground-color: #fff;\n\tborder-radius: 50%;\n\tcontent: \"\";\n\theight: 12px;\n\tleft: 1px;\n\tposition: absolute;\n\ttop: .5px;\n\twidth: 12px;\n\tbox-shadow: 0.2px 0.2px 1px 0.5px rgb(180, 180, 180);\n}\n\n.switch_default:checked + label {\n\tbackground-color: #1ABC9C;\n\tbox-shadow: none;\n}\n\n.switch_default:checked + label:after {\n\tleft: 17px;\n}\n\n@font-face {\n\tfont-family: \"iconfont\";\n src: url('//at.alicdn.com/t/font_1313145_r9szngeugmj.eot?t=1566619028667'); /* IE9 */\n src: url('//at.alicdn.com/t/font_1313145_r9szngeugmj.eot?t=1566619028667#iefix') format('embedded-opentype'), /* IE6-IE8 */\n url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAiMAAsAAAAAD1QAAAg+AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCDdAqRCI1TATYCJAMgCxIABCAFhG0HXhvDDFGUcFIP2c+CnCw3FdS0XDPVbunm+E8fE3Kh6ue/bf25c6cYjLF6zMIMaivAjSQGxCJXNjJwM/BFbdbXczPwNb5ueXi7vbv7y5IszKOA2/IoDoIWp4GmlieQNKkzrZalJCXDA+JcJDsu8Qa0obxaKz0SBAprr8Pya68FDD1xLPmjV6X13/Yu2UGLwt0ogQZU0TadboBznEq5XTozB57jZIAAcBIhD9CoGqEBFsnmIaQcFrMO2IIc2dGMsCK6YceQoM1AYfMaog8ANkW/j36QIRaAQBWwNxyzKY3Q+PFfc3jxIDY1UMKy5bQAIC4GgAHkAQApCu9GyVoAH+mtGBdNmg6Ad/4iBn7eL/Nr/K3+VQPNX3ODg5Vq8NGkCugA8I4dSMwF/3moApsfAIgxwAA/79GfWyADCRDAr7EABcAACZDAv4oEGDDQTAIIfM0J4IFB7Oo8ABQCEC8AXhmk1ovRGGdBLBjd8PEhEkmUKwkj7Q2XcCgpncW8lAwLD1RQiHpZRCPq2XFdPSZJ3VpOf+ZhInXgUYXu9IMEcu/9thnRJonEzeipaAUHrRb40G4oKdWek0KrqlNGvzvlfPb53B6P7vUa5LLhRpv+Zw0tVitpxk1GbHIT1GOTq0g3lxGJLwnzP3PXM67Ni/ReV/m8z3XQCRx2U8CB4ubYY42tYP8zB3DedYFj3iPehzZXg7jQNGGpSdyWZUrVOM4BsDiENpWAUjmGclVtXimBYkVhTA6glC2CGUKEKYGMTqFAm8jIEglCiWVMAVfAK7R4waZoiZa8fLLKuRYsBEfBoro9YU2ScTwGn4PTrhTr1J7G+5+ZNb5LVzt8ywqc80TgwCGPGcZB6Ww+qVeunp71mz0/R8o9PS3t9eQ4AASOuAFfmOU3UDoKQSY0oPmcN0CoIxMRTTQ2lpYWUFoHYfZupcysO9TjOlmvK1cMwAZbLdVtCqvldfSJgPc1YcXQKW4mGjDFK7tJflBU3j8Y/Li047Pnj+79adS3ArfHp3VMyC2NSv+4dJ3El3ZqRz1cpT+Z+7Itr7FKLvr90rseudkbeoKjsHZJg5vj/a9M399PlAsGE4Ml1FSqcksTTM5zlPCRCmmDqJfKttsWUfJZHW9U3kJw12FvhEG7RGgIQM5LEaOoDEzglhAOWbmJnGRbgtuCKAbDsi7hrTfVVdskAPrXon3RbM0E1gR02BFPwMU1Q0iRtpjK/O0YK4LPUVL4TfNW8s3btybD9+0LDX9/9vCTIwaOjFe7+D9yPnGdcEWEs+yq347wxL0ohLvwEyfY+henIWkPEYKNI088lFHaoT6EJ0xHV80n5hFBF2EizJRkuyqYMkSNRWPrDestoO0c1WnAs3ffYRi+7dzaFcRG4vI+3A2KyelHcdMsVVsbI5L3E9h0dPVwh+DJ9GSszlx9fxKjeotDabJW4/NpSjWRPooAYz4/UqPaNk8xbzdEy6MTcKm89JovnDkR4UmPL/0uVZriLpGW+OTXx60ZO5cJp9xUCm2mwum5Y9eMuy73lUhT3bKuRUvj0z0RJ+hw2k0nEwWMqVSYZe5UUGClzHTKdHU4Q5oSdwoE34G2NA0Xok63Ct4Gb+Puht1C5W34lWoxKAN+qhtTCz9FlOwLg6pWTltGzvMeXkRMhk0T04eFUvFjhqhw3Infqybsnz4wJZB7Yg+62BPqUTkaFWAsni3kjLwPO19nJqpb/poAtJqmP0dpE9OrJ3iWZp4dyqQSp3NIa3llctmQYRPDhqlOZ8QqoqMXf1qR+NUIe8xHExICSuPClqlN2Y0PpzwNP1iLfJcuBXKvr14F30xvVt++/fv2+bK8f3+v/nf5EvTbvNmv9+6rkdzJNDZ+DVev+hZt4+0jB/fPn3YW6sOPP8+B8GhxP5WZSfUT79yS7C9PASndzqvVkXljwP+iUVyPJ05eXxV6ajK5yYK3cXHKdZOYoRlYyQ4r/Hj1x/53UrI4gxk6aV2cksNbN1mmUK9GZ8AmKaTsL78lId4h+zMz074Ju115mr3Y3Ou+tHirQR3K8vr98suK/3tWastt6WV5pexWOjwonO6mZfmySNBcWq2X782vGaqUbD6wWLlaufjAZolyTYFOXsYT3MM0HIrpCfYwyqE1+b3FCtlTtyJIodVyBzx29C+ZIlE7vq43FdKebtggp1uYHsZbTv7333+lQWpv3Xj55FbFaoVUsSZCBvVYucWbNtddcvOmxRzfHedt7RsY6HP3vfbBIgAAgx/ja1hA9z/4E0wt3kfm4WIAABLxaN3/kggj7wIyFi9G8Ba+hGvfTCvBs+p7qhnBtb+x0j+rKS9WPt1O1OHAvARgEUBkvIeiIg9gcDBgGSwo2NAYXv8+A7f0wb2sXgj2EgA4ZxzA28ccCv1LCiM4xstOGJGhCYwENMZKA5Cs4wQpUqVA01gNaE4uqHeXCgMHDIUEAHJgBUMjPLyNJgS5ysVNkDtcEhAfmhIJ33Fo1COM5rSksANKZSALJ3eIOpdoFPRzBIvB2mVyVS4uTh0nmmd16BzE4tdqER1Oi7VLKC4oskJqsUt0LLGJs9ssc7lMgslh7RRUbAOxo8Mq2BzWNtHgKmhF0FZdWGiSNy0wWDuBI+cg0nEF+EYC6M0htzCw6mKa3IWr/Pw4IrNZOug4Omrq5C1EDk6W+QtQDAVQNACg5ncNqnmUbKduZjJwkdZE8IodrDoJoCKtqMPxWwlga16ujcjApQBaJ3htqqGQBjMN5RdsL+z8pecAwLEPwyYCYUQiCtGIQSySAPnxnspIu0XLbEsX3anr0plFrLNZSIPVKNJmi6t1lp7qsrpEJwAAAA==') format('woff2'), url('//at.alicdn.com/t/font_1313145_r9szngeugmj.woff?t=1566619028667') format('woff'), url('//at.alicdn.com/t/font_1313145_r9szngeugmj.ttf?t=1566619028667') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n url('//at.alicdn.com/t/font_1313145_r9szngeugmj.svg?t=1566619028667#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.iconfont {\n\tfont-family: \"iconfont\" !important;\n\tfont-size: 16px;\n\tfont-style: normal;\n\t-webkit-font-smoothing: antialiased;\n\t-moz-osx-font-smoothing: grayscale;\n}\n\n.iconread:before {\n\tcontent: \"\\e742\";\n}\n\n.iconweixin:before {\n\tcontent: \"\\e632\";\n}\n\n.iconmanage:before {\n\tcontent: \"\\e610\";\n}\n\n.iconapi:before {\n\tcontent: \"\\e668\";\n}\n\n.iconcode:before {\n\tcontent: \"\\e654\";\n}\n\n.icongithub:before {\n\tcontent: \"\\ea0a\";\n}\n\n.iconnotes:before {\n\tcontent: \"\\e687\";\n}\n\n.header-logo a {\n\tpadding: 0;\n}\n\n.navbar .menu a {\n\tpadding: 0 8px;\n}\n\n.navbar .menu .active {\n\tfont-weight: 900;\n\tcolor: #161209;\n}\n\n.dark-theme .navbar .menu .active {\n\tcolor: #fff;\n}\n\n.navbar-header a:hover,\n.navbar .menu a:hover {\n\tbackground-color: transparent;\n}\n\nheader label {\n\tmargin-left: 15px;\n\tposition: relative;\n\t-webkit-transform: translateY(0.1em) translateX(0.5em);\n}\n\n.copyright {\n\tfont-size: 14px;\n}\n\n.pagination {\n\tdisplay: flex;\n\tflex-direction: row;\n\tjustify-content: center;\n\tlist-style: none;\n\twhite-space: nowrap;\n\twidth: 100%;\n\tpadding-top: 2em;\n}\n\n.pagination a,\n .pagination span {\n\t-webkit-font-smoothing: antialiased;\n\tfont-size: 12px;\n\tcolor: #bfbfbf;\n\tletter-spacing: 0.1em;\n\tfont-weight: 700;\n\tpadding: 5px 5px;\n\ttext-decoration: none;\n\ttransition: 0.3s;\n}\n\n.pagination .page-number {\n\tpadding-bottom: 3px;\n\tmargin: 0 20px;\n\tbox-sizing: border-box;\n\tposition: relative;\n\tdisplay: inline;\n}\n\n.pagination .page-number.disabled {\n\tdisplay: none;\n}\n\n.pagination .page-number:hover a {\n\tcolor: #000;\n}\n\n.dark-theme .pagination .page-number:hover a {\n\tcolor: #fff;\n}\n\n.pagination .page-number:before,\n.pagination .page-number:after {\n\tposition: absolute;\n\tcontent: \"\";\n\twidth: 0;\n\theight: 1px;\n\tbackground: #000;\n\ttransition: 0.3s;\n\tbottom: 0px;\n}\n\n.dark-theme .pagination .page-number:before,\n.dark-theme .pagination .page-number:after {\n\tbackground: #fff;\n}\n\n.pagination .page-number:before .current,\n.pagination .page-number:after .current {\n\twidth: 100%;\n}\n\n.pagination .page-number:before {\n\tleft: 50%;\n}\n\n.pagination .page-number:after {\n\tright: 50%;\n}\n\n.pagination .page-number:hover:before,\n.pagination .page-number:hover:after {\n\twidth: 50%;\n}\n\n.pagination .page-number.current {\n\tcolor: #000;\n}\n\n.dark-theme .pagination .page-number.current {\n\tcolor: #fff;\n}\n\n.pagination .page-number.current:before,\n.pagination .page-number.current:after {\n\twidth: 60%;\n}\n\n.intro {\n\ttransform: translateY(20vh);\n\ttext-align: center;\n}\n\n.intro .avatar {\n\tpadding: 10px;\n}\n\n.intro .avatar img {\n\twidth: 128px;\n\theight: auto;\n\tdisplay: inline-block;\n\t-webkit-border-radius: 100%;\n\tborder-radius: 100%;\n\t-webkit-box-shadow: 0 0 0 0.3618em rgba(0, 0, 0, 0.05);\n\tbox-shadow: 0 0 0 0.3618em rgba(0, 0, 0, 0.05);\n\tmargin: 0 auto;\n\t-webkit-transition: all ease 0.4s;\n\t-moz-transition: all ease 0.4s;\n\t-o-transition: all ease 0.4s;\n\ttransition: all ease 0.4s;\n\tcursor: pointer;\n}\n\n.intro .avatar img:hover {\n\tposition: relative;\n\t-webkit-transform: translateY(-0.75em);\n\t-moz-transform: translateY(-0.75em);\n\t-ms-transform: translateY(-0.75em);\n\t-o-transform: translateY(-0.75em);\n\ttransform: translateY(-0.75em);\n\tcursor: pointer;\n}\n\n.nickname {\n\tfont-size: 2em;\n\tfont-weight: normal;\n}\n\n.links a {\n\tpadding: 0 5px;\n}\n\n.links a:hover {\n\tbackground-color: transparent;\n}\n\n.links .iconfont {\n\tfont-size: 2em;\n}\n\n.post-wrap {\n\tposition: relative;\n\twidth: 100%;\n\tmax-width: 1024px;\n\tmargin: 0 auto;\n\tpadding-top: 2rem;\n}\n\n.archive-item-date {\n\tfloat: right;\n\ttext-align: right;\n\tcolor: #a9a9b3;\n}\n\n.dark-theme .archive-item-date {\n\tcolor: #87878d;\n}\n\n.post-wrap .categories-card {\n\tmargin: 0 auto;\n\tmargin-top: 1em;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: space-between;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n\tpadding: 0 2.5em;\n\tline-height: 1.6em;\n}\n\n.post-wrap .categories-card .card-item {\n\tfont-size: 14px;\n\ttext-align: left;\n\twidth: 50%;\n\tdisplay: flex;\n\talign-items: flex-start;\n\tposition: relative;\n}\n\n.post-wrap .categories-card .card-item .categories {\n\toverflow: hidden;\n}\n\n.categories h3 {\n\tdisplay: inline-block;\n}\n\n.categories span {\n\tfloat: right;\n\tpadding-right: 1em;\n}\n\n.categories .more-post-link {\n\tfloat: right;\n}\n\n.tag-cloud-tags {\n\tmargin: 10px 0;\n\tpadding-top: 2em;\n}\n\n.tag-cloud-tags a {\n\tdisplay: inline-block;\n\tposition: relative;\n\tmargin: 5px 10px;\n\tword-wrap: break-word;\n\ttransition-duration: 0.3s;\n\ttransition-property: transform;\n\ttransition-timing-function: ease-out;\n}\n\n.tag-cloud-tags a:active,\n .tag-cloud-tags a:focus,\n .tag-cloud-tags a:hover {\n\tcolor: #5A9600;\n\ttransform: scale(1.1);\n}\n\n.dark-theme .tag-cloud-tags a:active,\n.dark-theme .tag-cloud-tags a:focus,\n.dark-theme .tag-cloud-tags a:hover {\n\tcolor: #fff;\n}\n\n.tag-cloud-tags a small {\n\tmargin: 0 0.3em;\n\tcolor: #a9a9b3;\n}\n\n.dark-theme .tag-cloud-tags a small {\n\tcolor: #fff;\n}\n\n.page {\n\tpadding-top: 0;\n}\n\n.page .post-content {\n\tmargin: 0;\n\tpadding-top: 0;\n}\n\n.post-wrap p {\n\tfont-size: 1em;\n\tmargin: 0.5em 0 0.5em 0;\n}\n\n.post-wrap .post-header h1 {\n\tmargin: 0 !important;\n}\n\n.post-wrap .post-title {\n\tfont-size: 2em;\n\tline-height: 1.5em;\n}\n\n.post-wrap .eror-tip {\n\ttext-align: center;\n\tline-height: 1.5em;\n\tmargin-top: 250px;\n}\n\n.post-wrap .post-meta {\n\tcolor: rgba(85, 85, 85, 0.529) !important;\n}\n\n.dark-theme .post-wrap .post-meta {\n\tcolor: #87878d !important;\n}\n\n.post-wrap .post-meta a {\n\tcolor: #000;\n}\n\n.dark-theme .post-wrap .post-meta a {\n\tcolor: #eee;\n}\n\n.post-wrap .post-meta a:hover {\n\tcolor: #5A9600;\n}\n\n.dark-theme .post-wrap .post-meta a:hover {\n\tcolor: #fff;\n}\n\n.post-content {\n\tpadding-top: 2rem;\n\ttext-align: justify;\n}\n\n.post-copyright {\n\tmargin-top: 5rem;\n\tborder-top: 1px solid #e8e8e8;\n\tborder-bottom: 1px solid #e8e8e8;\n}\n\n.post-copyright a {\n\tcolor: #000;\n}\n\n.dark-theme .post-copyright a {\n\tcolor: #eee;\n}\n\n.post-copyright a:hover {\n\tcolor: #5A9600;\n}\n\n.dark-theme .post-copyright a:hover {\n\tcolor: #fff;\n}\n\n.post-copyright .copyright-item {\n\tmargin: 5px 0;\n}\n\n.post-copyright .lincese {\n\tfont-weight: bold;\n}\n\n.dark-theme .post-copyright {\n\tborder-top: 1px solid #909196;\n\tborder-bottom: 1px solid #909196;\n}\n\n.post-tags {\n\tpadding: 1rem 0 1rem;\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.post-nav:before,\n.post-nav:after {\n\tcontent: \" \";\n\tdisplay: table;\n}\n\n.post-nav a.prev,\n.post-nav a.next {\n\tfont-weight: 600;\n\tfont-size: 16px;\n\ttransition-property: transform;\n\ttransition-timing-function: ease-out;\n\ttransition-duration: 0.3s;\n}\n\n.post-nav a.prev {\n\tfloat: left;\n}\n\n.post-nav a.prev::before {\n\tcontent: \"<\";\n\tmargin-right: 0.5em;\n}\n\n.post-nav a.prev:hover {\n\ttransform: translateX(-4px);\n}\n\n.post-nav a.next {\n\tfloat: right;\n}\n\n.post-nav a.next::after {\n\tcontent: \">\";\n\tmargin-left: 0.5em;\n}\n\n.post-nav a.next:hover {\n\ttransform: translateX(4px);\n}\n\n.post-nav a.prev::before,\n .post-nav a.next::after {\n\tfont-weight: bold;\n}\n\n.tag:not(:last-child) a::after {\n\tcontent: \" / \";\n}\n\n@media only screen and (min-device-width: 320px) and (max-device-width: 1024px) {\n\t.main {\n\t\tpadding-top: 40pt;\n\t}\n\n\t.navbar {\n\t\tdisplay: none;\n\t}\n\n\t.navbar-mobile {\n\t\tdisplay: block !important;\n\t\tposition: fixed;\n\t\twidth: 100%;\n\t\tz-index: 100;\n\t\ttransition: all 0.6s ease 0s;\n\t}\n\n\t.navbar-mobile .container {\n\t\tpadding: 0;\n\t\tmargin: 0;\n\t\tline-height: 5.5em;\n\t\tbackground: #fff;\n\t}\n\n\t.navbar-mobile .container .navbar-header {\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\talign-items: center;\n\t\twidth: 100%;\n\t\tpadding-right: 1em;\n\t\tpadding-left: 1em;\n\t\tbox-sizing: border-box;\n\t\tposition: relative;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle {\n\t\tcursor: pointer;\n\t\tline-height: 5.5em;\n\t\tpadding: auto 2em;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle span {\n\t\tdisplay: block;\n\t\tbackground: #000;\n\t\twidth: 36px;\n\t\theight: 2px;\n\t\t-webkit-border-radius: 3px;\n\t\t-moz-border-radius: 3px;\n\t\tborder-radius: 3px;\n\t\t-webkit-transition: 0.25s margin 0.25s, 0.25s transform;\n\t\t-moz-transition: 0.25s margin 0.25s, 0.25s transform;\n\t\ttransition: 0.25s margin 0.25s, 0.25s transform;\n\t}\n\n\t.dark-theme .navbar-mobile .container .navbar-header .menu-toggle span {\n\t\tbackground: #a9a9b3;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle span:nth-child(1) {\n\t\tmargin-bottom: 8px;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle span:nth-child(3) {\n\t\tmargin-top: 8px;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle.active span {\n\t\t-webkit-transition: 0.25s margin, 0.25s transform 0.25s;\n\t\t-moz-transition: 0.25s margin, 0.25s transform 0.25s;\n\t\ttransition: 0.25s margin, 0.25s transform 0.25s;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle.active span:nth-child(1) {\n\t\t-moz-transform: rotate(45deg) translate(4px, 6px);\n\t\t-ms-transform: rotate(45deg) translate(4px, 6px);\n\t\t-webkit-transform: rotate(45deg) translate(4px, 6px);\n\t\ttransform: rotate(45deg) translate(4px, 6px);\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle.active span:nth-child(2) {\n\t\topacity: 0;\n\t}\n\n\t.navbar-mobile .container .navbar-header .menu-toggle.active span:nth-child(3) {\n\t\t-moz-transform: rotate(-45deg) translate(8px, -10px);\n\t\t-ms-transform: rotate(-45deg) translate(8px, -10px);\n\t\t-webkit-transform: rotate(-45deg) translate(8px, -10px);\n\t\ttransform: rotate(-45deg) translate(8px, -10px);\n\t}\n\n\t.navbar-mobile .container .menu {\n\t\ttext-align: center;\n\t\tbackground: #fff;\n /*border-top: 1px solid #000;*/\n\t\tpadding-top: 1em;\n\t\tpadding-bottom: 1em;\n\t\tdisplay: none;\n\t\tbox-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1), 0px 4px 8px rgba(0, 0, 0, 0.1);\n\t}\n\n\t.navbar-mobile .container .menu a {\n\t\tdisplay: inline-block;\n\t\tmargin: 0 1em;\n\t\tline-height: 2.5em;\n\t}\n\n\t.navbar-mobile .container .menu.active {\n\t\tdisplay: block;\n\t\twhite-space: nowrap;\n\t\tbox-sizing: border-box;\n\t\toverflow-x: auto;\n\t}\n\n\t.dark-theme .navbar-mobile .container .menu {\n\t\tbackground: #292a2d;\n /*border-top: 1px solid #87878d;*/\n\t}\n\n\t.dark-theme .navbar-mobile .container {\n\t\tbackground: #292a2d !important;\n\t}\n\n\t.archive {\n\t\twidth: 90%;\n\t}\n\n\t.archive .archive-item .archive-item-date {\n\t\tdisplay: none;\n\t}\n\n\t#dynamic-to-top {\n\t\tdisplay: none !important;\n\t}\n\n\t.footer {\n\t\theight: 3rem;\n\t\twidth: 100%;\n\t\ttext-align: center;\n\t\tline-height: 1.5rem;\n\t\tpadding-top: 2em;\n\t}\n\n\t.post-warp {\n\t\tpadding-top: 6em;\n\t}\n\n\t.post-warp .archive-item-date {\n\t\tdisplay: none;\n\t}\n\n\t.categories .categories-card .card-item {\n\t\twidth: 100%;\n\t\tdisplay: flex;\n\t\tmin-height: 0;\n\t}\n\n\t.categories .categories-card .card-item .categories {\n\t\toverflow: hidden;\n\t}\n\n\t.signature-img {\n\t\twidth: 100%;\n\t}\n\n\t.signature-box img {\n\t\theight: 100px !important;\n\t}\n\n\t.signature-img img {\n\t\theight: 100px;\n\t}\n\n\t.signature-action, .vip-action {\n\t\twidth: 100%;\n\t}\n\n\t.signature-action select, .vip-action select {\n\t\twidth: 100%;\n\t}\n\n\t.signature-action input, .vip-action input {\n\t\twidth: 200px;\n\t\tfloat: left;\n\t\tmargin-top: 5px;\n\t}\n\n\t.signature-action button, .vip-action button {\n\t\twidth: 200px;\n\t\tmargin-top: 5px;\n\t}\n\n\t.mta-box {\n\t\twidth: 100% !important;\n\t}\n\n\t.mta-a ul li {\n\t\twidth: 100% !important;\n\t}\n\n\t.navbar-mobile {\n\t\tdisplay: none;\n\t}\n}\n\n@media only screen and (min-device-width: 768px) {\n\t.navbar-mobile {\n\t\tdisplay: none;\n\t}\n}\n\n@media only screen and (min-width: 1024px) {\n\t.navbar-mobile {\n\t\tdisplay: none;\n\t}\n}\n\n.loader {\n\tbox-sizing: content-box;\n\tdisplay: block;\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\tmargin: 0;\n\ttext-align: center;\n\tz-index: 1000;\n\t-webkit-transform: translateX(-50%) translateY(-50%);\n\ttransform: translateX(-50%) translateY(-50%);\n}\n\n.loader:before {\n\tposition: absolute;\n\tcontent: '';\n\ttop: 0;\n\tleft: 50%;\n\twidth: 50px;\n\theight: 50px;\n\tmargin: 0 0 0 -25px;\n\tborder-radius: 50px;\n\tborder: 4px solid rgba(0, 0, 0, .1);\n}\n\n.loader:after {\n\tposition: absolute;\n\tcontent: '';\n\ttop: 0;\n\tleft: 50%;\n\twidth: 50px;\n\theight: 50px;\n\tmargin: 0 0 0 -25px;\n\tanimation: loader .6s linear;\n\tanimation-iteration-count: infinite;\n\tborder-radius: 50px;\n\tborder: 4px solid transparent;\n\tborder-top-color: #767676;\n\tbox-shadow: 0 0 0 1px transparent;\n}\n\n@keyframes loader {\n\tfrom {\n\t\t-webkit-transform: rotate(0deg);\n\t\ttransform: rotate(0deg);\n\t}\n\n\tto {\n\t\t-webkit-transform: rotate(360deg);\n\t\ttransform: rotate(360deg);\n\t}\n}\n\n.dark-theme .post-content {\n\tbackground: #292a2d !important;\n\tcolor: #eee !important;\n}\n\n.dark-theme .post-content p code, .dark-theme .post-content ul li code {\n\tbackground: #292a2d !important;\n}\n\n.apps {\n\tcolor: red;\n\tfont-weight: bold;\n}\n\n.signature-box {\n\tmargin-top: 100px;\n\ttext-align: center;\n}\n\n.signature-box img {\n\tborder: none;\n\theight: 145px;\n\tmargin-bottom: 50px;\n}\n\n.signature-action select, .vip-action select {\n\theight: 30px;\n}\n\n.signature-action input, .vip-action input {\n\theight: 25px;\n\tpadding-left: 5px;\n}\n\n.signature-action input:focus, .vip-action input:focus {\n\toutline: none;\n}\n\n.signature-action button, .vip-action button {\n\twidth: 135px;\n\theight: 30px;\n}\n\n.tag-cloud-tags-extend {\n\tpadding-top: 0;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\n.vip-action {\n\ttext-align: center;\n}\n\n.imgbox {\n\twidth: 70%;\n\ttext-align: center;\n\tmargin: 80px auto 0;\n}\n\n.imgbox img {\n\tmax-width: 100%;\n\tmax-height: 100%;\n}\n\n.girl-qrcode {\n\ttext-align: center;\n}\n\n.girl-img {\n\twidth: 20%;\n}\n\n.btnbox {\n\ttext-align: center;\n\tmargin-top: 20px;\n}\n\n.tab-box {\n\tmargin: 0 auto;\n\tmargin-top: 50px;\n\twidth: 1150px;\n}\n\n.top-tab {\n\tfont-weight: bold;\n\tfloat: left;\n\tmargin-top: 5px;\n}\n\n.top-tab ul li {\n\tlist-style: none;\n}\n\n.top-tab ul li a.archive {\n\tcolor: #5A9600;\n}\n\n.top-content {\n\tfloat: left;\n}\n\n.top-content ul li {\n\tlist-style: none;\n\theight: 35px;\n\tline-height: 35px;\n\twidth: 888px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap;\n}\n\n.mta-box {\n\twidth: 75%;\n\tmargin: 100px auto 0;\n}\n\n.mta-a {\n\tmargin: 20px 68px 50px 20px;\n}\n\n.mta-a ul {\n\twidth: auto;\n\tdisplay: none;\n}\n\n.mta-a ul li {\n\tfloat: left;\n\twidth: 25%;\n\tlist-style: none;\n}\n\n.mta-a-item {\n\tmargin: 0 10px;\n\tborder: 1px solid #e1e1e1;\n\tbackground: #fff;\n\tmin-height: 60px;\n}\n\n.mta-a-title {\n\tpadding: 16px 16px 0;\n\theight: 20px;\n\tline-height: 20px;\n}\n\n.mta-a-value {\n\theight: 100%;\n\tfont-size: 30px;\n\theight: 24px;\n\tmargin: 20px 0 20px 30px;\n}\n\n.mta-date {\n\ttext-align: right;\n\tpadding-right: 5px;\n}\n\n.dark-theme .mta-a-item {\n\tborder: 1px solid #a9a9b3;\n\tbackground: transparent;\n}\n\n.qrcode {\n\twidth: 120px;\n\tz-index: 99999;\n\topacity: 0.8;\n\tmargin: 20px auto 0;\n}\n\n.qrcode img {\n\twidth: 100%;\n}\n\n.soul {\n\ttext-align: center;\n\tmargin-top: 200px;\n}\n\n.soul-btn {\n\tbackground-color: #5a9600;\n\tborder: 5px;\n\tcolor: white;\n\tpadding: 15px 32px;\n\ttext-align: center;\n\ttext-decoration: none;\n\tdisplay: inline-block;\n\tfont-size: 16px;\n\tmargin: 4px 2px;\n\tcursor: pointer;\n\t-webkit-transition-duration: 0.4s;\n\ttransition-duration: 0.4s;\n}\n\n.soul-btn:hover {\n\tbox-shadow: 0 12px 16px 0 rgba(0,0,0,0.24),0 17px 50px 0 rgba(0,0,0,0.19);\n}\n```\n\n</details>\n\n\n\n在css中用到了开源的 FiraCode 字体，可以自己去下载，不过在css中我已经改为远程地址了。\n\n删掉  wwwroot/sample-data、wwwroot/css/bootstrap、wwwroot/css/open-iconic 三个文件夹。\n\n在wwwroot文件夹下，有一个index.html，这个是我们网站的入口，注意里面有一对标签：`<app>Loading...</app>`，这个标签里面的内容会在 wasm 加载完毕后自动清除掉，所以，一般可以用来做加载提示。\n\n现在改造一下`index.html`，代码如下：\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n    <meta name=\"keywords\" content=\"Meowv,qix,阿星Plus,个人博客\">\n    <meta name=\"description\" content=\"阿星Plus的个人博客,用于发表原创文章,关注微信公众号：『阿星Plus』了解更多。\">\n    <title>😍阿星Plus⭐⭐⭐</title>\n    <base href=\"/\" />\n    <link href=\"css/app.css\" rel=\"stylesheet\" />\n</head>\n\n<body>\n    <app>\n        <div class=\"loader\"></div>\n    </app>\n    <script src=\"_framework/blazor.webassembly.js\"></script>\n</body>\n\n</html>\n```\n\n千万注意，`blazor.webassembly.js` 这个js不可以删除，会在项目打包后自动生成这个js文件。\n\n然后我们一点一点完善，`Program.cs`默认就行暂时不需要做任何改动。\n\n`Pages`文件夹内的Razor组件就是我们的具体页面了，干掉默认的`Counter.razor`和`FetchData.razor`，留下`Index.razor`，当作我们的首页。\n\n`Shared`文件夹内可以放一些共享的组件，比如我们的模板`MainLayout.razor`就在里面，它需要继承`LayoutComponentBase`。\n\n所以现在可以来修改一下我们的模板内容。\n\n以我博客的UI架构而言，博客分为了三个部分，头部、尾部、内容。\n\n```html\n@inherits LayoutComponentBase\n\n<div class=\"wrapper\">\n    <Header />\n    @Body\n    <Footer />\n</div>\n```\n\n`@Body`为固定语法，表示这里是内容部分，其他的不变，只在这里填充内容。\n\n在Shared文件夹中添加两个组件，头部：`Header.razor`、尾部：`Footer.razor`。\n\n`Header.razor`的内容如下：\n\n```html\n<!-- Header.razor -->\n<header>\n    <nav class=\"navbar\">\n        <div class=\"container\">\n            <div class=\"navbar-header header-logo\">\n                <NavLink class=\"menu-item\" href=\"/\" Match=\"NavLinkMatch.All\">\n                    😍阿星Plus\n                </NavLink>\n            </div>\n            <div class=\"menu navbar-right\">\n                <NavLink class=\"menu-item\" href=\"posts\">Posts</NavLink>\n                <NavLink class=\"menu-item\" href=\"categories\">Categories</NavLink>\n                <NavLink class=\"menu-item\" href=\"tags\">Tags</NavLink>\n                <NavLink class=\"menu-item apps\" href=\"apps\">Apps</NavLink>\n                <input id=\"switch_default\" type=\"checkbox\" class=\"switch_default\" />\n                <label for=\"switch_default\" class=\"toggleBtn\"></label>\n            </div>\n        </div>\n    </nav>\n    <nav class=\"navbar-mobile\">\n        <div class=\"container\">\n            <div class=\"navbar-header\">\n                <div>\n                    <NavLink class=\"menu-item\" href=\"\" Match=\"NavLinkMatch.All\">😍阿星Plus</NavLink>\n                    <NavLink > · Light</NavLink>\n                </div>\n                <div class=\"menu-toggle\">☰ Menu</div>\n            </div>\n            <div class=\"menu\">\n                <NavLink class=\"menu-item\" href=\"posts\">Posts</NavLink>\n                <NavLink class=\"menu-item\" href=\"categories\">Categories</NavLink>\n                <NavLink class=\"menu-item\" href=\"tags\">Tags</NavLink>\n                <NavLink class=\"menu-item apps\" href=\"apps\">Apps</NavLink>\n            </div>\n        </div>\n    </nav>\n</header>\n```\n\n可以看到有很多的`NavLink`组件，这是我将a标签转换后的内容，其实最终生成的也是我们熟悉的a标签，不过他自然有独特用处，看介绍：\n\n> 创建导航链接时，请使用 NavLink 组件代替 HTML 超链接元素 (&lt;a&gt;)。 NavLink 组件的行为方式类似于 &lt;a&gt; 元素，但它根据其 href 是否与当前 URL 匹配来切换 active CSS 类。 active 类可帮助用户了解所显示导航链接中的哪个页面是活动页面。\n> ...\n\n`Footer.razor`的内容如下：\n\n```html\n<!-- Footer.razor -->\n<footer id=\"footer\" class=\"footer\">\n    <div class=\"copyright\">\n        <span>\n            Powered by <a target=\"_blank\" href=\"http://dot.net\">.NET Core 3.1</a> and <a href=\"http://blazor.net/\">Blazor</a> on Linux\n        </span>\n    </div>\n</footer>\n```\n\n然后删掉默认的多余的组件：`NavMenu.razor`和`SurveyPrompt.razor`。\n\n还有一个`_Imports.razor`，这个就是用来导入命名空间的，放在这里面就相当于全局引用了。\n\n现在去编辑我们的首页`Index.razor`。\n\n```html\n@page \"/\"\n\n<div class=\"main\">\n    <div class=\"container\">\n        <div class=\"intro\">\n            <div class=\"avatar\">\n                <a href=\"javascript:;\"><img src=\"https://static.meowv.com/images/avatar.jpg\"></a>\n            </div>\n            <div class=\"nickname\">阿星Plus</div>\n            <div class=\"description\">\n                <p>\n                    生命不息，奋斗不止\n                    <br>Cease to struggle and you cease to live\n                </p>\n            </div>\n            <div class=\"links\">\n                <NavLink class=\"link-item\" title=\"Posts\" href=\"posts\">\n                    <i class=\"iconfont iconread\"></i>\n                </NavLink>\n                <NavLink target=\"_blank\" class=\"link-item\" title=\"Notes\" href=\"https://notes.meowv.com/\">\n                    <i class=\"iconfont iconnotes\"></i>\n                </NavLink>\n                <NavLink target=\"_blank\" class=\"link-item\" title=\"API\" href=\"https://api.meowv.com/\">\n                    <i class=\"iconfont iconapi\"></i>\n                </NavLink>\n                <NavLink class=\"link-item\" title=\"Manage\" href=\"/account/auth\">\n                    <i class=\"iconfont iconcode\"></i>\n                </NavLink>\n                <NavLink target=\"_blank\" class=\"link-item\" title=\"Github\" href=\"https://github.com/Meowv/\">\n                    <i class=\"iconfont icongithub\"></i>\n                </NavLink>\n                <NavLink class=\"link-item weixin\" title=\"扫码关注微信公众号：『阿星Plus』查看更多。\">\n                    <i class=\"iconfont iconweixin\"></i>\n                </NavLink>\n                <div class=\"qrcode\">\n                    <img src=\"https://static.meowv.com/images/wx_qrcode.jpg\" />\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n```\n\n`@page`指令用于设置页面路由地址，因为是首页，所以直接给一个\"/\"就可以了。\n\n至此项目算是搭建完成并且将其改造了一番，现在可以去运行一下看看效果了。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200607215542220-1618189764.png)\n\n第一次打开或者强制刷新页面会出现加载中的界面，我这里就是一个小圈圈在那里转，当加载完毕后就会自动消失，什么都不需要干，太方便了。\n\n现在已经成功将首页的显示搞定了，随便点击几个按钮试试，会输出一个错误提示：Sorry, there's nothing at this address，因为没有找到这些路由，所以就...\n\n默认的有点丑，并且这句提示当然也可以自定义的，现在来看最后的一个组件`App.razor`。\n\n```html\n<Router AppAssembly=\"@typeof(Program).Assembly\">\n    <Found Context=\"routeData\">\n        <RouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\" />\n    </Found>\n    <NotFound>\n        <LayoutView Layout=\"@typeof(MainLayout)\">\n            <p>Sorry, there's nothing at this address.</p>\n        </LayoutView>\n    </NotFound>\n</Router>\n```\n\n通过语义化的代码不难理解，`Found`就是找到与之匹配的路由，然后调用模板`MainLayout`，`NotFound`就是没有找到的情况下，使用`MainLayout`并且在`@body`输出一句提示。\n\n将这句错误提示做成一个公共的组件并且美化一下，在Shared文件夹下新建组件：`ErrorTip.razor`，内容如下：\n\n```html\n<div class=\"main\">\n    <div class=\"post-wrap\">\n        <h2 class=\"eror-tip\">Sorry, there's nothing at this address.😖😖😖</h2>\n    </div>\n</div>\n```\n\n使用组件也很简单，在`App.razor`中删掉默认的p标签然后调用`ErrorTip`。\n\n```html\n...\n    <NotFound>\n        <LayoutView Layout=\"@typeof(MainLayout)\">\n            <ErrorTip />\n        </LayoutView>\n    </NotFound>\n...\n```\n\n再看一下打开了不存在路由的页面的错误提示吧。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200607220930210-502780591.png)\n\n哈哈哈，是不是好看许多，接下来会完成主题切换，菜单展开关闭等等功能，其实这些可以用JavaScript很方便的实现，但是既然用了 Blazor 开发，所以还是用 .NET 代码实现吧。\n\n本篇就先到这里，未完待续...\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-09 09:09:09"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）",
    "author": "阿星Plus",
    "url": "2020-06-10-blog_22",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇搭建了 Blazor 项目并将整体框架改造了一下，本篇将完成用 C# 代码代替 JavaScript 实现几个小功能，说是代替但并不能完全不用 JavaScript，应该说是尽量不用吧。\n\n## 二维码显示与隐藏\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200608142754914-916006518.gif)\n\n可以看到，当我鼠标移入的时候显示二维码，移出的时候隐藏二维码。\n\n这个功能如果是用JavaScript来完成的话，肯定首先想到的是HTML的 Mouse 事件属性，那么在Blazor中也是一样的，给我们实现了各种`on*`事件。\n\n打开`index.razor`页面，给微信图标那个 NavLink 标签添加两个事件，`@onmouseover`和`@onmouseout`。\n\n```html\n...\n<NavLink class=\"link-item weixin\" title=\"扫码关注微信公众号：『阿星Plus』查看更多。\" @onmouseover=\"Hover\" @onmouseout=\"Hover\">\n    <i class=\"iconfont iconweixin\"></i>\n</NavLink>\n...\n```\n\n当鼠标移入移出的时候都执行我们自定义的一个方法`Hover()`。\n\nC# 代码写在`@code{}`花括号中，实现显示和隐藏原理是利用css，默认是隐藏的，当显示的时候将具有隐藏属性的class值去掉就可以了。\n\n所以，可以添加两个字段，一个用于判断当前是否处于隐藏状态，一个用来存储class的值。\n\n```CSharp\n/// <summary>\n/// 是否隐藏\n/// </summary>\nprivate bool IsHidden = true;\n\n/// <summary>\n/// 二维码CSS\n/// </summary>\nprivate string QrCodeCssClass => IsHidden ? \"hidden\" : null;\n```\n\n当`IsHidden = true`，`QrCodeCssClass = \"hidden\"`，当`IsHidden = false`，`QrCodeCssClass = null`。\n\n那么在`Hover()`方法中，不断修改`IsHidden`的值就可以实现效果了。\n\n```CSharp\n/// <summary>\n/// 鼠标移入移出操作\n/// </summary>\nprivate void Hover() => IsHidden = !IsHidden;\n```\n\n最后将`QrCodeCssClass`变量赋值给二维码图片所在的div上。\n\n```html\n...\n<div class=\"qrcode @QrCodeCssClass\">\n    <img src=\"https://static.meowv.com/images/wx_qrcode.jpg\" />\n</div>\n...\n```\n\n大功告成，`index.razor`完整代码如下：\n\n```html\n@page \"/\"\n\n<div class=\"main\">\n    <div class=\"container\">\n        <div class=\"intro\">\n            <div class=\"avatar\">\n                <a href=\"javascript:;\"><img src=\"https://static.meowv.com/images/avatar.jpg\"></a>\n            </div>\n            <div class=\"nickname\">阿星Plus</div>\n            <div class=\"description\">\n                <p>\n                    生命不息，奋斗不止\n                    <br>Cease to struggle and you cease to live\n                </p>\n            </div>\n            <div class=\"links\">\n                <NavLink class=\"link-item\" title=\"Posts\" href=\"posts\">\n                    <i class=\"iconfont iconread\"></i>\n                </NavLink>\n                <NavLink target=\"_blank\" class=\"link-item\" title=\"Notes\" href=\"https://notes.meowv.com/\">\n                    <i class=\"iconfont iconnotes\"></i>\n                </NavLink>\n                <NavLink target=\"_blank\" class=\"link-item\" title=\"API\" href=\"https://api.meowv.com/\">\n                    <i class=\"iconfont iconapi\"></i>\n                </NavLink>\n                <NavLink class=\"link-item\" title=\"Manage\" href=\"/account/auth\">\n                    <i class=\"iconfont iconcode\"></i>\n                </NavLink>\n                <NavLink target=\"_blank\" class=\"link-item\" title=\"Github\" href=\"https://github.com/Meowv/\">\n                    <i class=\"iconfont icongithub\"></i>\n                </NavLink>\n                <NavLink class=\"link-item weixin\" title=\"扫码关注微信公众号：『阿星Plus』查看更多。\" @onmouseover=\"Hover\" @onmouseout=\"Hover\">\n                    <i class=\"iconfont iconweixin\"></i>\n                </NavLink>\n                <div class=\"qrcode @QrCodeCssClass\">\n                    <img src=\"https://static.meowv.com/images/wx_qrcode.jpg\" />\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n@code {\n    /// <summary>\n    /// 是否隐藏\n    /// </summary>\n    private bool IsHidden = true;\n\n    /// <summary>\n    /// 二维码CSS\n    /// </summary>\n    private string QrCodeCssClass => IsHidden ? \"hidden\" : null;\n\n    /// <summary>\n    /// 鼠标移入移出操作\n    /// </summary>\n    private void Hover() => IsHidden = !IsHidden;\n}\n```\n\n## 菜单显示与隐藏\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200608145616714-1839322387.gif)\n\n菜单是在小屏幕上才会出现的，相信看完了二维码的显示与隐藏，这个菜单的显示与隐藏就好办了吧，实现方法是一样的，菜单按钮是在头部组件`Header.razor`中的，包括主题切换功能，所以下面代码都在`Header.razor`里面。\n\n```CSharp\n@code {\n    /// <summary>\n    /// 下拉菜单是否打开\n    /// </summary>\n    private bool collapseNavMenu = false;\n\n    /// <summary>\n    /// 导航菜单CSS\n    /// </summary>\n    private string NavMenuCssClass => collapseNavMenu ? \"active\" : null;\n\n    /// <summary>\n    /// 显示/隐藏 菜单\n    /// </summary>\n    private void ToggleNavMenu() => collapseNavMenu = !collapseNavMenu;\n}\n```\n\n默认是不打开的，`collapseNavMenu = false`。然后根据`collapseNavMenu`值为`NavMenuCssClass`给定不同的class。\n\n```html\n...\n<nav class=\"navbar-mobile\">\n    <div class=\"container\">\n        <div class=\"navbar-header\">\n            <div>\n                <NavLink class=\"menu-item\" href=\"\" Match=\"NavLinkMatch.All\">😍阿星Plus</NavLink>\n                <NavLink>&nbsp;·&nbsp;Light</NavLink>\n            </div>\n            <div class=\"menu-toggle\" @onclick=\"ToggleNavMenu\">&#9776; Menu</div>\n        </div>\n        <div class=\"menu @NavMenuCssClass\">\n            <NavLink class=\"menu-item\" href=\"posts\">Posts</NavLink>\n            <NavLink class=\"menu-item\" href=\"categories\">Categories</NavLink>\n            <NavLink class=\"menu-item\" href=\"tags\">Tags</NavLink>\n            <NavLink class=\"menu-item apps\" href=\"apps\">Apps</NavLink>\n        </div>\n    </div>\n</nav>\n...\n```\n\n与二维码显示与隐藏唯一区别就是这里是点击按钮，不是移入移出，所以菜单显示与隐藏需要用到`@onclick`方法。\n\n## 主题切换\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200608164132941-2088370863.gif)\n\n哇，这个主题切换真的是一言难尽，当切换主题的时候需要记住当前的主题是什么，当刷新页面或者跳转其他页面的时候，主题状态是需要一致的，默认是白色主题，当切换暗黑色主题后其实是在body上加了一个class。\n\n在Blazor实在是不知道用什么办法去动态控制body的样式，所以这里我想到了一个办法，写几个全局的JavaScript方法，然后再Blazor中调用，要知道，他们是可以互相调用的，于是问题迎刃而解。\n\n添加`app.js`文件，放在 /wwwroot/js/ 下面。\n\n```javascript\nvar func = window.func || {};\n\nfunc = {\n    setStorage: function (name, value) {\n        localStorage.setItem(name, value);\n    },\n    getStorage: function (name) {\n        return localStorage.getItem(name);\n    },\n    switchTheme: function () {\n        var currentTheme = this.getStorage('theme') || 'Light';\n        var isDark = currentTheme === 'Dark';\n\n        if (isDark) {\n            document.querySelector('body').classList.add('dark-theme');\n        } else {\n            document.querySelector('body').classList.remove('dark-theme');\n        }\n    }\n};\n```\n\n这里写了三个方法，设置localStorage：`setStorage(name,value)`，获取localStorage：`getStorage(name)`，切换主题：`switchTheme()`，localStorage 是浏览器以 name:value 形式的本地存储对象。\n\n`switchTheme`主要做的事情就是，判断当前主题如果是暗黑，就给body加上对应的class，如果不是就去掉。\n\n然后在 index.html 中引用。\n\n```html\n...\n<body>\n    <app>\n        <div class=\"loader\"></div>\n    </app>\n    <script src=\"js/app.js\"></script>\n    <script src=\"_framework/blazor.webassembly.js\"></script>\n</body>\n...\n```\n\n有了这个三个全局的JavaScript方法，切换主题就变得简单多了，看代码。\n\n```CSharp\n...\n/// <summary>\n/// 当前主题\n/// </summary>\nprivate string currentTheme;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    currentTheme = await JSRuntime.InvokeAsync<string>(\"window.func.getStorage\", \"theme\") ?? \"Light\";\n\n    await JSRuntime.InvokeVoidAsync(\"window.func.switchTheme\");\n}\n...\n```\n\n注意在Blazor调用JavaScript方法需要注入`IJSRuntime`接口，`@inject IJSRuntime JSRuntime`。\n\n新建一个变量`currentTheme`，在生命周期函数初始化的时候去调用JavaScript中的`getStorage`方法，获取当前主题，考虑到第一次访问的情况，可以给一个默认值为Light，表示白色主题，然后再去调用switchTheme，执行切换主题的方法。这样页面就会根据`localStorage`的值来确定当前的主题。\n\n```CSharp\n...\n/// <summary>\n/// 切换主题\n/// </summary>\nprivate async Task SwitchTheme()\n{\n    currentTheme = currentTheme == \"Light\" ? \"Dark\" : \"Light\";\n\n    await JSRuntime.InvokeVoidAsync(\"window.func.setStorage\", \"theme\", currentTheme);\n\n    await JSRuntime.InvokeVoidAsync(\"window.func.switchTheme\");\n}\n...\n```\n\n`SwitchTheme()`是切换主题的方法，当我们点击input按钮时可以任意切换，并且主题还要实时跟着变化。\n\n当点击按钮执行`SwitchTheme()`时候改变`currentTheme`的值，然后将`currentTheme`传递给JavaScript方法`setStorage`，最后再次执行切换主题的JavaScript方法即可。\n\n此时变量`currentTheme`也发挥了不少作用，在小屏幕下会显示当前主题的名称，Dark or Light，可以直接将`currentTheme`在HTML中赋值即可。\n\n并且我们input是checkbox类型，当是黑色主题的时候需要时选中的状态，白色主题的时候不选中，这里就可以利用checked属性这样写：`checked=\"@(currentTheme == \"Dark\")\"`。\n\n```html\n<nav class=\"navbar\">\n    <div class=\"container\">\n       ...\n        <div class=\"menu navbar-right\">\n           ...\n            <input id=\"switch_default\" type=\"checkbox\" class=\"switch_default\" @onchange=\"SwitchTheme\" checked=\"@(currentTheme == \"Dark\")\" />\n            <label for=\"switch_default\" class=\"toggleBtn\"></label>\n        </div>\n    </div>\n</nav>\n<nav class=\"navbar\">\n    <div class=\"container\">\n       ...\n        <div class=\"menu navbar-right\">\n           ...\n            <input id=\"switch_default\" type=\"checkbox\" class=\"switch_default\" @onchange=\"SwitchTheme\" checked=\"@(currentTheme == \"Dark\")\" />\n            <label for=\"switch_default\" class=\"toggleBtn\"></label>\n        </div>\n    </div>\n</nav>\n<nav class=\"navbar-mobile\">\n    <div class=\"container\">\n        <div class=\"navbar-header\">\n            <div>\n                <NavLink class=\"menu-item\" href=\"\" Match=\"NavLinkMatch.All\">😍阿星Plus</NavLink>\n                <NavLink @onclick=\"SwitchTheme\">&nbsp;·&nbsp;@currentTheme</NavLink>\n            </div>\n            <div class=\"menu-toggle\" @onclick=\"ToggleNavMenu\">&#9776; Menu</div>\n        </div>\n        <div class=\"menu @NavMenuCssClass\">\n            ...\n        </div>\n    </div>\n</nav>\n```\n\nOK，搞定，快去试试吧。\n\n## 优化代码\n\n现在看起来乱乱的，并且设置获取`localStorage`属于公共的方法，说不定以后也能用到，我们将其封装一下，便于日后的调用，不然要写好多重复的代码。\n\n在Blazor项目根目录添加文件夹Commons，在文件夹下添加一个`Common.cs`，目前用到了`IJSRuntime`，用构造函数注入，然后写几个公共的方法。\n\n```CSharp\n//Common.cs\nusing Microsoft.JSInterop;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BlazorApp.Commons\n{\n    public class Common\n    {\n        private readonly IJSRuntime _jsRuntime;\n\n        public Common(IJSRuntime jsRuntime)\n        {\n            _jsRuntime = jsRuntime;\n        }\n\n        /// <summary>\n        /// 执行无返回值方法\n        /// </summary>\n        /// <param name=\"identifier\"></param>\n        /// <param name=\"args\"></param>\n        /// <returns></returns>\n        public async ValueTask InvokeAsync(string identifier, params object[] args)\n        {\n            await _jsRuntime.InvokeVoidAsync(identifier, args);\n        }\n\n        /// <summary>\n        /// 执行带返回值的方法\n        /// </summary>\n        /// <typeparam name=\"TValue\"></typeparam>\n        /// <param name=\"identifier\"></param>\n        /// <param name=\"args\"></param>\n        /// <returns></returns>\n        public async ValueTask<TValue> InvokeAsync<TValue>(string identifier, params object[] args)\n        {\n            return await _jsRuntime.InvokeAsync<TValue>(identifier, args);\n        }\n\n        /// <summary>\n        /// 设置localStorage\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"value\"></param>\n        /// <returns></returns>\n        public async Task SetStorageAsync(string name, string value)\n        {\n            await InvokeAsync(\"window.func.setStorage\", name, value);\n        }\n\n        /// <summary>\n        /// 获取localStorage\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <returns></returns>\n        public async Task<string> GetStorageAsync(string name)\n        {\n            return await InvokeAsync<string>(\"window.func.getStorage\", name);\n        }\n    }\n}\n```\n\n然后需要在`Program.cs`中注入。\n\n```CSharp\nusing Meowv.Blog.BlazorApp.Commons;\nusing Microsoft.AspNetCore.Components.WebAssembly.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BlazorApp\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var builder = WebAssemblyHostBuilder.CreateDefault(args);\n            builder.RootComponents.Add<App>(\"app\");\n\n            builder.Services.AddTransient(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });\n\n            builder.Services.AddSingleton(typeof(Common));\n\n            await builder.Build().RunAsync();\n        }\n    }\n}\n```\n\n紧接着在`_Imports.razor`中注入使用`Common`，`@inject Commons.Common Common`。\n\n改造一下`Header.razor`，全部代码如下：\n\n```CSharp\n<header>\n    <nav class=\"navbar\">\n        <div class=\"container\">\n            <div class=\"navbar-header header-logo\">\n                <NavLink class=\"menu-item\" href=\"/\" Match=\"NavLinkMatch.All\">\n                    😍阿星Plus\n                </NavLink>\n            </div>\n            <div class=\"menu navbar-right\">\n                <NavLink class=\"menu-item\" href=\"posts\">Posts</NavLink>\n                <NavLink class=\"menu-item\" href=\"categories\">Categories</NavLink>\n                <NavLink class=\"menu-item\" href=\"tags\">Tags</NavLink>\n                <NavLink class=\"menu-item apps\" href=\"apps\">Apps</NavLink>\n                <input id=\"switch_default\" type=\"checkbox\" class=\"switch_default\" @onchange=\"SwitchTheme\" checked=\"@(currentTheme == \"Dark\")\" />\n                <label for=\"switch_default\" class=\"toggleBtn\"></label>\n            </div>\n        </div>\n    </nav>\n    <nav class=\"navbar-mobile\">\n        <div class=\"container\">\n            <div class=\"navbar-header\">\n                <div>\n                    <NavLink class=\"menu-item\" href=\"\" Match=\"NavLinkMatch.All\">😍阿星Plus</NavLink>\n                    <NavLink @onclick=\"SwitchTheme\">&nbsp;·&nbsp;@currentTheme</NavLink>\n                </div>\n                <div class=\"menu-toggle\" @onclick=\"ToggleNavMenu\">&#9776; Menu</div>\n            </div>\n            <div class=\"menu @NavMenuCssClass\">\n                <NavLink class=\"menu-item\" href=\"posts\">Posts</NavLink>\n                <NavLink class=\"menu-item\" href=\"categories\">Categories</NavLink>\n                <NavLink class=\"menu-item\" href=\"tags\">Tags</NavLink>\n                <NavLink class=\"menu-item apps\" href=\"apps\">Apps</NavLink>\n            </div>\n        </div>\n    </nav>\n</header>\n\n@code {\n    /// <summary>\n    /// 下拉菜单是否打开\n    /// </summary>\n    private bool collapseNavMenu = false;\n\n    /// <summary>\n    /// 导航菜单CSS\n    /// </summary>\n    private string NavMenuCssClass => collapseNavMenu ? \"active\" : null;\n\n    /// <summary>\n    /// 显示/隐藏 菜单\n    /// </summary>\n    private void ToggleNavMenu() => collapseNavMenu = !collapseNavMenu;\n\n    /// <summary>\n    /// 当前主题\n    /// </summary>\n    private string currentTheme;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        currentTheme = await Common.GetStorageAsync(\"theme\") ?? \"Light\";\n\n        await Common.InvokeAsync(\"window.func.switchTheme\");\n    }\n\n    /// <summary>\n    /// 切换主题\n    /// </summary>\n    private async Task SwitchTheme()\n    {\n        currentTheme = currentTheme == \"Light\" ? \"Dark\" : \"Light\";\n\n        await Common.SetStorageAsync(\"theme\", currentTheme);\n\n        await Common.InvokeAsync(\"window.func.switchTheme\");\n    }\n}\n```\n\n实现过程比较简单，相信你绝对学会了。本篇就到这里了，未完待续...\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-10 08:58:10"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）",
    "author": "阿星Plus",
    "url": "2020-06-11-blog_23",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客的主题切换，菜单和二维码的显示与隐藏功能，本篇继续完成分页查询文章列表的数据展示。\n\n## 添加页面\n\n现在点击页面上的链接，都会提示错误消息，因为没有找到对应的路由地址。先在Pages下创建五个文件夹：Posts、Categories、Tags、Apps、FriendLinks。\n\n然后在对应的文件夹下添加Razor组件。\n\n- Posts文件夹：文章列表页面`Posts.razor`、根据分类查询文章列表页面`Posts.Category.razor`、根据标签查询文章列表页面`Posts.Tag.razor`、文章详情页`Post.razor`\n- Categories文件夹：分类列表页面`Categories.razor`\n- Tags文件夹：标签列表页面`Tags.razor`\n- Apps文件夹：`Apps.razor`准备将友情链接入口放在里面\n- FriendLinks文件夹：友情链接列表页面`FriendLinks.razor`\n\n先分别创建上面这些Razor组件，差不多除了后台CURD的页面就这些了，现在来逐个突破。\n\n不管三七二十一，先把所有页面的路由给确定了，指定页面路由使用 `@page` 指令，官方文档说不支持可选参数，但是可以支持多个路由规则。\n\n默认先什么都不显示，可以将之前的加载中圈圈写成一个组件，供每个页面使用。\n\n在Shared文件夹添加组件`Loading.razor`。\n\n```html\n<!--Loading.razor-->\n<div class=\"loader\"></div>\n```\n\n```csharp\n//Posts.razor\n@page \"/posts/\"\n@page \"/posts/page/{page:int}\"\n@page \"/posts/{page:int}\"\n\n<Loading />\n\n@code {\n    /// <summary>\n    /// 当前页码\n    /// </summary>\n    [Parameter]\n    public int? page { get; set; }\n}\n```\n\n这里我加了三条，可以匹配没有page参数，带page参数的，`/posts/page/{page:int}`这个大家可以不用加，我是用来兼容目前线上的博客路由的。总的来说可以匹配到：`/posts`、`/posts/1`、`/posts/page/1`这样的路由。\n\n```csharp\n//Posts.Category.razor\n@page \"/category/{name}\"\n\n<Loading />\n\n@code {\n    /// <summary>\n    /// 分类名称参数\n    /// </summary>\n    [Parameter]\n    public string name { get; set; }\n}\n```\n\n根据分类名称查询文章列表页面，name当作分类名称参数，可以匹配到类似于：`/category/aaa`、`/category/bbb`这样的路由。\n\n```csharp\n//Posts.Tag.razor\n@page \"/tag/{name}\"\n\n<Loading />\n\n@code {\n    /// <summary>\n    /// 标签名称参数\n    /// </summary>\n    [Parameter]\n    public string name { get; set; }\n}\n```\n\n这个根据标签名称查询文章列表页面和上面差不多一样，可以匹配到：`/tag/aaa`、`/tag/bbb`这样的路由。\n\n```csharp\n//Post.razor\n@page \"/post/{year:int}/{month:int}/{day:int}/{name}\"\n\n<Loading />\n\n@code {\n    [Parameter]\n    public int year { get; set; }\n\n    [Parameter]\n    public int month { get; set; }\n\n    [Parameter]\n    public int day { get; set; }\n\n    [Parameter]\n    public string name { get; set; }\n}\n```\n\n文章详情页面的路由有点点复杂，以/post/开头，加上年月日和当前文章的语义化名称组成。分别添加了四个参数年月日和名称，用来接收URL的规则，使用int来设置路由的约束，最终可以匹配到路由：`/post/2020/06/09/aaa`、`/post/2020/06/9/bbb`这样的。\n\n```csharp\n//Categories.razor\n@page \"/categories\"\n\n<Loading />\n\n//Tags.razor\n@page \"/tags\"\n\n<Loading />\n\n//FriendLinks.razor\n@page \"/friendlinks\"\n\n<Loading />\n```\n\n分类、标签、友情链接都是固定的路由，像上面这样就不多说了，然后还剩一个`Apps.razor`。\n\n```html\n//Apps.razor\n@page \"/apps\"\n\n<div class=\"container\">\n    <div class=\"post-wrap\">\n        <h2 class=\"post-title\">-&nbsp;Apps&nbsp;-</h2>\n        <ul>\n            <li>\n                <a target=\"_blank\" href=\"https://support.qq.com/products/75616\"><h3>吐个槽_留言板</h3></a>\n            </li>\n            <li>\n                <NavLink href=\"/friendlinks\"><h3>友情链接</h3></NavLink>\n            </li>\n        </ul>\n    </div>\n</div>\n```\n\n在里面添加了一个友情链接的入口，和一个 [腾讯兔小巢](https://support.qq.com/products/75616) 的链接，欢迎大家吐槽留言噢。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200609214326543-1196371440.png)\n\n现在可以运行一下看看，点击所有的链接都不会提示错误，只要路由匹配正确就会出现加载中的圈圈了。\n\n## 文章列表\n\n在做文章列表的数据绑定的时候遇到了大坑，有前端开发经验的都知道，JavaScript弱类型语言中接收json数据随便玩，但是在Blazor中我试了下动态接受传递过来的JSON数据，一直报错压根运行不起来。所以在请求api接收数据的时候需要指定接收对象，那就好办了我就直接引用API中的`.Application.Contracts`就行了啊，但是紧接着坑又来了，目标框架对不上，引用之后也运行不起来，这里应该是之前没有设计好。\n\n于是，我就想了一个折中的办法吧，将API中的返回对象可以用到的DTO先手动拷贝一份到Blazor项目中，后续可以考虑将公共的返回模型做成Nuget包，方便使用。\n\n那么，最终就是在Blazor中添加一个Response文件夹，用来放接收对象，里面的内容看图：\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200609215727896-297305034.png)\n\n有点傻，先这样解决，后面在做进一步的优化吧。\n\n将我们复制进来的东东，在`_Imports.razor`中添加引用。\n\n```csharp\n//_Imports.razor\n@using System.Net.Http\n@using System.Net.Http.Json\n@using Microsoft.AspNetCore.Components.Forms\n@using Microsoft.AspNetCore.Components.Routing\n@using Microsoft.AspNetCore.Components.Web\n@using Microsoft.AspNetCore.Components.WebAssembly.Http\n@using Meowv.Blog.BlazorApp.Shared\n@using Response.Base\n@using Response.Blog\n\n@inject HttpClient Http\n@inject Commons.Common Common\n```\n\n`@inject HttpClient Http`：注入`HttpClient`，用它来请求API数据。\n\n现在有了接收对象，接下来就好办了，来实现分页查询文章列表吧。\n\n先添加三个私有变量，限制条数，就是一次加载文章的数量，总页码用来计算分页，还有就是API的返回数据的接收类型参数。\n\n```csharp\n/// <summary>\n/// 限制条数\n/// </summary>\nprivate int Limit = 15;\n\n/// <summary>\n/// 总页码\n/// </summary>\nprivate int TotalPage;\n\n/// <summary>\n/// 文章列表数据\n/// </summary>\nprivate ServiceResult<PagedList<QueryPostDto>> posts;\n```\n\n然后当页面初始化的时候，去加载数据，渲染页面，因为page参数可能存在为空的情况，所以要考虑进去，当为空的时候给他一个默认值1。\n\n```csharp\n/// <summary>\n/// 初始化\n/// </summary>\nprotected override async Task OnInitializedAsync()\n{\n    // 设置默认值\n    page = page.HasValue ? page : 1;\n\n    await RenderPage(page);\n}\n\n/// <summary>\n/// 点击页码重新渲染数据\n/// </summary>\n/// <param name=\"page\"></param>\n/// <returns></returns>\nprivate async Task RenderPage(int? page)\n{\n    // 获取数据\n    posts = await Http.GetFromJsonAsync<ServiceResult<PagedList<QueryPostDto>>>($\"/blog/posts?page={page}&limit={Limit}\");\n\n    // 计算总页码\n    TotalPage = (int)Math.Ceiling((posts.Result.Total / (double)Limit));\n}\n```\n\n在初始化方法中设置默认值，调用`RenderPage(...)`获取到API返回来的数据，并根据返回数据计算出页码，这样就可以绑定数据了。\n\n```html\n@if (posts == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap archive\">\n        @if (posts.Success && posts.Result.Item.Any())\n        {\n            @foreach (var item in posts.Result.Item)\n            {\n                <h3>@item.Year</h3>\n                @foreach (var post in item.Posts)\n                {\n                    <article class=\"archive-item\">\n                        <NavLink href=\"@(\"/post\" + post.Url)\">@post.Title</NavLink>\n                        <span class=\"archive-item-date\">@post.CreationTime</span>\n                    </article>\n                }\n            }\n            <nav class=\"pagination\">\n                @for (int i = 1; i <= TotalPage; i++)\n                {\n                    var _page = i;\n\n                    if (page == _page)\n                    {\n                        <span class=\"page-number current\">@_page</span>\n                    }\n                    else\n                    {\n                        <a class=\"page-number\" @onclick=\"@(() => RenderPage(_page))\" href=\"/posts/@_page\">@_page</a>\n                    }\n                }\n            </nav>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n在加载数据的时候肯定是需要一个等待时间的，因为不可抗拒的原因数据还没加载出来的时候，可以让它先转一会圈圈，当`posts`不为空的时候，再去绑定数据。\n\n在绑定数据，for循环页码的时候我又遇到了一个坑😂，这里不能直接去使用变量i，必须新建一个变量去接受它，不然我传递给`RenderPage(...)`的参数就会是错的，始终会取到最后一次循环的i值。\n\n当判断数据出错或者没有数据的时候，在把错误提示`<ErrorTip />`扔出来显示。\n\n做到这里，可以去运行看看了，肯定会报错，因为还有一个重要的东西没有改，就是我们接口的`BaseAddress`，在`Program.cs`中，默认是当前Blazor项目的运行地址。\n\n我们需要先将API项目运行起来，拿到地址配置在`Program.cs`中，因为现在还是本地开发，有多种办法可以解决，可以将`.HttpApi.Hosting`设为启动项目直接运行起来，也可以使用命令直接`dotnet run`。\n\n我这里为了方便，直接发布在IIS中，后续只要电脑打开就可以访问了，你甚至选择其它任何你能想到的方式。\n\n关于如何发布这里先不做展开，有机会的话写一篇将.net core开发的项目发布到 Windows、Linux、Docker 的教程吧。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200609222912182-67282542.png)\n\n所以我的`Program.cs`中配置如下：\n\n```csharp\n//Program.cs\nusing Meowv.Blog.BlazorApp.Commons;\nusing Microsoft.AspNetCore.Components.WebAssembly.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nnamespace Meowv.Blog.BlazorApp\n{\n    public class Program\n    {\n        public static async Task Main(string[] args)\n        {\n            var builder = WebAssemblyHostBuilder.CreateDefault(args);\n            builder.RootComponents.Add<App>(\"app\");\n\n            var baseAddress = \"https://localhost\";\n\n            if (builder.HostEnvironment.IsProduction())\n                baseAddress = \"https://api.meowv.com\";\n\n            builder.Services.AddTransient(sp => new HttpClient\n            {\n                BaseAddress = new Uri(baseAddress)\n            });\n\n            builder.Services.AddSingleton(typeof(Common));\n\n            await builder.Build().RunAsync();\n        }\n    }\n}\n```\n\n`baseAddress`默认为本地开发地址，使用`builder.HostEnvironment.IsProduction()`判断是否为线上正式生产环境，改变`baseAddress`地址。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200609223639127-1100272840.gif)\n\n现在可以看到已经可以正常获取数据，并且翻页也是OK的，然后又出现了一个新的BUG😂。\n\n## 解决BUG\n\n细心的可以发现，当我点击头部组件的`Posts`a 标签菜单时候，页面没有发生变化，只是路由改变了。\n\n思来想去，我决定使用`NavigationManager`这个URI和导航状态帮助程序来解决，当点击头部的`Posts`a 标签菜单直接刷新页面得了。\n\n在`Common.cs`中使用构造函数注入`NavigationManager`，然后添加一个跳转指定URL的方法。\n\n```csharp\n/// <summary>\n/// 跳转指定URL\n/// </summary>\n/// <param name=\"uri\"></param>\n/// <param name=\"forceLoad\">true，绕过路由刷新页面</param>\n/// <returns></returns>\npublic async Task RenderPage(string url, bool forceLoad = true)\n{\n    _navigationManager.NavigateTo(url, forceLoad);\n\n    await Task.CompletedTask;\n}\n```\n\n当`forceLoad = true`的时候，将会绕过路由直接强制刷新页面，如果`forceLoad = false`，则不会刷新页面。\n\n紧接着在`Header.razor`中修改代码，添加点击事件。\n\n```html\n@*<NavLink class=\"menu-item\" href=\"posts\">Posts</NavLink>*@\n\n<NavLink class=\"menu-item\" href=\"posts\" @onclick=\"@(async () => await Common.RenderPage(\"posts\"))\">Posts</NavLink>\n```\n\n总算是搞定，完成了分页查询文章列表的数据绑定，今天就到这里吧，未完待续...\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-11 08:54:11"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）",
    "author": "阿星Plus",
    "url": "2020-06-12-blog_24",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://www.cnblogs.com/meowv/p/12896177.html)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://www.cnblogs.com/meowv/p/12896898.html)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://www.cnblogs.com/meowv/p/12909558.html)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://www.cnblogs.com/meowv/p/12913676.html)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://www.cnblogs.com/meowv/p/12916613.html)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://www.cnblogs.com/meowv/p/12924409.html)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://www.cnblogs.com/meowv/p/12924859.html)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://www.cnblogs.com/meowv/p/12935693.html)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://www.cnblogs.com/meowv/p/12943699.html)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://www.cnblogs.com/meowv/p/12956696.html)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://www.cnblogs.com/meowv/p/12961014.html)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://www.cnblogs.com/meowv/p/12966092.html)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://www.cnblogs.com/meowv/p/12971041.html)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://www.cnblogs.com/meowv/p/12974439.html)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://www.cnblogs.com/meowv/p/12980301.html)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://www.cnblogs.com/meowv/p/12987623.html)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://www.cnblogs.com/meowv/p/12994914.html)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://www.cnblogs.com/meowv/p/13039883.html)**\n\n---\n\n上篇文章完成了文章增删改的接口和友情链接列表的接口，本篇继续。\n\n善于思考的同学肯定发现，在执行增删改操作后，Redis缓存中的数据还是存在的，也就意味着查询接口返回的数据还是旧的，所以在写接口之前，先完成一下清缓存的操作。\n\n## 移除缓存\n\n移除缓存我这里找了一个新的包：`Caching.CSRedis`，选他是因为微软的包`Microsoft.Extensions.Caching.StackExchangeRedis`没有给我们实现批量删除的功能。\n\n`Caching.CSRedis`开源地址，https://github.com/2881099/csredis 在这不做过多介绍，感兴趣的自己去看。\n\n在`.Application.Caching`层添加包`Caching.CSRedis`，`Install-Package Caching.CSRedis`，然后在模块类`MeowvBlogApplicationCachingModule`中进行配置。\n\n```CSharp\n//MeowvBlogApplicationCachingModule.cs\n...\npublic override void ConfigureServices(ServiceConfigurationContext context)\n{\n    ...\n\n    var csredis = new CSRedis.CSRedisClient(AppSettings.Caching.RedisConnectionString);\n    RedisHelper.Initialization(csredis);\n\n    context.Services.AddSingleton<IDistributedCache>(new CSRedisCache(RedisHelper.Instance));\n}\n...\n```\n\n直接新建一个移除缓存的接口：`ICacheRemoveService`，添加移除缓存的方法`RemoveAsync()`。代码较少，可以直接写在缓存基类`CachingServiceBase`中。\n\n```CSharp\npublic interface ICacheRemoveService\n{\n    /// <summary>\n    /// 移除缓存\n    /// </summary>\n    /// <param name=\"key\"></param>\n    /// <param name=\"cursor\"></param>\n    /// <returns></returns>\n    Task RemoveAsync(string key, int cursor = 0);\n}\n```\n\n然后可以在基类中实现这个接口。\n\n```CSharp\npublic async Task RemoveAsync(string key, int cursor = 0)\n{\n    var scan = await RedisHelper.ScanAsync(cursor);\n    var keys = scan.Items;\n\n    if (keys.Any() && key.IsNotNullOrEmpty())\n    {\n        keys = keys.Where(x => x.StartsWith(key)).ToArray();\n\n        await RedisHelper.DelAsync(keys);\n    }\n}\n```\n\n简单说一下这个操作过程，使用`ScanAsync()`获取到所有的Redis key值，返回的是一个string数组，然后根据参数找到符合此前缀的所有key，最后调用`DelAsync(keys)`删除缓存。\n\n在需要有移除缓存功能的接口上继承`ICacheRemoveService`，这里就是`IBlogCacheService`。\n\n```CSharp\n//IBlogCacheService.cs\nnamespace Meowv.Blog.Application.Caching.Blog\n{\n    public partial interface IBlogCacheService : ICacheRemoveService\n    {\n    }\n}\n```\n\n在基类中已经实现了这个接口，所以现在所有继承基类的缓存实现类都可以调用移除缓存方法了。\n\n在`MeowvBlogConsts`中添加缓存前缀的常量。\n\n```CSharp\n//MeowvBlogConsts.cs\n/// <summary>\n/// 缓存前缀\n/// </summary>\npublic static class CachePrefix\n{\n    public const string Authorize = \"Authorize\";\n\n    public const string Blog = \"Blog\";\n\n    public const string Blog_Post = Blog + \":Post\";\n\n    public const string Blog_Tag = Blog + \":Tag\";\n\n    public const string Blog_Category = Blog + \":Category\";\n\n    public const string Blog_FriendLink = Blog + \":FriendLink\";\n}\n```\n\n然后在`BlogService.Admin.cs`服务执行增删改后调用移除缓存的方法。\n\n```CSharp\n//BlogService.Admin.cs\n\n// 执行清除缓存操作\nawait _blogCacheService.RemoveAsync(CachePrefix.Blog_Post);\n```\n\n因为是小项目，采用这种策略直接删除缓存，这样就搞定了当在执行增删改操作后，前台接口可以实时查询出最后的结果。\n\n## 文章详情\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200604135933251-1454347843.png)\n\n当我们修改文章数据的时候，是需要把当前数据库中的数据带出来显示在界面上的，因为有可能只是个别地方需要修改，所以这还需要一个查询文章详情的接口，当然这里的详情和前端的是不一样的，这里是需要根据Id主键去查询。\n\n添加模型类`PostForAdminDto.cs`，直接继承`PostDto`，然后添加一个Tags列表就行，==，好像和上一篇文章中的`EditPostInput`字段是一模一样的。顺手将`EditPostInput`改一下吧，具体代码如下：\n\n```CSharp\n//PostForAdminDto.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.Application.Contracts.Blog\n{\n    public class PostForAdminDto : PostDto\n    {\n        /// <summary>\n        /// 标签列表\n        /// </summary>\n        public IEnumerable<string> Tags { get; set; }\n    }\n}\n\n//EditPostInput.cs\nnamespace Meowv.Blog.Application.Contracts.Blog.Params\n{\n    public class EditPostInput : PostForAdminDto\n    {\n    }\n}\n```\n\n在`IBlogService.Admin.cs`中添加接口。\n\n```CSharp\n/// <summary>\n/// 获取文章详情\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nTask<ServiceResult<PostForAdminDto>> GetPostForAdminAsync(int id);\n```\n\n实现这个接口。\n\n```CSharp\n/// <summary>\n/// 获取文章详情\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\npublic async Task<ServiceResult<PostForAdminDto>> GetPostForAdminAsync(int id)\n{\n    var result = new ServiceResult<PostForAdminDto>();\n\n    var post = await _postRepository.GetAsync(id);\n\n    var tags = from post_tags in await _postTagRepository.GetListAsync()\n               join tag in await _tagRepository.GetListAsync()\n               on post_tags.TagId equals tag.Id\n               where post_tags.PostId.Equals(post.Id)\n               select tag.TagName;\n\n    var detail = ObjectMapper.Map<Post, PostForAdminDto>(post);\n    detail.Tags = tags;\n    detail.Url = post.Url.Split(\"/\").Where(x => !string.IsNullOrEmpty(x)).Last();\n\n    result.IsSuccess(detail);\n    return result;\n}\n```\n\n先根据Id查出文章数据，再通过联合查询找出标签数据。\n\n```CSharp\nCreateMap<Post, PostForAdminDto>().ForMember(x => x.Tags, opt => opt.Ignore());\n```\n\n新建一条AutoMapper配置，将`Post`转换成`PostForAdminDto`，忽略Tags。\n\n然后将查出来的标签、Url赋值给DTO，输出即可。在`BlogController.Admin`中添加API。\n\n```CSharp\n/// <summary>\n/// 获取文章详情\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\n[HttpGet]\n[Authorize]\n[Route(\"admin/post\")]\n[ApiExplorerSettings(GroupName = Grouping.GroupName_v2)]\npublic async Task<ServiceResult<PostForAdminDto>> GetPostForAdminAsync([Required] int id)\n{\n    return await _blogService.GetPostForAdminAsync(id);\n}\n```\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200604144612021-1493627466.png)\n\n至此，完成了关于文章的所有接口。\n\n接下来按照以上方式依次完成分类、标签、友链的增删改查接口，我觉得如果你有跟着我一起做，剩下的可以自己完成。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-12 08:57:12"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）",
    "author": "阿星Plus",
    "url": "2020-06-13-blog_25",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了分类标签友链的列表查询页面数据绑定，还剩下一个文章详情页的数据没有绑，现在简单的解决掉。\n\n## 文章详情\n\n之前已经添加了四个参数：year、month、day、name，用来组成我们最终的URL，继续添加一个参数用来接收API返回的数据。\n\n```csharp\n[Parameter]\npublic int year { get; set; }\n\n[Parameter]\npublic int month { get; set; }\n\n[Parameter]\npublic int day { get; set; }\n\n[Parameter]\npublic string name { get; set; }\n\n/// <summary>\n/// URL\n/// </summary>\nprivate string url => $\"/{year}/{(month >= 10 ? month.ToString() : $\"0{month}\")}/{(day >= 10 ? day.ToString() : $\"0{day}\")}/{name}/\";\n\n/// <summary>\n/// 文章详情数据\n/// </summary>\nprivate ServiceResult<PostDetailDto> post;\n```\n\n然后在初始化方法`OnInitializedAsync()`中请求数据。\n\n```csharp\n/// <summary>\n/// 初始化\n/// </summary>\nprotected override async Task OnInitializedAsync()\n{\n    // 获取数据\n    post = await Http.GetFromJsonAsync<ServiceResult<PostDetailDto>>($\"/blog/post?url={url}\");\n}\n```\n\n现在拿到了post数据，然后在HTML中绑定即可。\n\n```html\n@if (post == null)\n{\n    <Loading />\n}\nelse\n{\n    @if (post.Success)\n    {\n        var _post = post.Result;\n\n        <article class=\"post-wrap\">\n            <header class=\"post-header\">\n                <h1 class=\"post-title\">@_post.Title</h1>\n                <div class=\"post-meta\">\n                    Author: <a itemprop=\"author\" rel=\"author\" href=\"javascript:;\">@_post.Author</a>\n                    <span class=\"post-time\">\n                        Date: <a href=\"javascript:;\">@_post.CreationTime</a>\n                    </span>\n                    <span class=\"post-category\">\n                        Category:<a href=\"/category/@_post.Category.DisplayName/\">@_post.Category.CategoryName</a>\n                    </span>\n                </div>\n            </header>\n            <div class=\"post-content\" id=\"content\">\n                @((MarkupString)_post.Html)\n            </div>\n            <section class=\"post-copyright\">\n                <p class=\"copyright-item\">\n                    <span>Author:</span>\n                    <span>@_post.Author</span>\n                </p>\n                <p class=\"copyright-item\">\n                    <span>Permalink:</span>\n                    <span><a href=\"/post@_post.Url\">https://meowv.com/post@_post.Url</a></span>\n                </p>\n                <p class=\"copyright-item\">\n                    <span>License:</span>\n                    <span>本文采用<a target=\"_blank\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\"> 知识共享 署名-非商业性使用-禁止演绎(CC BY-NC-ND)国际许可协议 </a>进行许可</span>\n                </p>\n            </section>\n            <section class=\"post-tags\">\n                <div>\n                    <span>Tag(s):</span>\n                    <span class=\"tag\">\n                        @if (_post.Tags.Any())\n                        {\n                            @foreach (var tag in _post.Tags)\n                            {\n                                <a href=\"/tag/@tag.DisplayName/\"># @tag.TagName</a>\n                            }\n                        }\n                    </span>\n                </div>\n                <div>\n                    <a @onclick=\"async () => await Common.BaskAsync()\">back</a>\n                    <span>· </span>\n                    <a href=\"/\">home</a>\n                </div>\n            </section>\n            <section class=\"post-nav\">\n                @if (_post.Previous != null)\n                {\n                    <a class=\"prev\"\n                       rel=\"prev\"\n                       @onclick=\"@(async () => await Common.NavigateTo($\"/post{_post.Previous.Url}, true))\"\n                       href=\"/post@_post.Previous.Url\">@_post.Previous.Title</a>\n                }\n                @if (_post.Next != null)\n                {\n                    <a class=\"next\"\n                       rel=\"next\"\n                       @onclick=\"@(async () => await Common.NavigateTo($\"/post{_post.Next.Url}\", true))\"\n                       href=\"/post@_post.Next.Url\">\n                        @_post.Next.Title\n                    </a>\n                }\n            </section>\n        </article>\n    }\n    else\n    {\n        <ErrorTip />\n    }\n}\n```\n\n其中有几个地方需要注意一下：\n\n我们从post对象中取到的文章内容HTML，直接显示是不行了，需要将其解析为HTML标签，需要用到`MarkupString`。\n\n然后页面上有一个后退按钮，这里我在`Common.cs`中写了一个方法来实现。\n\n```csharp\n/// <summary>\n/// 后退\n/// </summary>\n/// <returns></returns>\npublic async Task BaskAsync()\n{\n    await InvokeAsync(\"window.history.back\");\n}\n```\n\n还有就是上一篇和下一篇的问题，将具体的URL传递给`NavigateTo()`方法，然后跳转过去即可。\n\n在`Common.cs`中将之前文章创建`RenderPage()`方法修改成`NavigateTo()`。这个命名更好一点。\n\n```csharp\n/// <summary>\n/// 跳转指定URL\n/// </summary>\n/// <param name=\"uri\"></param>\n/// <param name=\"forceLoad\">true，绕过路由刷新页面</param>\n/// <returns></returns>\npublic async Task NavigateTo(string url, bool forceLoad = false)\n{\n    _navigationManager.NavigateTo(url, forceLoad);\n\n    await Task.CompletedTask;\n}\n```\n\n现在数据算是绑定完了，但是遇到了一个大问题，就是详情页面的样式问题，因为用到了Markdown，所以之前是加载了许多JS文件来处理的。那么现在肯定行不通了，所以关于详情页的样式问题暂时搁浅，让我寻找一下好多解决方式。\n\n现在显示是没有问题了，就是不太好看，还有关于添加文章的功能，不知道有什么好的 Markdown 编辑器可以推荐我使用。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200611205625058-211827502.png)\n\n到这里Blazor的前端展示页面已经全部弄完了，接下来开始写后台相关的页面。\n\n## 后台首页\n\n关于后台管理的所有页面都放在Admin文件夹下，在Pages文件夹下新建Admin文件夹，然后先添加两个组件页面：`Admin.razor`、`Auth.razor`。\n\n`Admin.razor`为后台管理的首页入口，我们在里面直接添加几个预知的链接并设置其路由。\n\n```html\n@page \"/admin\"\n\n<div class=\"post-wrap\">\n    <h2 class=\"post-title\">-&nbsp;博客内容管理&nbsp;-</h2>\n    <ul>\n        <li>\n            <a href=\"/admin/post\"><h3>📝~~~ 新增文章 ~~~📝</h3></a>\n        </li>\n        <li>\n            <a href=\"/admin/posts\"><h3>📗~~~ 文章管理 ~~~📗</h3></a>\n        </li>\n        <li>\n            <a href=\"/admin/categories\"><h3>📕~~~ 分类管理 ~~~📕</h3></a>\n        </li>\n        <li>\n            <a href=\"/admin/tags\"><h3>📘~~~ 标签管理 ~~~📘</h3></a>\n        </li>\n        <li>\n            <a href=\"/admin/friendlinks\"><h3>📒~~~ 友链管理 ~~~📒</h3></a>\n        </li>\n    </ul>\n</div>\n```\n\n里面的a标签所对应的页面还没有添加，等做到的时候再加，先手动访问这个页面看看，当成功授权后就跳到这个页面来。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200611211032993-1424190424.png)\n\n## 认证授权\n\n关于授权，因为之前在API中已经完成了基于Github的JWT模式的认证授权模式，所以这里我想做一个无感的授权功能，为什么说无感呢，因为在我使用GitHub登录的过程中，如果之前已经登录过且没有清除浏览器cookie数据，下次再登录的时候会默认直接登录成功，从而达到无感的。\n\n实现逻辑其实也很简单，我这里用到了`Common.cs`中之前添加的公共方法设置和获取`localStorage`的方法，我会将token等信息放入`localStorage`中。\n\n我设置的路由是：`/auth`。这个路由需要和 GitHub OAuth App 的回调地址一致，当登录成功，会回调跳到配置的页面并携带code参数。\n\n在获取请求参数这块需要引用一个包：`Microsoft.AspNetCore.WebUtilities`，添加好后在`_Imports.razor`添加引用：`@using Meowv.Blog.BlazorApp.Shared`。\n\n默认还是显示加载中的组件：`<Loading />`。\n\n然后在`@code{}`中编写代码，添加页面初始化函数。\n\n```csharp\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    // localStorage中access_token值\n    var access_token = await Common.GetStorageAsync(\"access_token\");\n\n    // access_token有值\n    if (!string.IsNullOrEmpty(access_token))\n    {\n        // 获取token\n        var _token = await Http.GetFromJsonAsync<ServiceResult<string>>($\"/auth/token?access_token={access_token}\");\n        if (_token.Success)\n        {\n            // 将token存入localStorage\n            await Common.SetStorageAsync(\"token\", _token.Result);\n\n            // 跳转至后台首页\n            await Common.NavigateTo(\"/admin\");\n        }\n        else\n        {\n            // access_token失效，或者请求失败的情况下，重新执行一次验证流程\n            await AuthProcessAsync();\n        }\n    }\n    else //access_token为空\n    {\n        await AuthProcessAsync();\n    }\n}\n```\n\n先去获取`localStorage`中的access_token值，肯定会有两种情况，有或者没有，然后分别去走不同的逻辑。\n\n当access_token有值，就可以直接拿access_token去取token的值，理想情况请求成功拿到了token，这时候可以将token存到浏览器中，然后正常跳转至后台管理首页，还有就是取token失败了，失败了就有可能是access_token过期了或者出现异常情况，这时候我们不去提示错误，直接抛弃所有，重新来一遍认证授权的流程，放在一个单独的方法中`AuthProcessAsync()`。\n\n而当access_token没值那就好办了，也去来一遍认证授权的流程即可。\n\n验证流程`AuthProcessAsync()`的代码。\n\n```csharp\n/// <summary>\n/// 验证流程\n/// </summary>\n/// <returns></returns>\nprivate async Task AuthProcessAsync()\n{\n    // 当前URI对象\n    var uri = await Common.CurrentUri();\n\n    // 是否回调携带了code参数\n    bool hasCode = QueryHelpers.ParseQuery(uri.Query).TryGetValue(\"code\", out Microsoft.Extensions.Primitives.StringValues code);\n\n    if (hasCode)\n    {\n        var access_token = await Http.GetFromJsonAsync<ServiceResult<string>>($\"/auth/access_token?code={code}\");\n        if (access_token.Success)\n        {\n            // 将access_token存入localStorage\n            await Common.SetStorageAsync(\"access_token\", access_token.Result);\n\n            var token = await Http.GetFromJsonAsync<ServiceResult<string>>($\"/auth/token?access_token={access_token.Result}\");\n            if (token.Success)\n            {\n                // 将token存入localStorage\n                await Common.SetStorageAsync(\"token\", token.Result);\n\n                // 成功认证授权，跳转至后台管理首页\n                await Common.NavigateTo(\"/admin\");\n            }\n            else\n            {\n                // 没有权限的人，回到首页去吧\n                await Common.NavigateTo(\"/\");\n\n                // 输出提示信息\n                Console.WriteLine(token.Message);\n            }\n        }\n        else\n        {\n            // 出错了，回到首页去吧\n            await Common.NavigateTo(\"/\");\n\n            // 输出提示信息\n            Console.WriteLine(access_token.Message);\n        }\n    }\n    else\n    {\n        // 获取第三方登录地址\n        var loginAddress = await Http.GetFromJsonAsync<ServiceResult<string>>(\"/auth/url\");\n\n        // 跳转到登录页面\n        await Common.NavigateTo(loginAddress.Result);\n    }\n}\n```\n\n验证流程的逻辑先获取当前URI对象，判断URI中是否携带了code参数，从而可以知道当前页面是回调的过来的还是直接请求的，获取当前URI对象放在`Common.cs`中。\n\n```csharp\n/// <summary>\n/// 获取当前URI对象\n/// </summary>\n/// <returns></returns>\npublic async Task<Uri> CurrentUri()\n{\n    var uri = _navigationManager.ToAbsoluteUri(_navigationManager.Uri);\n\n    return await Task.FromResult(uri);\n}\n```\n\n在刚才添加的包`Microsoft.AspNetCore.WebUtilities`中为我们封装好了解析URI参数的方法。\n\n使用`QueryHelpers.ParseQuery(...)`获取code参数的值。\n\n当没有值的时候，直接取请求登录地址，然后如果登录成功就会跳转到携带code参数的回调页面。这样流程就又回到了 验证流程 开始的地方了。\n\n登录成功，此时code肯定就有值了，那么直接根据code获取access_token，存入`localStorage`，正常情况拿到access_token就去生成token，然后也存入`localStorage`，成功授权可以跳到后台管理首页了。\n\n其中如果有任何一个环节出现问题，直接跳转到网站首页去。如果授权不成功肯定是你在瞎搞(不接受任何反驳🤣🤣)，赶紧回到首页去吧。\n\n现在流程走完，去看看效果。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200611215254581-565964907.gif)\n\nGitHub在国内的情况大家知道，有时候慢甚至打不开，有时候还是挺快的，还好今天没掉链子，我遇到过好几次压根打不开的情况，获取可以针对网络不好的时候我们换成其它的验证方式，这个以后有机会再优化吧。\n\n## 验证组件\n\n这个时候会发现，其实我们压根不需要打开`/auth`走验证流程，直接访问`/admin`就可以进来管理首页，这是极其不合理的。那岂不是谁知道地址谁都能进来瞎搞了。所以我们可以在 Shared 文件夹下添加一个权限验证的组件：`AdminLayout.razor`。用来判断是否真的登录了。\n\n新建一个bool类型的变量 isLogin。默认肯定是false，此时可以让页面转圈圈，使用`<Loading />`组件。当`isLogin = true`的时候我们才展示具体的HTML内容。\n\n那么就需要用到服务端组件`RenderFragment`，他有一个固定的参数名称`ChildContent`。\n\n判断是否登录的方法可以写在初始化方法中，这里还少了一个API，就是判断当前token的值是否合法，合法就表示已经成功执行了验证流程了。token不存在或者不合法，直接拒绝请求返回到首页去吧。\n\n整个代码如下：\n\n```csharp\n@if (!isLogin)\n{\n    <Loading />\n}\nelse\n{\n    @ChildContent\n}\n\n@code {\n    /// <summary>\n    /// 展示内容\n    /// </summary>\n    [Parameter]\n    public RenderFragment ChildContent { get; set; }\n\n    /// <summary>\n    /// 是否登录\n    /// </summary>\n    private bool isLogin { get; set; }\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n\n        if (string.IsNullOrEmpty(token))\n        {\n            isLogin = false;\n\n            await Common.NavigateTo(\"/\");\n        }\n        else\n        {\n            // TODO:判断token是否合法，先默认都是正确的\n            isLogin = true;\n        }\n    }\n}\n```\n\n使用这个组件也很方便了，我们后台所有页面都引用`AdminLayout`，将展示内容传递给就行了，成功验证后就会展示HTM内容。\n\n在`Admin.razor`中使用。\n\n```html\n@page \"/admin\"\n\n<AdminLayout>\n    <div class=\"post-wrap\">\n        <h2 class=\"post-title\">-&nbsp;博客内容管理&nbsp;-</h2>\n        <ul>\n            <li>\n                <a href=\"/admin/post\"><h3>📝~~~ 新增文章 ~~~📝</h3></a>\n            </li>\n            <li>\n                <a href=\"/admin/posts\"><h3>📗~~~ 文章管理 ~~~📗</h3></a>\n            </li>\n            <li>\n                <a href=\"/admin/categories\"><h3>📕~~~ 分类管理 ~~~📕</h3></a>\n            </li>\n            <li>\n                <a href=\"/admin/tags\"><h3>📘~~~ 标签管理 ~~~📘</h3></a>\n            </li>\n            <li>\n                <a href=\"/admin/friendlinks\"><h3>📒~~~ 友链管理 ~~~📒</h3></a>\n            </li>\n        </ul>\n    </div>\n</AdminLayout>\n```\n\n现在清除掉浏览器缓存，去请求`/admin`试试。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200611221047660-1526078533.gif)\n\n完美，比较简单的实现了验证是否登录的组件。其中还有许多地方可以优化，就交给大家去自行完成了😎。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-13 09:11:13"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）",
    "author": "阿星Plus",
    "url": "2020-06-15-blog_26",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了博客文章详情页面的数据展示和基于JWT方式的简单身份验证，本篇继续推进，完成后台分类管理的所有增删改查等功能。\n\n## 分类管理\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614120830057-679897613.png)\n\n在 Admin 文件夹下新建Razor组件，`Categories.razor`，设置路由，`@page \"/admin/categories\"`。将具体的展示内容放在组件`AdminLayout`中。\n\n```\n\n```\n\n@page \"/admin/categories\"\n\n<AdminLayout>\n      <Loading />\n</AdminLayout>\n```\n\n在这里我会将所有分类展示出来，新增、更新、删除都会放在一个页面上去完成。\n\n先将列表查出来，添加API的返回参数，`private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;`，然后再初始化中去获取数据。\n\n```csharp\n//QueryCategoryForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryCategoryForAdminDto : QueryCategoryDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n```csharp\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    categories = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n}\n```\n\n初始化的时候，需要将我们存在`localStorage`中的token读取出来，因为我们后台的API都需要添加 `Authorization` Header 请求头才能成功返回数据。\n\n在Blazor添加请求头也是比较方便的，直接`Http.DefaultRequestHeaders.Add(...)`即可，要注意的是 token值前面需要加 `Bearer `，跟了一个空格不可以省略。\n\n获取数据单独提成了一个方法`FetchData()`，因为会频繁用到，现在在页面上将数据绑定进行展示。\n\n```html\n@if (categories == null)\n{\n    <Loading />\n}\nelse\n{\n    <div class=\"post-wrap categories\">\n        <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n        @if (categories.Success && categories.Result.Any())\n        {\n            <div class=\"categories-card\">\n                @foreach (var item in categories.Result)\n                {\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                            <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                <h3>@item.CategoryName</h3>\n                                <small>(@item.Count)</small>\n                            </NavLink>\n                        </div>\n                    </div>\n                }\n                <div class=\"card-item\">\n                    <div class=\"categories\">\n                        <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                    </div>\n                </div>\n            </div>\n        }\n        else\n        {\n            <ErrorTip />\n        }\n    </div>\n}\n```\n\n同样的当categories还没成功获取到数据的时候，我们直接在展示 `<Loading />`组件。然后就是循环列表数据在`foreach`中进行绑定数据。\n\n在每条数据最前面，加了删除和编辑两个按钮，删除的时候调用`DeleteAsync`方法，将当前分类的Id传给他即可。新增和编辑的时候调用`ShowBox`方法，他接受一个参数，当前循环到的分类对象item，即`QueryCategoryForAdminDto`。\n\n同时这里考虑到复用性，我写了一个弹窗组件，`Box.Razor`，放在Shared文件夹下面，可以先看一下标题为弹窗组件的内容再回来继续往下看。\n\n### 删除分类\n\n接下来看看删除方法。\n\n```csharp\n/// <summary>\n/// 删除分类\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            categories = await FetchData();\n        }\n    }\n}\n```\n\n删除之前搞个原生的`confirm`进行提示，避免手残误删。因为API那边使用的是`HttpDelete`，所有我们调用API时候要用`Http.DeleteAsync`，返回的是`HttpResponseMessage`对象，需要我们手动处理接收返回数据，将其转换为`ServiceResult`对象，如果判断删除成功后重新调用`FetchData()`刷新分类数据。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121205461-1669190603.gif)\n\n### 新增/更新分类\n\n新增和更新数据选择使用弹窗的方式来进行(弹窗组件在下方)，首先是需要一个参数判断弹窗是否打开，因为是将新增和更新放在一起，所以如何判断是新增还是更新呢？这里使用Id来进行判断，当编辑的时候肯定会有Id参数。新增的时候是没有参数传递的。\n\n当我们打开弹窗后里面需要展示两个input框，用来供输入要保存的数据，同样是添加两个变量。\n\n添加所需的这几个参数。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的分类字段值\n/// </summary>\nprivate string categoryName, displayName;\n\n/// <summary>\n/// 更新分类的Id值\n/// </summary>\nprivate int id;\n```\n\n现在可以将Box组件添加到页面上。\n\n```html\n<div class=\"post-wrap categories\">\n\t...\n</div>\n\n<Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n    <div class=\"box-item\">\n        <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n    </div>\n    <div class=\"box-item\">\n        <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n    </div>\n</Box>\n```\n\n确定按钮回调事件执行`SubmitAsync()`方法，打开状态参数为上面添加的`Open`，按钮文字`ButtonText`为默认值不填。\n\n添加了两个input，将两个分类字段分别绑定上去，使用`@bind`和`@bind:event`。前者等价于设置其value值，后者等价于一个change事件当值改变后会重新赋给绑定的字段参数。\n\n现在可以来看看点击了新增或者编辑按钮的方法`ShowBox(...)`，接收一个参数`QueryCategoryForAdminDto`让其默认值为null。\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryCategoryForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        categoryName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        categoryName = dto.CategoryName;\n    }\n}\n```\n\n执行`ShowBox()`方法，将弹窗打开，设置`Open = true;`和初始化id的值`id = 0;`。\n\n通过参数是否null进行判断是新增还是更新，这样打开弹窗就搞定了，剩下的就交给弹窗来处理了。\n\n因为新增和更新API需要还对应的输入参数`EditCategoryInput`，去添加它不要忘了。\n\n那么现在就只差按钮回调事件`SubmitAsync()`了，主要是给输入参数进行赋值调用API，执行新增或者更新即可。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditCategoryInput()\n    {\n        DisplayName = displayName.Trim(),\n        CategoryName = categoryName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        categories = await FetchData();\n        Open = false;\n    }\n}\n```\n\n当参数为空时，直接`return`什么都不执行。通过当前Id判断是新增还是更新操作，调用不同的方法`PutAsJsonAsync`和`PostAsJsonAsync`去请求API，同样返回到是`HttpResponseMessage`对象，最后如果操作成功，重新请求一个数据，刷新分类列表，将弹窗关闭掉。\n\n分类管理页面的全部代码如下：\n\n<details>\n<summary>点击查看代码</summary>\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n</details>\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614121519003-213824093.gif)\n\n## 弹窗组件\n\n考虑到新增和更新数据的时候需要弹窗，这里就简单演示一下写一个小组件。\n\n在 Shared 文件夹下新建一个`Box.razor`。\n\n在开始之前分析一下弹窗组件所需的元素，弹窗肯定有一个确认和取消按钮，右上角需要有一个关闭按钮，关闭按钮和取消按钮一个意思。他还需要一个打开或者关闭的状态，判断是否打开弹窗，还有就是弹窗内需要自定义展示内容。\n\n确定按钮的文字可以自定义，所以差不多就需要3个参数，组件内容`RenderFragment ChildContent`，是否打开弹窗`bool Open`默认隐藏，按钮文字`string ButtonText`默认值给\"确定\"。然后最重要的是确定按钮需要一个回调事件，`EventCallback<MouseEventArgs> OnClickCallback` 用于执行不同的事件。\n\n```csharp\n/// <summary>\n/// 组件内容\n/// </summary>\n[Parameter]\npublic RenderFragment ChildContent { get; set; }\n\n/// <summary>\n/// 是否隐藏\n/// </summary>\n[Parameter]\npublic bool Open { get; set; } = true;\n\n/// <summary>\n/// 按钮文字\n/// </summary>\n[Parameter]\npublic string ButtonText { get; set; } = \"确定\";\n\n/// <summary>\n/// 确认按钮点击事件回调\n/// </summary>\n[Parameter]\npublic EventCallback<MouseEventArgs> OnClickCallback { get; set; }\n\n/// <summary>\n/// 关闭Box\n/// </summary>\nprivate void Close() => Open = false;\n```\n\n右上角关闭和取消按钮直接在内部进行处理，执行`Close()`方法，将参数`Open`值设置为false即可。\n\n对应的html如下。\n\n```html\n@if (Open)\n{\n    <div class=\"shadow\"></div>\n    <div class=\"box\">\n        <div class=\"close\" @onclick=\"Close\">❌</div>\n        <div class=\"box-content\">\n            @ChildContent\n            <div class=\"box-item box-item-btn\">\n                <button class=\"box-btn\" @onclick=\"OnClickCallback\">@ButtonText</button>\n                <button class=\"box-btn btn-primary\" @onclick=\"Close\">取消</button>\n            </div>\n        </div>\n    </div>\n}\n```\n\n## 关于样式\n\n下面是弹窗组件所需的样式代码，大家需要的自取，也可以直接去GitHub实时获取最新的样式文件。\n\n```css\n.box {\n    width: 600px;\n    height: 300px;\n    border-radius: 5px;\n    background-color: #fff;\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    margin-top: -150px;\n    margin-left: -300px;\n    z-index: 997;\n}\n.close {\n    position: absolute;\n    right: 3px;\n    top: 2px;\n    cursor: pointer;\n}\n.shadow {\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    left: 0;\n    top: 0;\n    z-index: 996;\n    background-color: #000;\n    opacity: 0.3;\n}\n.box-content {\n    width: 90%;\n    margin: 20px auto;\n}\n.box-item {\n    margin-top: 10px;\n    height: 30px;\n}\n.box-item b {\n    width: 130px;\n    display: inline-block;\n}\n.box-item input[type=text] {\n    padding-left: 5px;\n    width: 300px;\n    height: 30px;\n}\n.box-item label {\n    width: 100px;\n    white-space: nowrap;\n}\n.box-item input[type=radio] {\n    width: auto;\n    height: auto;\n    visibility: initial;\n    display: initial;\n    margin-right: 2px;\n}\n.box-item button {\n    height: 30px;\n    width: 100px;\n}\n.box-item-btn {\n    position: absolute;\n    right: 20px;\n    bottom: 20px;\n}\n.box-btn {\n    display: inline-block;\n    height: 30px;\n    line-height: 30px;\n    padding: 0 18px;\n    background-color: #5A9600;\n    color: #fff;\n    white-space: nowrap;\n    text-align: center;\n    font-size: 14px;\n    border: none;\n    border-radius: 2px;\n    cursor: pointer;\n}\nbutton:focus {\n    outline: 0;\n}\n.box-btn:hover {\n    opacity: .8;\n    filter: alpha(opacity=80);\n    color: #fff;\n}\n.btn-primary {\n    border: 1px solid #C9C9C9;\n    background-color: #fff;\n    color: #555;\n}\n.btn-primary:hover {\n    border-color: #5A9600;\n    color: #333;\n}\n.post-box {\n    width: 98%;\n    margin: 27px auto 0;\n}\n.post-box-item {\n    width: 100%;\n    height: 30px;\n    margin-bottom: 5px;\n}\n.post-box-item input {\n    width: 49.5%;\n    height: 30px;\n    padding-left: 5px;\n    border: 1px solid #ddd;\n}\n.post-box-item input:nth-child(1) {\n    float: left;\n    margin-right: 1px;\n}\n.post-box-item input:nth-child(2) {\n    float: right;\n    margin-left: 1px;\n}\n.post-box .box-item b {\n    width: auto;\n}\n.post-box .box-item input[type=text] {\n    width: 90%;\n}\n```\n\n好了，分类模块的功能都完成了，标签和友情链接的管理界面还会远吗？这两个模块的做法和分类是一样的，有兴趣的可以自己动手完成，今天到这吧，未完待续...\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-15 09:07:15"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）",
    "author": "阿星Plus",
    "url": "2020-06-16-blog_27",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了后台分类模块的所有功能，本篇继续将标签模块和友情链接模块的增删改查完成。\n\n## 标签管理\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614140152811-948105756.png)\n\n实现方式和之前的分类管理是一样的，在Admin文件夹下面添加`Tags.razor`组件，设置路由`@page \"/admin/tags\"`。\n\n同样的内容也需要放在`AdminLayout`组件下面，添加几个参数：弹窗状态`bool Open`、新增或更新时标签字段`string tagName, displayName`、更新时的标签Id`int id`、API返回的标签列表接收参数`ServiceResult<IEnumerable<QueryTagForAdminDto>> tags`。\n\n```csharp\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 新增或者更新时候的标签字段值\n/// </summary>\nprivate string tagName, displayName;\n\n/// <summary>\n/// 更新标签的Id值\n/// </summary>\nprivate int id;\n\n/// <summary>\n/// API返回的标签列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryTagForAdminDto>> tags;\n```\n\n```csharp\n//QueryTagForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryTagForAdminDto : QueryTagDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n在初始化方法`OnInitializedAsync()`中获取数据。\n\n```csharp\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    tags = await FetchData();\n}\n\n/// <summary>\n/// 获取数据\n/// </summary>\n/// <returns></returns>\nprivate async Task<ServiceResult<IEnumerable<QueryTagForAdminDto>>> FetchData()\n{\n    return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryTagForAdminDto>>>(\"/blog/admin/tags\");\n}\n```\n\n注意需要设置请求头，进行授权访问，然后页面上绑定数据。\n\n```html\n<AdminLayout>\n    @if (tags == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap tags\">\n            <h2 class=\"post-title\">-&nbsp;Tags&nbsp;-</h2>\n            @if (tags.Success && tags.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in tags.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/tag/{item.DisplayName}\")\">\n                                    <h3>@item.TagName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📘~~~ 新增标签 ~~~📘</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>TagName：</b><input type=\"text\" @bind=\"@tagName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n```\n\n`tags`没获取到数据的时候显示`<Loading />`组件内容，循环遍历数据进行绑定，删除按钮绑定点击事件调用`DeleteAsync()`方法。新增和编辑按钮点击事件调用`ShowBox()`方法显示弹窗。新增的时候不需要传递参数，编辑的时候需要将当前item即`QueryTagForAdminDto`传递进去。\n\n`<Box>`组件中绑定了标签的两个参数，是否打开参数`Opne`和确认按钮回调事件方法`SubmitAsync()`。\n\n删除标签的方法`DeleteAsync(...)`如下：\n\n```csharp\n// 弹窗确认\nbool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的标签吗💢💥\");\n\nif (confirmed)\n{\n    var response = await Http.DeleteAsync($\"/blog/tag?id={id}\");\n\n    var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n    if (result.Success)\n    {\n        tags = await FetchData();\n    }\n}\n```\n\n删除之前进行二次确认，避免误伤，删除成功重新加载一遍数据。\n\n弹窗的方法`ShowBox(...)`如下：\n\n```csharp\n/// <summary>\n/// 显示box，绑定字段\n/// </summary>\n/// <param name=\"dto\"></param>\nprivate void ShowBox(QueryTagForAdminDto dto = null)\n{\n    Open = true;\n    id = 0;\n\n    // 新增\n    if (dto == null)\n    {\n        displayName = null;\n        tagName = null;\n    }\n    else // 更新\n    {\n        id = dto.Id;\n        displayName = dto.DisplayName;\n        tagName = dto.TagName;\n    }\n}\n```\n\n最后在弹窗中确认按钮的回调事件方法`SubmitAsync()`如下：\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    var input = new EditTagInput()\n    {\n        DisplayName = displayName.Trim(),\n        TagName = tagName.Trim()\n    };\n\n    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.TagName))\n    {\n        return;\n    }\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (id > 0)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/tag?id={id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/tag\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        tags = await FetchData();\n        Open = false;\n    }\n}\n```\n\n输入参数`EditTagInput`。\n\n```csharp\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class EditTagInput : TagDto\n    {\n    }\n}\n```\n\n最终执行新增或者更新数据都在点击事件中进行，将变量的值赋值给`EditTagInput`，根据id判断走新增还是更新，成功后重新加载数据，关掉弹窗。\n\n标签管理页面全部代码如下：\n\n<details>\n<summary>点击查看代码</summary>\n\n```csharp\n@page \"/admin/categories\"\n\n<AdminLayout>\n    @if (categories == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;Categories&nbsp;-</h2>\n            @if (categories.Success && categories.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in categories.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@($\"/category/{item.DisplayName}\")\">\n                                    <h3>@item.CategoryName</h3>\n                                    <small>(@item.Count)</small>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📕~~~ 新增分类 ~~~📕</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>DisplayName：</b><input type=\"text\" @bind=\"@displayName\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>CategoryName：</b><input type=\"text\" @bind=\"@categoryName\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的分类字段值\n    /// </summary>\n    private string categoryName, displayName;\n\n    /// <summary>\n    /// 更新分类的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的分类列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        categories = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/category?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                categories = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryCategoryForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            displayName = null;\n            categoryName = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            displayName = dto.DisplayName;\n            categoryName = dto.CategoryName;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditCategoryInput()\n        {\n            DisplayName = displayName.Trim(),\n            CategoryName = categoryName.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/category?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/category\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            categories = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n</details>\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614140618426-215255984.gif)\n\n## 友链管理\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614141515594-754366555.png)\n\n实现方式都是一样的，这个就不多说了，直接上代码。\n\n先将API返回的接收参数和新增编辑的输入参数添加一下。\n\n```csharp\n//QueryFriendLinkForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryFriendLinkForAdminDto : FriendLinkDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n\n//EditFriendLinkInput.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class EditFriendLinkInput : FriendLinkDto\n    {\n    }\n}\n```\n\n```csharp\n@page \"/admin/friendlinks\"\n\n<AdminLayout>\n    @if (friendlinks == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap categories\">\n            <h2 class=\"post-title\">-&nbsp;FriendLinks&nbsp;-</h2>\n            @if (friendlinks.Success && friendlinks.Result.Any())\n            {\n                <div class=\"categories-card\">\n                    @foreach (var item in friendlinks.Result)\n                    {\n                        <div class=\"card-item\">\n                            <div class=\"categories\">\n                                <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(item.Id))\">❌</NavLink>\n                                <NavLink title=\"📝编辑\" @onclick=\"@(() => ShowBox(item))\">📝</NavLink>\n                                <NavLink target=\"_blank\" href=\"@item.LinkUrl\">\n                                    <h3>@item.Title</h3>\n                                </NavLink>\n                            </div>\n                        </div>\n                    }\n                    <div class=\"card-item\">\n                        <div class=\"categories\">\n                            <NavLink><h3 @onclick=\"@(() => ShowBox())\">📒~~~ 新增友链 ~~~📒</h3></NavLink>\n                        </div>\n                    </div>\n                </div>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n\n        <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\">\n            <div class=\"box-item\">\n                <b>Title：</b><input type=\"text\" @bind=\"@title\" @bind:event=\"oninput\" />\n            </div>\n            <div class=\"box-item\">\n                <b>LinkUrl：</b><input type=\"text\" @bind=\"@linkUrl\" @bind:event=\"oninput\" />\n            </div>\n        </Box>\n    }\n</AdminLayout>\n\n@code {\n    /// <summary>\n    /// 默认隐藏Box\n    /// </summary>\n    private bool Open { get; set; } = false;\n\n    /// <summary>\n    /// 新增或者更新时候的友链字段值\n    /// </summary>\n    private string title, linkUrl;\n\n    /// <summary>\n    /// 更新友链的Id值\n    /// </summary>\n    private int id;\n\n    /// <summary>\n    /// API返回的友链列表数据\n    /// </summary>\n    private ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>> friendlinks;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <returns></returns>\n    protected override async Task OnInitializedAsync()\n    {\n        var token = await Common.GetStorageAsync(\"token\");\n        Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n        friendlinks = await FetchData();\n    }\n\n    /// <summary>\n    /// 获取数据\n    /// </summary>\n    /// <returns></returns>\n    private async Task<ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>>> FetchData()\n    {\n        return await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryFriendLinkForAdminDto>>>(\"/blog/admin/friendlinks\");\n    }\n\n    /// <summary>\n    /// 删除分类\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    private async Task DeleteAsync(int id)\n    {\n        Open = false;\n\n        // 弹窗确认\n        bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这个该死的分类吗💢💥\");\n\n        if (confirmed)\n        {\n            var response = await Http.DeleteAsync($\"/blog/friendlink?id={id}\");\n\n            var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n            if (result.Success)\n            {\n                friendlinks = await FetchData();\n            }\n        }\n    }\n\n    /// <summary>\n    /// 显示box，绑定字段\n    /// </summary>\n    /// <param name=\"dto\"></param>\n    private void ShowBox(QueryFriendLinkForAdminDto dto = null)\n    {\n        Open = true;\n        id = 0;\n\n        // 新增\n        if (dto == null)\n        {\n            title = null;\n            linkUrl = null;\n        }\n        else // 更新\n        {\n            id = dto.Id;\n            title = dto.Title;\n            linkUrl = dto.LinkUrl;\n        }\n    }\n\n    /// <summary>\n    /// 确认按钮点击事件\n    /// </summary>\n    /// <returns></returns>\n    private async Task SubmitAsync()\n    {\n        var input = new EditFriendLinkInput()\n        {\n            Title = title.Trim(),\n            LinkUrl = linkUrl.Trim()\n        };\n\n        if (string.IsNullOrEmpty(input.Title) || string.IsNullOrEmpty(input.LinkUrl))\n        {\n            return;\n        }\n\n        var responseMessage = new HttpResponseMessage();\n\n        if (id > 0)\n            responseMessage = await Http.PutAsJsonAsync($\"/blog/friendlink?id={id}\", input);\n        else\n            responseMessage = await Http.PostAsJsonAsync(\"/blog/friendlink\", input);\n\n        var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n        if (result.Success)\n        {\n            friendlinks = await FetchData();\n            Open = false;\n        }\n    }\n}\n```\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614143211653-1904701328.gif)\n\n截至目前为止，还剩下文章模块的功能还没做了，今天到这里吧，明天继续刚，未完待续...\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-16 08:54:16"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）",
    "author": "阿星Plus",
    "url": "2020-06-17-blog_28",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n上一篇完成了标签模块和友情链接模块的所有功能，本篇来继续完成博客最后的模块，文章的管理。\n\n## 文章列表 & 删除\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614200844738-638855159.png)\n\n先将分页查询的列表给整出来，这块和首页的分页列表是类似的，就是多了个Id字段。\n\n先添加两条路由规则。\n\n```csharp\n@page \"/admin/posts\"\n@page \"/admin/posts/{page:int}\"\n```\n\n新建返回数据默认`QueryPostForAdminDto.cs`。\n\n```csharp\n//QueryPostForAdminDto.cs\nusing System.Collections.Generic;\n\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class QueryPostForAdminDto\n    {\n        /// <summary>\n        /// 年份\n        /// </summary>\n        public int Year { get; set; }\n\n        /// <summary>\n        /// Posts\n        /// </summary>\n        public IEnumerable<PostBriefForAdminDto> Posts { get; set; }\n    }\n}\n\n//PostBriefForAdminDto.cs\nnamespace Meowv.Blog.BlazorApp.Response.Blog\n{\n    public class PostBriefForAdminDto : PostBriefDto\n    {\n        /// <summary>\n        /// 主键\n        /// </summary>\n        public int Id { get; set; }\n    }\n}\n```\n\n然后添加所需的参数：当前页码、限制条数、总页码、文章列表返回数据模型。\n\n```csharp\n/// <summary>\n/// 当前页码\n/// </summary>\n[Parameter]\npublic int? page { get; set; }\n\n/// <summary>\n/// 限制条数\n/// </summary>\nprivate int Limit = 15;\n\n/// <summary>\n/// 总页码\n/// </summary>\nprivate int TotalPage;\n\n/// <summary>\n/// 文章列表数据\n/// </summary>\nprivate ServiceResult<PagedList<QueryPostForAdminDto>> posts;\n```\n\n然后在初始化函数`OnInitializedAsync()`中调用API获取文章数据.\n\n```csharp\n/// <summary>\n/// 初始化\n/// </summary>\nprotected override async Task OnInitializedAsync()\n{\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    // 设置默认值\n    page = page.HasValue ? page : 1;\n\n    await RenderPage(page);\n}\n\n/// <summary>\n/// 点击页码重新渲染数据\n/// </summary>\n/// <param name=\"page\"></param>\n/// <returns></returns>\nprivate async Task RenderPage(int? page)\n{\n    // 获取数据\n    posts = await Http.GetFromJsonAsync<ServiceResult<PagedList<QueryPostForAdminDto>>>($\"/blog/admin/posts?page={page}&limit={Limit}\");\n\n    // 计算总页码\n    TotalPage = (int)Math.Ceiling((posts.Result.Total / (double)Limit));\n}\n```\n\n在初始化中判断page参数，如果没有值给他设置一个默认值1。`RenderPage(int? page)`方法是调用API返回数据，并计算出总页码值。\n\n最后在页面上进行数据绑定。\n\n```html\n<AdminLayout>\n    @if (posts == null)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-wrap archive\">\n            <NavLink style=\"float:right\" href=\"/admin/post\"><h3>📝~~~ 新增文章 ~~~📝</h3></NavLink>\n            @if (posts.Success && posts.Result.Item.Any())\n            {\n                @foreach (var item in posts.Result.Item)\n                {\n                    <h3>@item.Year</h3>\n                    @foreach (var post in item.Posts)\n                    {\n                        <article class=\"archive-item\">\n                            <NavLink title=\"❌删除\" @onclick=\"@(async () => await DeleteAsync(post.Id))\">❌</NavLink>\n                            <NavLink title=\"📝编辑\" @onclick=\"@(async () => await Common.NavigateTo($\"/admin/post/{post.Id}\"))\">📝</NavLink>\n                            <NavLink target=\"_blank\" class=\"archive-item-link\" href=\"@(\"/post\" + post.Url)\">@post.Title</NavLink>\n                            <span class=\"archive-item-date\">@post.CreationTime</span>\n                        </article>\n                    }\n                }\n                <nav class=\"pagination\">\n                    @for (int i = 1; i <= TotalPage; i++)\n                    {\n                        var _page = i;\n\n                        if (page == _page)\n                        {\n                            <span class=\"page-number current\">@_page</span>\n                        }\n                        else\n                        {\n                            <a class=\"page-number\" @onclick=\"@(() => RenderPage(_page))\" href=\"/admin/posts/@_page\">@_page</a>\n                        }\n                    }\n                </nav>\n            }\n            else\n            {\n                <ErrorTip />\n            }\n        </div>\n    }\n</AdminLayout>\n```\n\nHTML内容放在组件`AdminLayout`中，当 posts 没加载完数据的时候显示加载组件`<Loading />`。\n\n在页面上循环遍历文章数据和翻页页码，每篇文章标题前面添加两个按钮删除和编辑，同时单独加了一个新增文章的按钮。\n\n删除文章调用`DeleteAsync(int id)`方法，需要传递参数，当前文章的id。\n\n新增和编辑按钮都跳转到\"/admin/post\"页面，当编辑的时候将id也传过去即可，路由规则为：\"/admin/post/{id}\"。\n\n删除文章``方法如下：\n\n```csharp\n/// <summary>\n/// 删除文章\n/// </summary>\n/// <param name=\"id\"></param>\n/// <returns></returns>\nprivate async Task DeleteAsync(int id)\n{\n    // 弹窗确认\n    bool confirmed = await Common.InvokeAsync<bool>(\"confirm\", \"\\n💥💢真的要干掉这篇该死的文章吗💢💥\");\n\n    if (confirmed)\n    {\n        var response = await Http.DeleteAsync($\"/blog/post?id={id}\");\n\n        var result = await response.Content.ReadFromJsonAsync<ServiceResult>();\n\n        if (result.Success)\n        {\n            await RenderPage(page);\n        }\n    }\n}\n```\n\n删除之前进行二次确认，避免误删，当确认删除之后调用删除文章API，最后重新渲染数据即可。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614202156563-532339787.gif)\n\n## 新增 & 更新文章\n\n完成了后台文章列表的查询和删除，现在整个博客模块功能就差新增和更新文章了，胜利就在前方，冲啊。\n\n这块的开发工作耗费了我太多时间，因为想使用 markdown 来写文章，找了一圈下来没有一个合适的组件，所以退而求次只能选择现有的markdown编辑器来实现了。\n\n我这里选择了开源的编辑器`Editor.md`，有需要的可以去 Github 自己下载，https://github.com/pandao/editor.md 。\n\n将下载的资源包解压放在 wwwroot 文件夹下，默认是比较大的，而且还有很多示例文件，我已经将其精简了一番，可以去我 Github 下载使用。\n\n先来看下最终的成品效果吧。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614214938404-633246509.png)\n\n是不是感觉还可以，废话不多说，接下里告诉大家如何实现。\n\n在 Admin 文件夹下添加`post.razor`组件，设置路由，并且引用一个样式文件，在页面中引用样式文件好像不太符合标准，不过无所谓了，这个后台就自己用，而且还就这一个页面用得到。\n\n```html\n@page \"/admin/post\"\n@page \"/admin/post/{id:int}\"\n\n<link href=\"./editor.md/css/editormd.css\" rel=\"stylesheet\" />\n\n<AdminLayout>\n    ...\n</AdminLayout>\n```\n\n把具体HTML内容放在组件`AdminLayout`中。\n\n因为新增和编辑放在同一个页面上，所以当id参数不为空的时候需要添加一个id参数，同时默认一进来就让页面显示加载中的组件，当页面和数据加载完成后在显示具体的内容，所以在指定一个布尔类型的是否加载参数`isLoading`。\n\n我们的编辑器主要依赖JavaScript实现的，所以这里不可避免要使用到JavaScript了。\n\n在`app.js`中添加几个全局函数。\n\n```javascript\nswitchEditorTheme: function () {\n    editor.setTheme(localStorage.editorTheme || 'default');\n    editor.setEditorTheme(localStorage.editorTheme === 'dark' ? 'pastel-on-dark' : 'default');\n    editor.setPreviewTheme(localStorage.editorTheme || 'default');\n},\nrenderEditor: async function () {\n\tawait this._loadScript('./editor.md/lib/zepto.min.js').then(function () {\n\t    func._loadScript('./editor.md/editormd.js').then(function () {\n\t        editor = editormd(\"editor\", {\n\t            width: \"100%\",\n\t            height: 700,\n\t            path: './editor.md/lib/',\n\t            codeFold: true,\n\t            saveHTMLToTextarea: true,\n\t            emoji: true,\n\t            atLink: false,\n\t            emailLink: false,\n\t            theme: localStorage.editorTheme || 'default',\n\t            editorTheme: localStorage.editorTheme === 'dark' ? 'pastel-on-dark' : 'default',\n\t            previewTheme: localStorage.editorTheme || 'default',\n\t            toolbarIcons: function () {\n\t                return [\"bold\", \"del\", \"italic\", \"quote\", \"ucwords\", \"uppercase\", \"lowercase\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"list-ul\", \"list-ol\", \"hr\", \"link\", \"image\", \"code\", \"preformatted-text\", \"code-block\", \"table\", \"datetime\", \"html-entities\", \"emoji\", \"watch\", \"preview\", \"fullscreen\", \"clear\", \"||\", \"save\"]\n\t            },\n\t            toolbarIconsClass: {\n\t                save: \"fa-check\"\n\t            },\n\t            toolbarHandlers: {\n\t                save: function () {\n\t                    func._shoowBox();\n\t                }\n\t            },\n\t            onload: function () {\n\t                this.addKeyMap({\n\t                    \"Ctrl-S\": function () {\n\t                        func._shoowBox();\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    });\n\t});\n},\n_shoowBox: function () {\n    DotNet.invokeMethodAsync('Meowv.Blog.BlazorApp', 'showbox');\n},\n_loadScript: async function (url) {\n    let response = await fetch(url);\n    var js = await response.text();\n    eval(js);\n}\n```\n\n`renderEditor`主要实现了动态加载JavaScript代码，将markdown编辑器渲染出来。这里不多说，都是`Editor.md`示例里面的代码。\n\n为了兼容暗黑色主题，这里还加了一个切换编辑器主题的JavaScript方法，`switchEditorTheme`。\n\n`_shoowBox`就厉害了，这个方法是调用的.NET组件中的方法，前面我们用过了在Blazor中调用JavaScript，这里演示了JavaScript中调用Blazor中的组件方法。\n\n现在将所需的几个参数都添加到代码中。\n\n```csharp\n/// <summary>\n/// 定义一个委托方法，用于组件实例方法调用\n/// </summary>\nprivate static Func<Task> action;\n\n/// <summary>\n/// 默认隐藏Box\n/// </summary>\nprivate bool Open { get; set; } = false;\n\n/// <summary>\n/// 修改时的文章Id\n/// </summary>\n[Parameter]\npublic int? Id { get; set; }\n\n/// <summary>\n/// 格式化的标签\n/// </summary>\nprivate string tags { get; set; }\n\n/// <summary>\n/// 默认显示加载中\n/// </summary>\nprivate bool isLoading = true;\n\n/// <summary>\n/// 文章新增或者修改输入参数\n/// </summary>\nprivate PostForAdminDto input;\n\n/// <summary>\n/// API返回的分类列表数据\n/// </summary>\nprivate ServiceResult<IEnumerable<QueryCategoryForAdminDto>> categories;\n```\n\n大家看看注释就知道参数是做什么的了。\n\n现在我们在初始化函数中将所需的数据通过API获取到。\n\n```csharp\n/// <summary>\n/// 初始化\n/// </summary>\n/// <returns></returns>\nprotected override async Task OnInitializedAsync()\n{\n    action = ChangeOpenStatus;\n\n    var token = await Common.GetStorageAsync(\"token\");\n    Http.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n\n    if (Id.HasValue)\n    {\n        var post = await Http.GetFromJsonAsync<ServiceResult<PostForAdminDto>>($\"/blog/admin/post?id={Id}\");\n\n        if (post.Success)\n        {\n            var _post = post.Result;\n            input = new PostForAdminDto\n            {\n                Title = _post.Title,\n                Author = _post.Author,\n                Url = _post.Url,\n                Html = _post.Html,\n                Markdown = _post.Markdown,\n                CategoryId = _post.CategoryId,\n                Tags = _post.Tags,\n                CreationTime = _post.CreationTime\n            };\n\n            tags = string.Join(\",\", input.Tags);\n        }\n    }\n    else\n    {\n        input = new PostForAdminDto()\n        {\n            Author = \"阿星Plus\",\n            CreationTime = DateTime.Now\n        };\n    }\n\n    categories = await Http.GetFromJsonAsync<ServiceResult<IEnumerable<QueryCategoryForAdminDto>>>(\"/blog/admin/categories\");\n\n    // 渲染编辑器\n    await Common.InvokeAsync(\"window.func.renderEditor\");\n\n    // 关闭加载\n    isLoading = !isLoading;\n}\n```\n\naction是一个异步的委托，在初始化中执行了`ChangeOpenStatus`方法，这个方法等会说，然后获取`localStorage`中token的值。\n\n通过参数Id是否有值来判断当前是新增文章还是更新文章，如果有值就是更新文章，这时候需要根据id去将文章的数据拿到赋值给`PostForAdminDto`对象展示在页面上，如果没有可以添加几个默认值给`PostForAdminDto`对象。\n\n因为文章需要分类和标签的数据，同时这里将分类的数据也查出来，标签默认是List列表，将其转换成字符串类型。\n\n但完成上面操作后，调用JavaScript方法`renderEditor`渲染渲染编辑器，最后关闭加载，显示页面。\n\n现在来看看页面。\n\n```html\n<AdminLayout>\n    @if (isLoading)\n    {\n        <Loading />\n    }\n    else\n    {\n        <div class=\"post-box\">\n            <div class=\"post-box-item\">\n                <input type=\"text\" placeholder=\"标题\" autocomplete=\"off\" @bind=\"@input.Title\" @bind:event=\"oninput\" @onclick=\"@(() => { Open = false; })\" />\n                <input type=\"text\" placeholder=\"作者\" autocomplete=\"off\" @bind=\"@input.Author\" @bind:event=\"oninput\" @onclick=\"@(() => { Open = false; })\" />\n            </div>\n            <div class=\"post-box-item\">\n                <input type=\"text\" placeholder=\"URL\" autocomplete=\"off\" @bind=\"@input.Url\" @bind:event=\"oninput\" @onclick=\"@(() => { Open = false; })\" />\n                <input type=\"text\" placeholder=\"时间\" autocomplete=\"off\" @bind=\"@input.CreationTime\" @bind:format=\"yyyy-MM-dd HH:mm:sss\" @bind:event=\"oninput\" @onclick=\"@(() => { Open = false; })\" />\n            </div>\n            <div id=\"editor\">\n                <textarea style=\"display:none;\">@input.Markdown</textarea>\n            </div>\n\n            <Box OnClickCallback=\"@SubmitAsync\" Open=\"@Open\" ButtonText=\"发布\">\n                <div class=\"box-item\">\n                    <b>分类：</b>\n                    @if (categories.Success && categories.Result.Any())\n                    {\n                        @foreach (var item in categories.Result)\n                        {\n                            <label><input type=\"radio\" name=\"category\" value=\"@item.Id\" @onchange=\"@(() => { input.CategoryId = item.Id; })\" checked=\"@(item.Id == input.CategoryId)\" />@item.CategoryName</label>\n                        }\n                    }\n                </div>\n                <div class=\"box-item\"></div>\n                <div class=\"box-item\">\n                    <b>标签：</b>\n                    <input type=\"text\" @bind=\"@tags\" @bind:event=\"oninput\" />\n                </div>\n            </Box>\n        </div>\n    }\n</AdminLayout>\n```\n\n添加了四个input框，分别用来绑定标题、作者、URL、时间，`<div id=\"editor\"></div>`中为编辑器所需。\n\n然后我这里还是把之前的弹窗组件搞出来了，执行逻辑不介绍了，在弹窗组件中自定义显示分类和标签的内容，将获取到的分类和标签绑定到具体位置。\n\n每个分类都是一个radio标签，并且对应一个点击事件，点哪个就把当前分类的Id赋值给`PostForAdminDto`对象。\n\n所有的input框都使用`@bind`和`@bind:event`绑定数据和获取数据。\n\n`Box`弹窗组件这里自定义了按钮文字，`ButtonText=\"发布\"`。\n\n```csharp\n/// <summary>\n/// 改变Open状态，通知组件渲染\n/// </summary>\nprivate async Task ChangeOpenStatus()\n{\n    Open = true;\n\n    var markdown = await Common.InvokeAsync<string>(\"editor.getMarkdown\");\n    var html = await Common.InvokeAsync<string>(\"editor.getHTML\");\n\n    if (string.IsNullOrEmpty(input.Title) || string.IsNullOrEmpty(input.Url) ||\n        string.IsNullOrEmpty(input.Author) || string.IsNullOrEmpty(markdown) ||\n        string.IsNullOrEmpty(html))\n    {\n        await Alert();\n    }\n\n    input.Html = html;\n    input.Markdown = markdown;\n\n    StateHasChanged();\n}\n\n/// <summary>\n/// 暴漏给JS执行，弹窗确认框\n/// </summary>\n[JSInvokable(\"showbox\")]\npublic static void ShowBox()\n{\n    action.Invoke();\n}\n```\n\n```csharp\n/// <summary>\n/// alert提示\n/// </summary>\n/// <returns></returns>\nprivate async Task Alert()\n{\n    Open = false;\n\n    await Common.InvokeAsync(\"alert\", \"\\n💥💢好像漏了点什么吧💢💥\");\n    return;\n}\n```\n\n现在可以来看看`ChangeOpenStatus`方法了，这个是改变当前弹窗状态的一个方法。为什么需要这个方法呢?\n\n因为在Blazor中JavaScript想要调用组件内的方法，方法必须是静态的，那么只能通过这种方式去实现了，在静态方法是不能够直接改变弹窗的状态值的。\n\n其实也可以不用这么麻烦，因为我在编辑器上自定义了一个按钮，为了好看一些所以只能曲折一点，嫌麻烦的可以直接在页面上搞个按钮执行保存数据逻辑也是一样的。\n\n使用`JSInvokable`Attribute需要在`_Imports.razor`中添加命名空间`@using Microsoft.JSInterop`。\n\n`ChangeOpenStatus`中获取到文章内容：HTML和markdown，赋值给`PostForAdminDto`对象，要先进行判断页面上的几个参数是否有值，没值的话给出提示执行`Alert()`方法，最后使用`StateHasChanged()`通知组件其状态已更改。\n\n`Alert`方法就是调用原生的JavaScript`alert`方法，给出一个提示。\n\n`ShowBox`就是暴漏给JavaScript的方法，使用`DotNet.invokeMethodAsync('Meowv.Blog.BlazorApp', 'showbox');`进行调用。\n\n那么现在一切都正常进行的情况下，点击编辑器上自定义的保存按钮，页面上值不为空的情况下就会弹出我们的弹窗组件`Box`。\n\n最后在弹窗组件的回调方法中执行新增文章还是更新文章。\n\n```csharp\n/// <summary>\n/// 确认按钮点击事件\n/// </summary>\n/// <returns></returns>\nprivate async Task SubmitAsync()\n{\n    if (string.IsNullOrEmpty(tags) || input.CategoryId == 0)\n    {\n        await Alert();\n    }\n\n    input.Tags = tags.Split(\",\");\n\n    var responseMessage = new HttpResponseMessage();\n\n    if (Id.HasValue)\n        responseMessage = await Http.PutAsJsonAsync($\"/blog/post?id={Id}\", input);\n    else\n        responseMessage = await Http.PostAsJsonAsync(\"/blog/post\", input);\n\n    var result = await responseMessage.Content.ReadFromJsonAsync<ServiceResult>();\n    if (result.Success)\n    {\n        await Common.NavigateTo(\"/admin/posts\");\n    }\n}\n```\n\n打开弹窗后执行回调事件之前还是要判断值是否为空，为空的情况下还是给出`alert`提示，此时将tags标签还是转换成List列表，根据Id是否有值去执行新增数据或者更新数据，最终成功后跳转到文章列表页。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614215750117-640132844.gif)\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200614215755962-368836717.gif)\n\n本片到这里就结束了，主要攻克了在Blazor中使用Markdown编辑器实现新增和更新文章，这个系列差不多就快结束了，预计还有2篇的样子，感谢各位的支持。\n\n开源地址：https://github.com/Meowv/Blog/tree/blog_tutorial\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-17 08:54:17"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）",
    "author": "阿星Plus",
    "url": "2020-06-18-blog_29",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n终于要接近尾声了，上一篇基本上将文章模块的所有功能都完成了，整个博客页面也都完成了，本篇主要来美化几个地方，修修补补。\n\n## 编辑器主题切换\n\n当我们新增和编辑文章的时候，默认编辑器是白色的，如果点击了头部切换主题按钮，我想要把编辑器主题颜色也做相应的改变该如何去实现呢？\n\n刚好，`editor.md`是支持主题切换的，这就比较舒服了，直接按照要求调用对应的方法即可。\n\n在`app.js`的`renderEditor`函数中我们已经自定义了三个参数`theme`、`editorTheme`、`previewTheme`，这三个参数就是来改变编辑器主题颜色的。\n\n还是将值存在localStorage中，和我们博客的主题切换一样，这里叫`editorTheme`。\n\n```javascript\ntheme: localStorage.editorTheme || 'default',\neditorTheme: localStorage.editorTheme === 'dark' ? 'pastel-on-dark' : 'default',\npreviewTheme: localStorage.editorTheme || 'default',\n```\n\n默认从`localStorage`中取数据，如果没取到的话，给对应的默认值。第二个参数有点特殊，用了一个三元表达式给不同的值。\n\n然后在主题切换的时候也对编辑器做相应的调整即可。\n\n打开`Header.razor`头部组件，找到`SwitchTheme()`切换主题的方法，添加一句`await Common.SwitchEditorTheme(currentTheme);`。\n\n```csharp\n/// <summary>\n/// 切换主题\n/// </summary>\nprivate async Task SwitchTheme()\n{\n    currentTheme = currentTheme == \"Light\" ? \"Dark\" : \"Light\";\n\n    await Common.SetStorageAsync(\"theme\", currentTheme);\n\n    await Common.InvokeAsync(\"window.func.switchTheme\");\n\n    var uri = await Common.CurrentUri();\n    if (uri.AbsolutePath.StartsWith(\"/admin/post\"))\n    {\n        await Common.SwitchEditorTheme(currentTheme);\n    }\n}\n```\n\n将具体切换逻辑放到`SwitchEditorTheme`中，他接收一个参数`currentTheme`，用来判断是切换黑的还是白的。\n\n```csharp\n/// <summary>\n/// 切换编辑器主题\n/// </summary>\n/// <param name=\"currentTheme\"></param>\n/// <returns></returns>\npublic async Task SwitchEditorTheme(string currentTheme)\n{\n    var editorTheme = currentTheme == \"Light\" ? \"default\" : \"dark\";\n\n    await SetStorageAsync(\"editorTheme\", editorTheme);\n\n    await InvokeAsync(\"window.func.switchEditorTheme\");\n}\n```\n\n切换主题之前拿到当前URI对象，判断当前请求的链接是否是新增和更新文章的那个页面，即\"/admin/post\"，才去执行切换编辑器主题的方法，当不是这个页面的时候，编辑器是没有渲染出来的，如果也执行这段代码就会报错。\n\n去看看效果。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200615204827795-1896882776.gif)\n\n## 文章详情页美化\n\n现在的文章详情页是没有将markdown格式渲染出来的，这里还是使用`editor.md`提供的方法，因为需要加载几个js文件，然后才能渲染样式。\n\n所以还是在`app.js`添加一段代码。\n\n```javascript\nrenderMarkdown: async function () {\n    await this._loadScript('./editor.md/lib/zepto.min.js').then(function () {\n        func._loadScript('./editor.md/lib/marked.min.js').then(function () {\n            func._loadScript('./editor.md/lib/prettify.min.js').then(function () {\n                func._loadScript('./editor.md/editormd.js').then(function () {\n                    editormd.markdownToHTML(\"content\");\n                });\n            });\n        });\n    });\n},\n```\n\n然后在文章详情页的组件`Post.razor`中修改代码，当数据加载完成后调用`renderMarkdown`即可，然后还需要引用一个css文件`editormd.preview.css`。\n\n提供一下`Post.razor`最终的代码。\n\n```csharp\n@page \"/post/{year:int}/{month:int}/{day:int}/{name}\"\n\n<link href=\"./editor.md/css/editormd.preview.css\" rel=\"stylesheet\" />\n\n@if (post == null)\n{\n    <Loading />\n}\nelse\n{\n    @if (post.Success)\n    {\n        var _post = post.Result;\n\n        <article class=\"post-wrap\">\n            <header class=\"post-header\">\n                <h1 class=\"post-title\">@_post.Title</h1>\n                <div class=\"post-meta\">\n                    Author: <a itemprop=\"author\" rel=\"author\" href=\"javascript:;\">@_post.Author</a>\n                    <span class=\"post-time\">\n                        Date: <a href=\"javascript:;\">@_post.CreationTime</a>\n                    </span>\n                    <span class=\"post-category\">\n                        Category:<a href=\"/category/@_post.Category.DisplayName/\">@_post.Category.CategoryName</a>\n                    </span>\n                </div>\n            </header>\n            <div class=\"post-content\" id=\"content\">\n                @((MarkupString)_post.Html)\n            </div>\n            <section class=\"post-copyright\">\n                <p class=\"copyright-item\">\n                    <span>Author:</span>\n                    <span>@_post.Author</span>\n                </p>\n                <p class=\"copyright-item\">\n                    <span>Permalink:</span>\n                    <span><a href=\"/post@_post.Url\">https://meowv.com/post@_post.Url</a></span>\n                </p>\n                <p class=\"copyright-item\">\n                    <span>License:</span>\n                    <span>本文采用<a target=\"_blank\" href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\"> 知识共享 署名-非商业性使用-禁止演绎(CC BY-NC-ND)国际许可协议 </a>进行许可</span>\n                </p>\n            </section>\n            <section class=\"post-tags\">\n                <div>\n                    <span>Tag(s):</span>\n                    <span class=\"tag\">\n                        @if (_post.Tags.Any())\n                        {\n                            @foreach (var tag in _post.Tags)\n                            {\n                                <a href=\"/tag/@tag.DisplayName/\"># @tag.TagName</a>\n                            }\n                        }\n                    </span>\n                </div>\n                <div>\n                    <a @onclick=\"@(async () => await Common.NavigateTo(\"/posts\"))\">back</a>\n                    <span>· </span>\n                    <a href=\"/\">home</a>\n                </div>\n            </section>\n            <section class=\"post-nav\">\n                @if (_post.Previous != null)\n                {\n                    <a class=\"prev\"\n                       rel=\"prev\"\n                       @onclick=\"@(async () => await FetchData(_post.Previous.Url))\"\n                       href=\"/post@_post.Previous.Url\">@_post.Previous.Title</a>\n                }\n                @if (_post.Next != null)\n                {\n                    <a class=\"next\"\n                       rel=\"next\"\n                       @onclick=\"@(async () => await FetchData(_post.Next.Url))\"\n                       href=\"/post@_post.Next.Url\">\n                        @_post.Next.Title\n                    </a>\n                }\n            </section>\n        </article>\n    }\n    else\n    {\n        <ErrorTip />\n    }\n}\n\n@code {\n    [Parameter]\n    public int year { get; set; }\n\n    [Parameter]\n    public int month { get; set; }\n\n    [Parameter]\n    public int day { get; set; }\n\n    [Parameter]\n    public string name { get; set; }\n\n    /// <summary>\n    /// URL\n    /// </summary>\n    private string url => $\"/{year}/{(month >= 10 ? month.ToString() : $\"0{month}\")}/{(day >= 10 ? day.ToString() : $\"0{day}\")}/{name}/\";\n\n    /// <summary>\n    /// 文章详情数据\n    /// </summary>\n    private ServiceResult<PostDetailDto> post;\n\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    protected override async Task OnInitializedAsync()\n    {\n        await FetchData(url);\n    }\n\n    /// <summary>\n    /// 请求数据，渲染页面\n    /// </summary>\n    /// <param name=\"url\"></param>\n    /// <returns></returns>\n    private async Task FetchData(string url, bool isPostNav = false)\n    {\n        post = await Http.GetFromJsonAsync<ServiceResult<PostDetailDto>>($\"/blog/post?url={url}\");\n        await Common.InvokeAsync(\"window.func.renderMarkdown\");\n    }\n}\n```\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200615210615733-982554725.gif)\n\n到这里整个开发工作便结束了，这里只是一个小小的实战系列记录，没有深层次的剖析研究Blazor的所有使用方式。\n\n如果本系列对你有些许帮助，便是我最大的收获，欢迎大家关注我的公众号：阿星Plus。\n\n开源地址：https://github.com/Meowv/Blog\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-18 08:57:18"
  },
  {
    "title": "基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目",
    "author": "阿星Plus",
    "url": "2020-06-19-blog_30",
    "markdown": "## 系列文章\n\n1. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目](https://mp.weixin.qq.com/s/3Sc4Z2xkLdQNErvXf92B9A)**\n2. **[基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来](https://mp.weixin.qq.com/s/oc96GG2sxz0J_vT6sReojQ)**\n3. **[基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场](https://mp.weixin.qq.com/s/usz1BRYzBO2tT_z9MaonPg)**\n4. **[基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先](https://mp.weixin.qq.com/s/OHBW24PSNIeOARnHlbWBNQ)**\n5. **[基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查](https://mp.weixin.qq.com/s/ObgAtdWe3-nZw6hWC5dhyg)**\n6. **[基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型](https://mp.weixin.qq.com/s/uVsFiKjbiHX5lKAhuZ2E9g)**\n7. **[基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁](https://mp.weixin.qq.com/s/cNB469s18plbCLbHxL1QUA)**\n8. **[基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API](https://mp.weixin.qq.com/s/ZOX9D4ncqqeXxipYapTeBA)**\n9. **[基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录](https://mp.weixin.qq.com/s/segjYoh1rMI372PKi-ap6w)**\n10. **[基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据](https://mp.weixin.qq.com/s/fTqDnwVUgqKnwz21AsETGA)**\n11. **[基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理](https://mp.weixin.qq.com/s/wRITvM72JveP7ozx2tDL4A)**\n12. **[基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射](https://mp.weixin.qq.com/s/VO0qKlOg90kb27XGcpGjqw)**\n13. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）](https://mp.weixin.qq.com/s/DkGuy4jJ629ARh5gMq5I_Q)**\n14. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）](https://mp.weixin.qq.com/s/vGg14QchfUjNcNuOBfw7Tg)**\n15. **[基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）](https://mp.weixin.qq.com/s/rFvsLuqZtdUnkqxRhN29rw)**\n16. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）](https://mp.weixin.qq.com/s/5tTMKfZvXvi1Z7NJ3yZdvg)**\n17. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）](https://mp.weixin.qq.com/s/2nmw2td01cEhqBCc32FUYw)**\n18. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）](https://mp.weixin.qq.com/s/B0AwLunJ6xSqJzXwE_qJSg)**\n19. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）](https://mp.weixin.qq.com/s/3V7Q-RvaxEiopXR73YpG5Q)**\n20. **[基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）](https://mp.weixin.qq.com/s/B3jvHCtKotmmlcAKYxL9Lw)**\n21. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）](https://mp.weixin.qq.com/s/gtnZ74ItGmocpxDcOVswng)**\n22. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）](https://mp.weixin.qq.com/s/RVX94RPnEteHouz_0BDayw)**\n23. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）](https://mp.weixin.qq.com/s/9pC456tnmjJNMS55aEe9Qg)**\n24. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）](https://mp.weixin.qq.com/s/Y0zGpc4L2eAvUd0ba6Hbkg)**\n25. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）](https://mp.weixin.qq.com/s/dj4ubCqqjCWRc6mXPsgqBw)**\n26. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）](https://mp.weixin.qq.com/s/-W3JQHOxYLYxAb13ZSVhnQ)**\n27. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七）](https://mp.weixin.qq.com/s/q1BHEk8TNRRczBGRGecBPw)**\n28. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（八）](https://mp.weixin.qq.com/s/ZCYJa3f3HYPclM6bpmynNA)**\n29. **[基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（九）](https://mp.weixin.qq.com/s/0-mMmkr3HelmoJUWN7R7JA)**\n30. **[基于 abp vNext 和 .NET Core 开发博客项目 - 终结篇之发布项目](https://mp.weixin.qq.com/s/Lf543XOxSIGYdOGM8Zt4Lw)**\n\n---\n\n终于到了这一步了，开发了 API，紧接着又开发了 Blazor 版的博客项目，庆祝本系列文章完结撒花。🎉🎉🎉\n\n既然开发完成了，还是拿出来溜溜比较好，本篇是本系列文章的最后一篇了，准备将 API 部署到 Linux，把前端 Blazor 开发的博客部署到 GitHub Pages。\n\n- **blog**：https://blazor.meowv.com/\n- **api**：https://api2.meowv.com/\n\n先放地址，体验一下，要有点耐心，第一次访问会下载资源文件到本地浏览器，后面访问就贼快了。\n\n也是第一次使用 Blazor 开发项目，不管怎么说，这个实验性的带教学和宣传目的博客总算是搞出来了，自己用的话，完全可以，同时在开发过程中自己也有不少收获。\n\n## 发布API\n\n发布自己写的后端API项目，必须要有属于自己的服务器，当然如果只是为了动动手玩玩就没啥必要了，因为 .NET Core 跨平台咱们可以任意选择，我这里演示将项目发布到 Linux 下。\n\n在这之前可以看一下我去年的一篇文章，[基于.NET Core开发的个人博客发布至CentOS小记](https://mp.weixin.qq.com/s/WtZlCvLWjolTX8NYVdlLoA) ，简单了解下。\n\n我的机器是很久之前撸羊毛的渣渣配置服务器，1G内存，1核CPU，1M带宽，不过对于我们这种小站来说没啥访问量，照样用。🤣🤣\n\n首先肯定是需要安装 .NET Core 运行环境，直接安装最新的 .NET Core 3.1 即可。这一步大家根据微软官方文档来就可以了，https://docs.microsoft.com/zh-cn/dotnet/core/install/linux 。\n\n安装完成后可以使用 `dotnet --list-runtimes` 查看运行时。\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617215458097-1044857481.png)\n\n接着就可以去安装 Nginx ，高性能 Web 服务器，在这里使用它反向代理的功能，当然它的功能远不止于此。关于 Nginx 的安装我也不说了，如果你不懂，网上太多教程了。\n\n安装完成后可以使用 `nginx -V` 查看安装版本等信息。\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617220944495-1578220668.png)\n\n到这一步就可以把我们API项目部署上去了，直接利用 Visual Studio 将项目打包发布，`appsettings.json`配置文件信息填好，这一步不用多说吧，相信大家都会。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222223476-457921761.png)\n\n利用 WinSCP 工具将发布好的代码上传至服务器，我这里新建了文件夹 qix/api2 方便自己管理，顺便提一句，WinSCP 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617222814781-574516396.png)\n\n那么现在我们可以在终端中定位到API所在目录，`cd /qix/api2`，然后执行命令启动项目`dotnet run Meowv.Blog.HttpApi.Hosting.dll`这时候便会看到输出信息，我们就可以使用服务器IP+端口的方式访问到API了。\n\n如果只是这样肯定不是我想要的，这时候就引入了 Linux 下的守护进程，就类似于 Windows 下面的服务一样，让守护进程帮助我们运行项目，当关机、重启或者其它异常问题出现时，可以自动帮我们重启应用，就是自动执行`dotnet run xxx.dll`这句命令。\n\n关于守护进程用的比较多的，supervisor 与 pm2 ，前者基于Python开发的，后者是基于nodejs开发的。\n\n咱这里就选用 supervisor 了，当然 pm2 也不错也可以用用。\n\n在 centos 下安装 supervisor 也很简单，直接贴几行代码，照着执行即可。\n\n```ini\nyum install python-setuptools\n\neasy_install supervisor\n\nmkdir /etc/supervisor\necho_supervisord_conf > /etc/supervisor/supervisord.conf\n```\n\n安装成功后还需要花点时间去配置它，找到文件 /etc/supervisor/supervisord.conf 去掉文件最后的注释，可以改成向下面这样。\n\n```ini\n...\n[include]\nfiles = conf.d/*.ini\n```\n\n这时候就可以监听到 conf.d 文件夹下面的 ini 配置文件了，在 /etc/supervisor/ 下新建文件夹 conf.d，conf.d 文件夹下新建一个配置文件 api2_meowv.conf 文件，名字随便起，内容如下：\n\n```ini\n[program:api2_meowv] # api2_meowv程序名称\ncommand=dotnet Meowv.Blog.HttpApi.Hosting.dll # 执行的命令\ndirectory=/qix/api2  # 命令执行的目录\nenvironment=ASPNETCORE__ENVIRONMENT=Production # 环境变量\nuser=root\nstopsignal=INT \nautostart=true # 是否自启动\nautorestart=true # 是否自动重启\nstartsecs=3 # 自动重启时间间隔（s）\nstderr_logfile=/var/log/api2.meowv.com.err.log #错误日志文件指向目录\nstdout_logfile=/var/log/api2.meowv.com.out.log #输出日志文件指向目录\n```\n\n每行都带有注释，很清楚知道是干啥用的，顺便贴几条常用的命令：\n\n```ini\nsupervisorctl start program_name   #启动某个进程(program_name=配置的进程名称)\nsupervisorctl stop program_name    #停止某一进程\nsupervisorctl reload               #重新启动配置中的所有程序\nsupervisorctl stop all             #停止全部进程\nsupervisorctl update               #更新新的配置到supervisord\nsupervisorctl restart program_name #重启某一进程\nsupervisorctl                      #查看正在守候的进程\n```\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617225533767-1029923751.png)\n\n使用上面命令成功启动项目，使用IP+端口的方式去访问API肯定是不友好的，这时候就需要一个域名了，我这里将新建一个二级域名 api2.meowv.com 执行新开发的API项目。\n\n关于域名的解析啥的不说了，配置完域名我顺便去申请了一个SSL证书，使用HTTPS的方式访问。\n\n这时可以去配置 Nginx 方向代理了。来到 nginx 安装目录，我这里是 /etc/nginx ，新建一个文件夹 ssl ，将申请的SSL证书放进去，然后再 conf.d 文件夹下新建一个 api2_meowv.conf 文件，写入下面的配置信息。\n\n```nginx\nserver {\n        listen 443 ssl;\n        server_name api2.meowv.com;\n        ssl_certificate ssl/1_api2.meowv.com_bundle.crt; \n        ssl_certificate_key ssl/2_api2.meowv.com.key; \n        ssl_session_timeout 5m;\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;\n\tssl_prefer_server_ciphers on;\n        location / {\n             if ($request_method = 'OPTIONS') {\n\t\tadd_header Access-Control-Allow-Headers 'Authorization,Content-Type';\n             \tadd_header Access-Control-Allow-Origin *;\n             \tadd_header Access-Control-Allow-Credentials true; \n             \tadd_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n             \treturn 204;\n             }\n             proxy_pass http://localhost:5009;\n             proxy_set_header   X-Real-IP        $remote_addr;\n             proxy_set_header   Host             $host;\n             proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n\t     client_max_body_size 20M;\n        }\n}\n\nserver {\n\tlisten 80;\n\tserver_name api2.meowv.com;\n\trewrite ^(.*)$ https://api2.meowv.com;\n}\n```\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617232140637-752750064.png)\n\n关于配置信息大家可以自己去学习一下，我这里也是简单的使用，我这里监听的端口是 5009，这个端口在 API 项目中是可以自定义的，相信大家都知道。做好以上操作后，在终端执行 `nginx -s reloa`，刷新 nginx 配置使其生效，然后就大功告成了。\n\n关于项目中的数据库和Redis缓存，大家可以自行安装。数据库可以选择使用Sqlite，项目中已经做了一键切换数据库。安装Redis也很简单，相信大家可以自己完成，Redis可用可不用，可以直接关闭。\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200617231936439-1402332824.png)\n\n现在API项目便发布成功，将其部署在Linux系统下面，有了线上正常运行的API，接下来把前端 Blazor 开发的博客也发一下。\n\n## 发布Blog\n\n为了节省服务器资源，现在里面已经容纳了超级多的东西了，我准备将 Blog 部署在 GitHub Pages 上。\n\n使用 Blazor WebAssembly 发布后是纯静态的文件，所以啊，其实放在哪里都可以。无关乎环境，只要可以开启一个WEB服务即可。\n\n在GitHub上创建一个仓库来放我们的发布后的代码，关于创建仓库不会的看这里，https://pages.github.com 。\n\n接下来去发布 Blazor 项目，发布之前改一下API地址，当然这个也可以做成配置文件形式的。\n\n![7](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200618201703995-687896253.png)\n\n![8](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200618202057528-110490665.png)\n\n然后将创建好的仓库克隆下来，把博客静态文件拷贝进去，这时候还不能直接push到仓库中，为了适配 GitHub Pages 我们还要做几点改动。\n\nGitHub Pages 使用的是 Jekyll，以特殊字符开头的文件夹是不会被映射到路由中去的，我们发布的静态文件中刚好有以`_`开头的文件夹`_framework`，为了解决这个问题可以在仓库下面创建一个以`.nojekyll`命名的空文件即可。\n\n根据实际操作和踩坑，现在如果发布还是会报一个无法加载资源的错误`The resource has been blocked.`，然后在GitHub找到了解决办法，详见：https://github.com/dotnet/aspnetcore/issues/19907#issuecomment-600054113 。\n\n新建一个`.gitattributes`文件，写入内容：`* binary`，即可，现在将文件 push 到仓库。\n\n然后在仓库的settings下面开启 GitHub Pages 功能选项。\n\n![9](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203548822-1059079953.png)\n\n我这里自定义了一个域名，如果你也想自定义域名可以在根目录添加一个名为`CNAME`的文件，里面的内容就是你的域名，我这里就是：blazor.meowv.com 。\n\n![10](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200618203930658-681131577.png)\n\n最后在去配置一下域名的 CNAME 解析即可，等待 DNS 生效，便可以用自定义域名访问了。\n\n## 结束语\n\n本系列文章从零开始搭建了API，使用 Blazor 开发了一个简单的博客系统，功能不是很多。整体来说从无到有，自己也踩了一遍坑，也算有不少收获了。\n\n在这里再次感谢那些在公众号给我赞赏的人。🌹🌹🌹\n\n可能整体涉及到的东西不是很多，广度和深度都没有，只是很基础的用了用，在写之前我也已经说过，这些系列是用来记录自己的编码过程，因为大佬们都不愿意出来分享，所以我们渣渣只能做到这种程度。\n\n如果对你没啥帮助，权当看过笑过😀😀或者右上角点一下小叉叉❌❌，因为不管你做的如何，总有人喜欢说三道四~~\n\n如果对你有些许帮助，请多多推广哟。✨✨✨\n\n最后大家可以关注一下我的微信公众号：『**阿星Plus**』🤞🤞🤞\n\n因为疫情影响，今年高考推迟到7月份，每年高考便是我所在公司的业务高峰期，接下来实在太忙，估计也没时间创作了，正好准备休息一段时间，好好思考思考后面为大家带来更好的文章，有缘人下个系列见吧。😊😊😊\n\n本系列文章代码开源地址：https://github.com/meowv/blog\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Blazor"
    ],
    "createdAt": "2020-06-19 08:55:19"
  },
  {
    "title": "基于 Blazor 开发五子棋⚫⚪小游戏",
    "author": "阿星Plus",
    "url": "2020-06-25-blazor",
    "markdown": "**今天是农历五月初五，端午节。在此，祝大家端午安康！**\n\n> 端午节是中华民族古老的传统节日之一。端午也称端五，端阳。此外，端午节还有许多别称，如：午日节、重五节、五月节、浴兰节、女儿节、天中节、地腊、诗人节、龙日等。\n\n不好意思，跑题了，就此打住。\n\n事情的经过是这样的，今年端午节公司给每位员工都准备了一个粽子礼盒，本以来就几个粽子而已，没想到今年的粽子礼盒内暗藏玄关，内附一个棋盘和五子棋子。\n\n![0](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624200454033-1736429647.jpg)\n\n![1](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624223823010-1063624744.jpg)\n\n![2](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624200513017-818757537.jpg)\n\n粽子什么的都不重要，主要是这个五子棋我还挺喜欢的，哈哈哈。😎\n\n正好这段时间用 Blazor 将之前的博客重构了一遍，于是就想着能否用 Blazor 写一个五子棋⚫⚪小游戏呢？\n\n说干就干，本篇主要是分享基于 Blazor 开发的五子棋小游戏，先放试玩地址：https://blazor.meowv.com/gobang 。\n\n大家可以先打开链接让他先加载一会(挂在GitHub，有点慢~🤪)，再继续回来看文章哈。\n\n![3](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624200925423-580897177.png)\n\n![4](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624200933915-1750169630.png)\n\n刚开始本来我是自己写的，发现越写越复杂，遂放弃就在Github上寻找有没有实现过类似的需求，别说还真有一位大神用 Blazor 实现了，地址：https://github.com/ut32/gobang/ ，所以我的代码逻辑基本上都参考这位大神的代码。👍👍👍\n\n接下来看看实现过程，新建一个`Gobang.razor`razor组件，设置路由：`@page \"/gobang\"`。\n\n我这里直接放在之前 Blazor 实战系列的项目中，如果你没有看过我的 Blazor 实战系列文章，建议你快去刷一遍。😁\n\n相信五子棋大家都玩过，规则我就不说了。\n\n先理一下需求和实现步骤：\n\n1. 在页面上显示一个 19x19 的棋盘。\n2. 给两个选项，电脑先手还是我先手。\n3. 开始游戏按钮，结束游戏按钮，一个按钮，文字动态显示。\n4. 落子问题，黑子始终先手，黑白交替落子，已经落子的地方不允许继续落子。\n5. 黑白棋子落子的样式问题。\n6. 人机对战，电脑如何最佳选择位置进行落子。\n7. 如何判断输赢，四个方向：横竖撇捺。\n8. 实现一个简单的五子棋小游戏，不考虑放弃落子、禁手等问题。\n\n先渲染一个 19x19 的棋盘，直接两层 for 循环配合 CSS 搞定。\n\n```html\n<div class=\"gobang-box\">\n    <div class=\"chess\">\n        @for (var i = 0; i < 19; i++)\n        {\n            @for (var j = 0; j < 19; j++)\n            {\n                var _i = i;\n                var _j = j;\n                <div class=\"cell\" @onclick=\"@(async () => await Playing(_i, _j))\">\n                    <span class=\"chess@(Chess[i, j])\"></span>\n                </div>\n            }\n        }\n    </div>\n</div>\n```\n\n其中的`onclick`方法先不看，主要是我方落子的点击事件。\n\n`Chess`是定义的一个二维数组：`private int[,] Chess = new int[19, 19];`。\n\n最重要的棋子就是`span`标签，用class来控制黑白，当`class = \"chess1\"`为黑子，当`class = \"chess2\"`为白子。\n\n同时在棋盘旁边添加一些按钮，选择谁先手的选项和描述信息。\n\n```html\n<div class=\"chess-info\">\n    <h1>五子棋⚫⚪</h1>\n    <p><b>⚡是时候表演真正的技术了，快来一场人机大战吧⚡</b></p>\n    <p><label><input type=\"radio\" name=\"chess\" checked=\"checked\" @onclick=\"@(() => first = \"ai\")\"> 电脑先手</label></p>\n    <p><label><input type=\"radio\" name=\"chess\" @onclick=\"@(() => first = \"me\")\"> 我先手</label></p>\n    <p><button class=\"box-btn\" @onclick=\"StartGame\">@(IsInGame ? \"结束游戏\" : \"开始游戏\")</button></p>\n    <div class=\"chess-msg\">\n        <p><b>@msgs</b></p>\n        <p>游戏规则：</p>\n        <span>（1）请选择电脑先手还是你先手，黑棋始终先手。</span>\n        <span>（2）点击开始游戏按钮开始对局。</span>\n        <span>（3）点击结束游戏按钮结束对局。</span>\n        <span>（4）对局双方各执一色棋子。</span>\n        <span>（5）空棋盘开局。</span>\n        <span>（6）黑先、白后，交替下子，每次只能下一子。</span>\n        <span>（7）棋子下在棋盘的空白点上，棋子下定后，不得向其它点移动，不得从棋盘上拿掉或拿起另落别处。</span>\n        <span>（8）黑方的第一枚棋子可下在棋盘任意交叉点上。</span>\n        <span>（9）轮流下子是双方的权利，<del>但允许任何一方放弃下子权（即：PASS权）</del>。</span>\n        <span>（10）<del>五子棋对局，执行黑方指定开局、三手可交换、五手两打的规定。整个对局过程中黑方有禁手，白方无禁手。黑方禁手有三三禁手、四四禁手和长连禁手三种。</del></span>\n    </div>\n</div>\n```\n\n这里同时把用到的css样式给到大家。\n\n```css\n.gobang-box {\n    width: 1200px;\n    margin: 0 auto;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n.chess {\n    width: 760px;\n    height: 760px;\n    float: left;\n}\n.chess .cell {\n    float: left;\n    width: 40px;\n    height: 40px;\n    position: relative;\n    cursor: pointer;\n    font-size: 10px;\n    color: #ffd800;\n}\n.chess .cell::after {\n    content:' ';\n    position: absolute;\n    height: 2px;\n    display: block;\n    width: 100%;\n    border-bottom: #f5d099 1px solid;\n    background: #c8a06f;\n    top: 50%;\n    left: 0;\n    z-index: 2;\n}\n.chess .cell::before {\n    content:' ';\n    position: absolute;\n    height: 100%;\n    display: block;\n    width: 2px;\n    border-right: #f5d099 1px solid;\n    background: #c8a06f;\n    top: 0;\n    left: 50%;\n    z-index: 1;\n}\n.chess .cell .chess1 {\n    display: block;\n    width: 30px;\n    height: 30px;\n    border-radius: 15px;\n    text-align: center;\n    line-height: 54px;\n    background: #000000;\n    left: 5px;\n    top: 5px;\n    position: absolute;\n    z-index: 10;\n    background-image: radial-gradient(#444 5%, #111 15%, #000 60%);\n    box-shadow: 0px 0px 3px #333;\n}\n.chess .cell .chess2 {\n    display: block;\n    width: 30px;\n    height: 30px;\n    border-radius: 15px;\n    text-align: center;\n    left: 5px;\n    top: 5px;\n    position: absolute;\n    z-index: 10;\n    line-height: 54px;\n    background-image: radial-gradient(#ffffff 5%, #f1f1f1 15%, #f1f1f1 60%);\n    box-shadow: 0px 0px 3px #333;\n}\n.chess-info {\n    float: left;\n    width: 400px;\n    height: 760px;\n    padding-left: 20px;\n    margin-left: 40px;\n}\n.chess-info input {\n    display: initial;\n    width: initial;\n    height: initial;\n    visibility: initial;\n}\n.chess-msg {\n    margin-top: 20px;\n    color: #aaa;\n}\n.chess-msg span {\n    display: block;\n    font-size: 12px;\n}\n```\n\n现在来把用到的一些变量和方法搞进来。\n\n```csharp\nprivate int[,] Chess = new int[19, 19];\n\nprivate string first = \"ai\";\n\nprivate bool IsInGame = false;\n\nprivate string msgs;\n\nprivate int AIChess = 1;\n\nprivate int MineChess = 2;\n```\n\n`Chess`是棋盘的二维数组。\n\n`first`为先手字段，默认电脑先手，我这里赋值为\"ai\"，用他来判断是我先手还是电脑先手。\n\n`IsInGame`用来判断当前游戏状态，是否开始游戏，可以根据它来动态控制按钮文字内容。\n\n`msgs`是一个提示信息，告诉玩家双方执子情况。\n\n`AIChess = 1`和`MineChess = 2`就是黑白子，默认电脑为黑子，我为白子。\n\n上方两个radio标签，用来选择谁先手，点击事件分别给`first`赋值，按钮点击事件`StartGame`。\n\n```csharp\nprivate void StartGame()\n{\n    // 初始化棋盘\n    Chess = new int[19, 19];\n\n    // 是否开始游戏，点击按钮重置显示消息\n    if (IsInGame)\n    {\n        msgs = string.Empty;\n    }\n    else\n    {\n        // 电脑先手\n        if (first == \"ai\")\n        {\n            AIChess = 1;\n            MineChess = 2;\n\n            // 电脑落子正中心天元位置\n            Chess[9, 9] = AIChess;\n\n            msgs = \"电脑：执黑子 ⚫ 我：执白子 ⚪\";\n        }\n        else\n        {\n            // 我先手的话则我执黑子，电脑执白子\n            MineChess = 1;\n            AIChess = 2;\n\n            msgs = \"我：执黑子 ⚫ 电脑：执白子 ⚪\";\n        }\n    }\n\n    // 改变游戏状态，用于显示不同文字的按钮\n    IsInGame = !IsInGame;\n}\n```\n\n开始游戏之前，先初始化一下棋盘，然后判断当前是否在游戏中，在游戏中点了按钮对应的肯定是结束游戏，那么此时将提示消息清空。如果未开始游戏，点了按钮就是开始对局了，此时就去判断电脑先手还是我先手。根据这两种情况分别给`AIChess`和`MineChess`赋值，给出对应的提示消息。如果是电脑先手，那么自动在棋盘正中心位置落子，查了一下这个位置叫天元。直接将棋盘数组赋值`Chess[9, 9] = AIChess;`即可，最后点了按钮是需要改变状态的：`IsInGame= !IsInGame;`。\n\n那么如果是我先手或者电脑落子之后，此时需要我方落子，那么我方落子的方法就是`Playing(int row, int cell)`方法。\n\n```csharp\nprivate async Task Playing(int row, int cell)\n{\n    // 是否开始游戏，当前判断没开始给出提示\n    if (!IsInGame)\n    {\n        await Common.InvokeAsync(\"alert\", \"\\n💪点击开始游戏按钮开启对局，请阅读游戏规则💪\");\n        return;\n    }\n\n    // 已落子直接返回，不做任何操作\n    if (Chess[row, cell] != 0)\n        return;\n\n    // 根据传进来的坐标进行我方落子\n    Chess[row, cell] = MineChess;\n\n    if (IsWin(MineChess, row, cell))\n    {\n        await Common.InvokeAsync(\"alert\", \"\\n恭喜，你赢了👍\");\n        IsInGame = !IsInGame;\n        return;\n    }\n\n    // 我方落子之后电脑落子\n    await AIPlaying(AIChess);\n}\n```\n\n我放落子之前先判断是否开始游戏，如果为点击开始游戏按钮，则给出弹窗提示，直接返回不做任何操作，接着有一种情况，我方点击了已经落子了的位置，也不做任何操作直接返回。\n\n某位置是否落子可以根据传进来的坐标进行判断，`Chess[row, cell] == 0` 表示未落子，`Chess[row, cell] != 0`就表示已经落子了，这里不可以继续落子了。\n\n然后就可以将我方点击的位置进行落子了，直接给数组赋值即可：`Chess[row, cell] = MineChess;`。\n\n落子之后需要判断输赢，这里引入了一个新的方法`IsWin(...)`后面说。如果返回true就是赢了，给出提示，改变游戏状态。如果没有赢，我方落子之后就该电脑落子了，这里也是引入了一个新的方法：`AIPlaying(...)`。\n\n```csharp\nprivate async Task AIPlaying(int chess)\n{\n    // 我方\n    var minePoints = new List<ValuedPoint>();\n    // 电脑\n    var aiPonints = new List<ValuedPoint>();\n\n    for (int i = 0; i < 19; i++)\n    {\n        for (int j = 0; j < 19; j++)\n        {\n            // 还未落子的位置列表\n            if (Chess[i, j] == 0)\n            {\n                minePoints.Add(GetValuedPoint(chess, i, j));\n\n                aiPonints.Add(GetValuedPoint((chess == 1 ? 2 : 1), i, j));\n            }\n        }\n    }\n\n    // 获取最佳位置\n    var minePoint = minePoints.OrderByDescending(x => x.Score).FirstOrDefault();\n    var aiPonint = aiPonints.OrderByDescending(x => x.Score).FirstOrDefault();\n\n    if (minePoint != null && aiPonint != null)\n    {\n        // 如果某个位置对手分数高于我方，则抢占位置\n        if (minePoint.Score > aiPonint.Score)\n        {\n            Chess[minePoint.Point.Row, minePoint.Point.Cell] = chess;\n\n            if (IsWin(AIChess, minePoint.Point.Row, minePoint.Point.Cell))\n            {\n                await Common.InvokeAsync(\"alert\", \"\\n电脑赢了，你个渣渣👎\");\n                IsInGame = !IsInGame;\n                return;\n            }\n        }\n        else\n        {\n            Chess[aiPonint.Point.Row, aiPonint.Point.Cell] = chess;\n\n            if (IsWin(AIChess, aiPonint.Point.Row, aiPonint.Point.Cell))\n            {\n                await Common.InvokeAsync(\"alert\", \"\\n电脑赢了，你个渣渣👎\");\n                IsInGame = !IsInGame;\n                return;\n            }\n        }\n    }\n}\n```\n\n电脑落子采用的是遍历计分方式，计算每一个空位的分数，分数由高到底，于是先构建一个对象`ValuedPoint`。\n\n```csharp\n//ValuedPoint.cs\npublic class ValuedPoint\n{\n    public Point Point { get; set; }\n\n    public int Score { get; set; }\n}\n\n//Point.cs\npublic struct Point\n{\n    public int Row { get; set; }\n    public int Cell { get; set; }\n}\n```\n\n添加我方和电脑计分对象列表：`minePoints`和`aiPonints`，遍历棋盘中未落子的位置进行分数计算，计算分数策略引入一个新的方法：`GetValuedPoint(...)`。\n\n然后分别获取黑子和白子双方应该落子的最佳位置，即获取到分数最高的位置坐标，就电脑落子来说，如果我分数高于电脑，电脑就会抢占这个位置进行落子。\n\n落子之后同样调用`IsWin(...)`来判断电脑是否赢了，赢了给出提示改变状态结束对局，没赢就继续下。\n\n现在来看看计分的策略：`GetValuedPoint(...)`。\n\n![5](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624213155734-1296194493.png)\n\n<details>\n<summary>点击查看代码</summary>\n\n```csharp\nprivate ValuedPoint GetValuedPoint(int chess, int row, int cell)\n{\n    var aiChess = chess == 1 ? 2 : 1;\n\n    int HScore = 0, VScore = 0, PScore = 0, LScore = 0;\n\n    #region 横方向 ➡⬅\n\n    {\n        var i = 1;\n        var score = 1;\n        var validPlace = 0;\n        var rightValid = true;\n        var leftValid = true;\n        var rightSpace = 0;\n        var leftSpace = 0;\n        var isDead = false;\n\n        while (i < 5)\n        {\n            var right = cell + i;\n            if (rightValid && right < 19)\n            {\n                if (Chess[row, right] == chess)\n                {\n                    if (rightSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[row, right] == 0)\n                {\n                    rightSpace++;\n                    validPlace++;\n                }\n                else if (Chess[row, right] == aiChess)\n                {\n                    rightValid = false;\n                    if (rightSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            var left = cell - i;\n            if (leftValid && left >= 0)\n            {\n                if (Chess[row, left] == chess)\n                {\n                    if (leftSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[row, left] == 0)\n                {\n                    leftSpace++;\n                    validPlace++;\n                }\n                else if (Chess[row, left] == aiChess)\n                {\n                    leftValid = false;\n                    if (leftSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            i++;\n        }\n\n        if (score >= 5)\n            HScore = 100000;\n\n        if (score == 4)\n        {\n            if (!isDead)\n                HScore = 80000;\n            else\n                HScore = validPlace <= 4 ? 0 : 8000;\n        }\n\n        if (score == 3)\n        {\n            if (!isDead)\n                HScore = validPlace <= 4 ? 0 : 4000;\n            else\n                HScore = validPlace <= 4 ? 0 : 2000;\n        }\n\n        if (score == 2)\n        {\n            if (!isDead)\n                HScore = validPlace <= 4 ? 0 : 600;\n            else\n                HScore = validPlace <= 4 ? 0 : 300;\n        }\n    }\n\n    #endregion\n\n    #region 竖方向 ⬇⬆\n\n    {\n        var i = 1;\n        var score = 1;\n        var validPlace = 0;\n        var topValid = true;\n        var bottomValid = true;\n        var topSpace = 0;\n        var bottomSpace = 0;\n        var isDead = false;\n\n        while (i < 5)\n        {\n            var top = row - i;\n            if (topValid && top >= 0)\n            {\n                if (Chess[top, cell] == chess)\n                {\n                    if (topSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[top, cell] == 0)\n                {\n                    topSpace++;\n                    validPlace++;\n                }\n                else if (Chess[top, cell] == aiChess)\n                {\n                    topValid = false;\n                    if (topSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            var bottom = row + i;\n            if (bottomValid && bottom < 19)\n            {\n                if (Chess[bottom, cell] == chess)\n                {\n                    if (bottomSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[bottom, cell] == 0)\n                {\n                    bottomSpace++;\n                    validPlace++;\n                }\n                else if (Chess[bottom, cell] == aiChess)\n                {\n                    bottomValid = false;\n                    if (bottomSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            i++;\n        }\n\n        if (score >= 5)\n            VScore = 100000;\n\n        if (score == 4)\n        {\n            if (!isDead)\n                VScore = 80000;\n            else\n                VScore = validPlace <= 4 ? 0 : 8000;\n        }\n        if (score == 3)\n        {\n            if (!isDead)\n                VScore = validPlace <= 4 ? 0 : 4000;\n            else\n                VScore = validPlace <= 4 ? 0 : 2000;\n        }\n        if (score == 2)\n        {\n            if (!isDead)\n                VScore = validPlace <= 4 ? 0 : 600;\n            else\n                VScore = validPlace <= 4 ? 0 : 300;\n        }\n    }\n\n    #endregion\n\n    #region 撇方向 ↙↗\n\n    {\n        var i = 1;\n        var score = 1;\n        var validPlace = 0;\n        var topValid = true;\n        var bottomValid = true;\n        var topSpace = 0;\n        var bottomSpace = 0;\n        var isDead = false;\n\n        while (i < 5)\n        {\n            var rightTopRow = row - i;\n            var rightTopCell = cell + i;\n            if (topValid && rightTopRow >= 0 && rightTopCell < 19)\n            {\n                if (Chess[rightTopRow, rightTopCell] == chess)\n                {\n                    if (topSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[rightTopRow, rightTopCell] == 0)\n                {\n                    topSpace++;\n                    validPlace++;\n                }\n                else if (Chess[rightTopRow, rightTopCell] == aiChess)\n                {\n                    topValid = false;\n                    if (topSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            var leftBottomRow = row + i;\n            var leftBottomCell = cell - i;\n            if (bottomValid && leftBottomRow < 19 && leftBottomCell >= 0)\n            {\n                if (Chess[leftBottomRow, leftBottomCell] == chess)\n                {\n                    if (bottomSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[leftBottomRow, leftBottomCell] == 0)\n                {\n                    bottomSpace++;\n                    validPlace++;\n                }\n                else if (Chess[leftBottomRow, leftBottomCell] == aiChess)\n                {\n                    bottomValid = false;\n                    if (bottomSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            i++;\n        }\n\n        if (score >= 5)\n            PScore = 100000;\n\n        if (score == 4)\n        {\n            if (!isDead)\n                PScore = 80000;\n            else\n                PScore = validPlace <= 4 ? 0 : 9000;\n        }\n        if (score == 3)\n        {\n            if (!isDead)\n                PScore = validPlace <= 4 ? 0 : 4500;\n            else\n                PScore = validPlace <= 4 ? 0 : 3000;\n        }\n        if (score == 2)\n        {\n            if (!isDead)\n                PScore = validPlace <= 4 ? 0 : 800;\n            else\n                PScore = validPlace <= 4 ? 0 : 500;\n        }\n    }\n\n    #endregion\n\n    #region 捺方向 ↘↖\n\n    {\n        var i = 1;\n        var score = 1;\n        var validPlace = 0;\n        var topSpace = 0;\n        var bottomSpace = 0;\n        var topValid = true;\n        var bottomValid = true;\n        var isDead = false;\n\n        while (i < 5)\n        {\n            var leftTopRow = row - i;\n            var leftTopCell = cell - i;\n            if (topValid && leftTopRow >= 0 && leftTopCell >= 0)\n            {\n                if (Chess[leftTopRow, leftTopCell] == chess)\n                {\n                    if (topSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[leftTopRow, leftTopCell] == 0)\n                {\n                    topSpace++;\n                    validPlace++;\n                }\n                else if (Chess[leftTopRow, leftTopCell] == aiChess)\n                {\n                    topValid = false;\n                    if (topSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            var rightBottomRow = row + i;\n            var rightBottomCell = cell + i;\n            if (bottomValid && rightBottomRow < 19 && rightBottomCell < 19)\n            {\n                if (Chess[rightBottomRow, rightBottomCell] == chess)\n                {\n                    if (bottomSpace == 0)\n                        score++;\n                    validPlace++;\n                }\n                else if (Chess[rightBottomRow, rightBottomCell] == 0)\n                {\n                    bottomSpace++;\n                    validPlace++;\n                }\n                else if (Chess[rightBottomRow, rightBottomCell] == aiChess)\n                {\n                    bottomValid = false;\n                    if (bottomSpace == 0)\n                        isDead = true;\n                }\n            }\n\n            i++;\n        }\n\n        if (score >= 5)\n            LScore = 100000;\n\n        if (score == 4)\n        {\n            if (!isDead)\n                LScore = 80000;\n            else\n                LScore = validPlace <= 4 ? 0 : 9000;\n        }\n\n        if (score == 3)\n        {\n            if (!isDead)\n                LScore = validPlace <= 4 ? 0 : 4500;\n            else\n                LScore = validPlace <= 4 ? 0 : 3000;\n        }\n\n        if (score == 2)\n        {\n            if (!isDead)\n                LScore = validPlace <= 4 ? 0 : 800;\n            else\n                LScore = validPlace <= 4 ? 0 : 500;\n        }\n    }\n\n    #endregion\n\n    return new ValuedPoint\n    {\n        Score = HScore + VScore + PScore + LScore,\n        Point = new Point\n        {\n            Row = row,\n            Cell = cell\n        }\n    };\n}\n```\n\n</details>\n\n分别对给定位置的棋子四个方向：横方向 ➡⬅、竖方向 ⬇⬆、撇方向 ↙↗、捺方向 ↘↖ 进行遍历，计算每一个空位的分数，分数由高到低，最后返回`ValuedPoint`对象。\n\n最后判断是否赢棋五子连珠的方法：`IsWin(int chess, int row, int cell)`。\n\n```csharp\nprivate bool IsWin(int chess, int row, int cell)\n{\n    #region 横方向 ➡⬅\n\n    {\n            var i = 1;\n            var score = 1;\n            var rightValid = true;\n            var leftValid = true;\n\n            while (i <= 5)\n            {\n                var right = cell + i;\n                if (rightValid && right < 19)\n                {\n                    if (Chess[row, right] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        rightValid = false;\n                }\n\n                var left = cell - i;\n                if (leftValid && left >= 0)\n                {\n                    if (Chess[row, left] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        leftValid = false;\n                }\n\n                i++;\n            }\n    }\n\n    #endregion\n\n    #region 竖方向 ⬇⬆\n\n    {\n            var i = 1;\n            var score = 1;\n            var topValid = true;\n            var bottomValid = true;\n\n            while (i < 5)\n            {\n                var top = row - i;\n                if (topValid && top >= 0)\n                {\n                    if (Chess[top, cell] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        topValid = false;\n                }\n\n                var bottom = row + i;\n                if (bottomValid && bottom < 19)\n                {\n                    if (Chess[bottom, cell] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                    {\n                        bottomValid = false;\n                    }\n                }\n\n                i++;\n            }\n    }\n\n    #endregion\n\n    #region 撇方向 ↙↗\n\n    {\n            var i = 1;\n            var score = 1;\n            var topValid = true;\n            var bottomValid = true;\n\n            while (i < 5)\n            {\n                var rightTopRow = row - i;\n                var rightTopCell = cell + i;\n                if (topValid && rightTopRow >= 0 && rightTopCell < 19)\n                {\n                    if (Chess[rightTopRow, rightTopCell] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        topValid = false;\n                }\n\n                var leftBottomRow = row + i;\n                var leftBottomCell = cell - i;\n                if (bottomValid && leftBottomRow < 19 && leftBottomCell >= 0)\n                {\n                    if (Chess[leftBottomRow, leftBottomCell] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        bottomValid = false;\n                }\n\n                i++;\n            }\n    }\n\n    #endregion\n\n    #region 捺方向 ↘↖\n\n    {\n            var i = 1;\n            var score = 1;\n            var topValid = true;\n            var bottomValid = true;\n\n            while (i < 5)\n            {\n                var leftTopRow = row - i;\n                var leftTopCell = cell - i;\n                if (topValid && leftTopRow >= 0 && leftTopCell >= 0)\n                {\n                    if (Chess[leftTopRow, leftTopCell] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        topValid = false;\n                }\n\n                var rightBottomRow = row + i;\n                var rightBottomCell = cell + i;\n                if (bottomValid && rightBottomRow < 19 && rightBottomCell < 19)\n                {\n                    if (Chess[rightBottomRow, rightBottomCell] == chess)\n                    {\n                        score++;\n                        if (score >= 5)\n                            return true;\n                    }\n                    else\n                        bottomValid = false;\n                }\n\n                i++;\n            }\n    }\n\n    #endregion\n\n    return false;\n}\n```\n\n当对弈双方在棋盘落子后，基于落子的坐标，在四个方向：横方向 ➡⬅、竖方向 ⬇⬆、撇方向 ↙↗、捺方向 ↘↖ 找到是否有五个连子，如果可以找到就返回true，表示赢了，结束本局，没找到就继续对弈。\n\n以上便是基于 Blazor 开发五子棋⚫⚪小游戏的实现过程，功能比较单一，请君赏阅，最后再次祝大家端午节安康！\n\n**好了我不能再写了，我女朋友喊我下五子棋⚫⚪去了。**🤭🤭🤭\n\n![6](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202006/891843-20200624222910134-2054652821.jpg)\n\n\n",
    "category": "Blazor",
    "tag": [
      ".NET Core",
      "Blazor",
      "五子棋"
    ],
    "createdAt": "2020-06-25 10:56:25"
  },
  {
    "title": "GIT COMMIT EMOJIS",
    "author": "阿星Plus",
    "url": "2020-07-20-emojis",
    "markdown": "emoji                   | emoji 代码 | commit 说明\n:-------- | :--------                      | :--------\n🎉 (庆祝) | `:tada:`                       | 初次提交\n🆕 (全新) | `:new:`                        | 引入新功能\n🔖 (书签) | `:bookmark:`                   | 发行/版本标签\n🐛 (bug) | `:bug:`                        | 修复 bug\n🚑 (急救车) | `:ambulance:`                  | 重要补丁\n🌐 (地球) | `:globe_with_meridians:`       | 国际化与本地化\n💄 (口红) | `:lipstick:`                   | 更新 UI 和样式文件\n🎬 (场记板) | `:clapper:`                    | 更新演示/示例\n🚨 (警车灯) | `:rotating_light:`             | 移除 linter 警告\n🔧 (扳手) | `:wrench:`                     | 修改配置文件\n➕ (加号) | `:heavy_plus_sign:`            | 增加一个依赖\n➖ (减号) | `:heavy_minus_sign:`           | 减少一个依赖\n⬆️ (上升箭头) | `:arrow_up:`                   | 升级依赖\n⬇️  (下降箭头) | `:arrow_down:`                 | 降级依赖\n⚡ (闪电)🐎 (赛马) | `:zap:``:racehorse:`       | 提升性能\n📈 (上升趋势图) | `:chart_with_upwards_trend:`   | 添加分析或跟踪代码\n🚀 (火箭) | `:rocket:`                     | 部署功能\n✅ (白色复选框) | `:white_check_mark:`           | 增加测试\n📝 (备忘录)📖 (书) | `:memo:``:book:`           | 撰写文档\n🔨 (锤子) | `:hammer:`                     | 重大重构\n🎨 (调色板) | `:art:`                        | 改进代码结构/代码格式\n🔥 (火焰) | `:fire:`                       | 移除代码或文件\n✏️ (铅笔) | `:pencil2:`                    | 修复 typo\n🚧 (施工) | `:construction:`               | 工作进行中\n🗑️ (垃圾桶) | `:wastebasket:`                | 废弃或删除\n♿ (轮椅) | `:wheelchair:`                 | 可访问性\n👷 (工人) | `:construction_worker:`        | 添加 CI 构建系统\n💚 (绿心) | `:green_heart:`                | 修复 CI 构建问题\n🔒 (锁) | `:lock:`                       | 修复安全问题\n🐳 (鲸鱼) | `:whale:`                      | Docker 相关工作\n🍎 (苹果) | `:apple:`                      | 修复 macOS 下的问题\n🐧 (企鹅) | `:penguin:`                    | 修复 Linux 下的问题\n🏁 (旗帜) | `:checkered_flag:`             | 修复 Windows 下的问题\n🔀 (交叉箭头) | `:twisted_rightwards_arrows:`  | 分支合并\n\n",
    "category": "Other",
    "tag": [
      "git",
      "Emojis"
    ],
    "createdAt": "2020-07-20 12:29:20"
  },
  {
    "title": "基于 abp vNext 的快速开发模板",
    "author": "阿星Plus",
    "url": "2020-09-02-abp-template",
    "markdown": "## 介绍\n\nTemplates to use when creating an application for abp vNext.\n\n基于abp已经最小化集成了各种项目开发所需的组件，Redis、Swagger、Autofac、Serilog、数据迁移、JWT、多语言支持等，支持多数据库(MySql、SqlServer、Sqlite、MongoDB)自由切换，可以根据业务需求自行简单修改，真正的开箱即用，直接开干写业务。\n\n## 快速使用\n\n```bash\ndotnet new -i AbpTemplate\ndotnet new abp -n Xxx(The name for the output being created)\n```\n\n创建成功后的项目结构如下：\n\n```bash\nDocuments\n ├── Documents.sln\n ├── LICENSE\n ├── src\n │   ├── Documents.Application\n │   ├── Documents.Application.Caching\n │   ├── Documents.Application.Contracts\n │   ├── Documents.DbMigrator\n │   ├── Documents.Domain\n │   ├── Documents.Domain.Shared\n │   ├── Documents.EntityFrameworkCore\n │   ├── Documents.EntityFrameworkCore.DbMigrations\n │   ├── Documents.HttpApi\n │   ├── Documents.HttpApi.Host\n │   └── Documents.MongoDB\n └── test\n     ├── Documents.Application.Tests\n     ├── Documents.Domain.Tests\n     ├── Documents.EntityFrameworkCore.Tests\n     ├── Documents.MongoDB.Tests\n     └── Documents.TestBase\n```\n\n## Nuget\n\n[https://www.nuget.org/packages/AbpTemplate](https://www.nuget.org/packages/AbpTemplate)\n\n## 开源地址\n\n[https://github.com/Meowv/AbpTemplate](https://github.com/Meowv/AbpTemplate)\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "abp vNext"
    ],
    "createdAt": "2020-09-02 08:51:02"
  },
  {
    "title": "动态 Restful API 生成",
    "author": "阿星Plus",
    "url": "2020-09-02-autoapi",
    "markdown": "## 介绍\n\n通常在DDD开发架构中，我们写完服务层需要在控制器中写API，今天介绍一个组件 `Plus.AutoApi` 可以用它来动态生成 Restful 风格的 WebApi，不用写 Controller。\n\n## 快速使用\n\n在你的应用服务层中添加组件\n\n```PowerShell\nInstall-Package Plus.AutoApi\n```\n\n在 Startup 中注册 AutoApi\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddAutoApi(x => { });\n}\n```\n\n`AddAutoApi` 同时也支持各种 Options 参数，可以自行查看。\n\n让你的服务直接或者间接实现`IAutoApi`，添加特性`[AutoApi]`即可，示例代码如下：\n\n```csharp\n[AutoApi]\npublic class WeatherService : IAutoApi\n{\n    private static readonly string[] Summaries = new[]\n    {\n        \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\"\n    };\n\n    public IEnumerable<WeatherForecast> Get()\n    {\n        return WeatherForecast();\n    }\n\n    [HttpGet(\"{id}\")]\n    public IEnumerable<WeatherForecast> Get(int id)\n    {\n        return WeatherForecast();\n    }\n\n    public IEnumerable<WeatherForecast> Post()\n    {\n        return WeatherForecast();\n    }\n\n    [HttpPut(\"{id}\")]\n    public IEnumerable<WeatherForecast> Put(int id)\n    {\n        return WeatherForecast();\n    }\n\n    [HttpDelete(\"{id}\")]\n    public IEnumerable<WeatherForecast> Delete(int id)\n    {\n        return WeatherForecast();\n    }\n\n    private static IEnumerable<WeatherForecast> WeatherForecast()\n    {\n        var rng = new Random();\n        return Enumerable.Range(1, 5).Select(index => new WeatherForecast\n        {\n            Date = DateTime.Now.AddDays(index),\n            TemperatureC = rng.Next(-20, 55),\n            Summary = Summaries[rng.Next(Summaries.Length)]\n        }).ToArray();\n    }\n}\n```\n\n需要注意的是你的服务层命名规范，默认要以`Service`或者`ApplicationService`结尾，也可以通过配置替换默认名称。\n\n如果你想让某个服务不自动生成API，可以给特性传递参数：`[AutoApi(Disabled = true)]`\n\n让生成的API兼容 Swagger，需要添加下面这句代码。\n\n```csharp {8}\nservices.AddSwaggerGen(options =>\n{\n    options.SwaggerDoc(\"v1\", new OpenApiInfo\n    {\n        Title = \"Plus AutoApi Sample\",\n        Version = \"v1.0.0\"\n    });\n    options.DocInclusionPredicate((docName, description) => true);\n});\n```\n\n同时自动生成API也可以和控制器共存，互不影响。你可以手动指定HTTP方法，也可以根据默认规则自动创建。\n\n默认自动创建HTTP方法的规则如下：\n\n```csharp\nstatic PlusConsts()\n{\n    HttpVerbs = new Dictionary<string, string>()\n    {\n        [\"add\"] = \"POST\",\n        [\"create\"] = \"POST\",\n        [\"post\"] = \"POST\",\n        [\"insert\"] = \"POST\",\n        [\"get\"] = \"GET\",\n        [\"find\"] = \"GET\",\n        [\"fetch\"] = \"GET\",\n        [\"query\"] = \"GET\",\n        [\"update\"] = \"PUT\",\n        [\"put\"] = \"PUT\",\n        [\"delete\"] = \"DELETE\",\n        [\"remove\"] = \"DELETE\"\n    };\n}\n```\n\n上面代码最终生成的API路由如下：\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200902085159585-1954437405.png)\n\n## Samples\n\n[https://github.com/Meowv/Plus.AutoApi/tree/master/samples/Plus.AutoApi.Sample](https://github.com/Meowv/Plus.AutoApi/tree/master/samples/Plus.AutoApi.Sample)\n\n## Nuget\n\n[https://www.nuget.org/packages/Plus.AutoApi](https://www.nuget.org/packages/Plus.AutoApi)\n\n## 开源地址\n\n[https://github.com/Meowv/Plus.AutoApi](https://github.com/Meowv/Plus.AutoApi)\n\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "WebApi"
    ],
    "createdAt": "2020-09-02 08:53:02"
  },
  {
    "title": ".NET Core 中导入导出Excel",
    "author": "阿星Plus",
    "url": "2020-09-04-import-and-export-excel",
    "markdown": "操作Excel是一个比较常见的业务场景，本篇将使用`EPPlus`简单演示一个导入导出的示例。\n\n`EPPlus`开源地址：[https://github.com/EPPlusSoftware/EPPlus](https://github.com/EPPlusSoftware/EPPlus)\n\n在项目中添加`EPPlus`组件\n\n```PowerShell\nInstall-Package EPPlus\n```\n\n## 导入\n\n先准备一个Excel文件，将其内容读取出来，并序列化成JSON字符串进行返回。\n\n![](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200903092719795-1406599664.png)\n\n```csharp\n[HttpPost]\npublic List<ExcelDemoDto> Import([FromForm] ImportExcelInput input)\n{\n    var list = new List<ExcelDemoDto>();\n\n    using (var package = new ExcelPackage(input.ExcelFile.OpenReadStream()))\n    {\n        // 获取到第一个Sheet，也可以通过 Worksheets[\"name\"] 获取指定的工作表\n        var sheet = package.Workbook.Worksheets.First();\n\n        #region 获取开始和结束行列的个数，根据个数可以做各种校验工作\n\n        // +1 是因为第一行往往我们获取到的都是Excel的标题\n        int startRowNumber = sheet.Dimension.Start.Row + 1;\n        int endRowNumber = sheet.Dimension.End.Row;\n        int startColumn = sheet.Dimension.Start.Column;\n        int endColumn = sheet.Dimension.End.Column;\n\n        #endregion\n\n        // 循环获取整个Excel数据表数据\n        for (int currentRow = startRowNumber; currentRow <= endRowNumber; currentRow++)\n        {\n            list.Add(new ExcelDemoDto\n            {\n                AAA = sheet.Cells[currentRow, 1].Text,\n                BBB = sheet.Cells[currentRow, 2].Text,\n                CCC = sheet.Cells[currentRow, 3].Text,\n                DDD = sheet.Cells[currentRow, 4].Text,\n                EEE = sheet.Cells[currentRow, 5].Text,\n                FFF = sheet.Cells[currentRow, 6].Text\n            });\n        }\n    }\n\n    return list;\n}\n\npublic class ExcelDemoDto\n{\n    public string AAA { get; set; }\n    public string BBB { get; set; }\n    public string CCC { get; set; }\n    public string DDD { get; set; }\n    public string EEE { get; set; }\n    public string FFF { get; set; }\n}\n\npublic class ImportExcelInput\n{\n    public IFormFile ExcelFile { get; set; }\n}\n```\n\n![](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200903092742371-466727433.png)\n\n## 导出\n\n```csharp\n[HttpGet]\npublic async Task<string> Export()\n{\n    using var package = new ExcelPackage();\n    var worksheet = package.Workbook.Worksheets.Add(\"sheet1\");\n\n    var headers = new string[] { \"AAA\", \"BBB\", \"CCC\", \"DDD\", \"EEE\", \"FFF\" };\n    for (int i = 0; i < headers.Length; i++)\n    {\n        worksheet.Cells[1, i + 1].Value = headers[i];\n        worksheet.Cells[1, i + 1].Style.Font.Bold = true;\n    }\n\n    // 模拟数据\n    var list = new List<ExcelDemoDto>();\n    for (int i = 1; i <= 10; i++)\n    {\n        list.Add(new ExcelDemoDto\n        {\n            AAA = $\"A{i}\",\n            BBB = $\"B{i}\",\n            CCC = $\"C{i}\",\n            DDD = $\"D{i}\",\n            EEE = $\"E{i}\",\n            FFF = $\"F{i}\"\n        });\n    }\n\n    // 支持各种直接获取数据的方法\n    // worksheet.Cells.Load*...\n\n    int row = 2;\n    foreach (var item in list)\n    {\n        worksheet.Cells[row, 1].Value = item.AAA;\n        worksheet.Cells[row, 2].Value = item.BBB;\n        worksheet.Cells[row, 3].Value = item.CCC;\n        worksheet.Cells[row, 4].Value = item.DDD;\n        worksheet.Cells[row, 5].Value = item.EEE;\n        worksheet.Cells[row, 6].Value = item.FFF;\n\n        row++;\n    }\n\n    // 通常做法是，将excel上传至对象存储，获取到下载链接，这里将其输出到项目根目录。\n    var path = Path.Combine(Directory.GetCurrentDirectory(), $\"excel.xlsx\");\n    await package.GetAsByteArray().DownloadAsync(path);\n    return path;\n}\n```\n\n![](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200903092755410-1216065159.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "EPPlus",
      "Excel"
    ],
    "createdAt": "2020-09-04 08:56:04"
  },
  {
    "title": ".NET Core 中生成验证码",
    "author": "阿星Plus",
    "url": "2020-09-04-captcha",
    "markdown": "在开发中，有时候生成验证码的场景目前还是存在的，本篇演示不依赖第三方组件，生成随机验证码图片。\n\n先添加验证码接口\n\n```csharp\npublic interface ICaptcha\n{\n    /// <summary>\n    /// 生成随机验证码\n    /// </summary>\n    /// <param name=\"codeLength\"></param>\n    /// <returns></returns>\n    Task<string> GenerateRandomCaptchaAsync(int codeLength = 4);\n\n    /// <summary>\n    /// 生成验证码图片\n    /// </summary>\n    /// <param name=\"captchaCode\">验证码</param>\n    /// <param name=\"width\">宽为0将根据验证码长度自动匹配合适宽度</param>\n    /// <param name=\"height\">高</param>\n    /// <returns></returns>\n    Task<CaptchaResult> GenerateCaptchaImageAsync(string captchaCode, int width = 0, int height = 30);\n}\n```\n\n验证码返回模型\n\n```csharp\npublic class CaptchaResult\n{\n    /// <summary>\n    /// CaptchaCode\n    /// </summary>\n    public string CaptchaCode { get; set; }\n\n    /// <summary>\n    /// CaptchaMemoryStream\n    /// </summary>\n    public MemoryStream CaptchaMemoryStream { get; set; }\n\n    /// <summary>\n    /// Timestamp\n    /// </summary>\n    public DateTime Timestamp { get; set; }\n}\n```\n\n接下来实现接口，主要是依赖微软的`System.Drawing.Common`组件，注意命名空间的引用\n\n```csharp\nusing System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.IO;\nusing System.Threading.Tasks;\n\n...\n\npublic class Captcha : ICaptcha\n{\n    private const string Letters = \"1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,U,V,W,X,Y,Z\";\n\n    public Task<CaptchaResult> GenerateCaptchaImageAsync(string captchaCode, int width = 0, int height = 30)\n    {\n        //验证码颜色集合\n        Color[] c = { Color.Black, Color.Red, Color.DarkBlue, Color.Green, Color.Orange, Color.Brown, Color.DarkCyan, Color.Purple };\n\n        //验证码字体集合\n        string[] fonts = { \"Verdana\", \"Microsoft Sans Serif\", \"Comic Sans MS\", \"Arial\" };\n\n        //定义图像的大小，生成图像的实例\n        var image = new Bitmap(width == 0 ? captchaCode.Length * 25 : width, height);\n\n        var g = Graphics.FromImage(image);\n\n        //背景设为白色\n        g.Clear(Color.White);\n\n        var random = new Random();\n\n        for (var i = 0; i < 100; i++)\n        {\n            var x = random.Next(image.Width);\n            var y = random.Next(image.Height);\n            g.DrawRectangle(new Pen(Color.LightGray, 0), x, y, 1, 1);\n        }\n\n        //验证码绘制在g中\n        for (var i = 0; i < captchaCode.Length; i++)\n        {\n            //随机颜色索引值\n            var cindex = random.Next(c.Length);\n\n            //随机字体索引值\n            var findex = random.Next(fonts.Length);\n\n            //字体\n            var f = new Font(fonts[findex], 15, FontStyle.Bold);\n\n            //颜色  \n            Brush b = new SolidBrush(c[cindex]);\n\n            var ii = 4;\n            if ((i + 1) % 2 == 0)\n                ii = 2;\n\n            //绘制一个验证字符  \n            g.DrawString(captchaCode.Substring(i, 1), f, b, 17 + (i * 17), ii);\n        }\n\n        var ms = new MemoryStream();\n        image.Save(ms, ImageFormat.Png);\n\n        g.Dispose();\n        image.Dispose();\n\n        return Task.FromResult(new CaptchaResult\n        {\n            CaptchaCode = captchaCode,\n            CaptchaMemoryStream = ms,\n            Timestamp = DateTime.Now\n        });\n    }\n\n    public Task<string> GenerateRandomCaptchaAsync(int codeLength = 4)\n    {\n        var array = Letters.Split(new[] { ',' });\n\n        var random = new Random();\n\n        var temp = -1;\n\n        var captcheCode = string.Empty;\n\n        for (int i = 0; i < codeLength; i++)\n        {\n            if (temp != -1)\n                random = new Random(i * temp * unchecked((int)DateTime.Now.Ticks));\n\n            var index = random.Next(array.Length);\n\n            if (temp != -1 && temp == index)\n                return GenerateRandomCaptchaAsync(codeLength);\n\n            temp = index;\n\n            captcheCode += array[index];\n        }\n\n        return Task.FromResult(captcheCode);\n    }\n}\n```\n\n在控制器中注入调用\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing System.Threading.Tasks;\n\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class CaptchaController : ControllerBase\n{\n    [HttpGet]\n    public async Task<FileContentResult> CaptchaAsync([FromServices] ICaptcha _captcha)\n    {\n        var code = await _captcha.GenerateRandomCaptchaAsync();\n\n        var result = await _captcha.GenerateCaptchaImageAsync(code);\n\n        return File(result.CaptchaMemoryStream.ToArray(), \"image/png\");\n    }\n}\n```\n\n实际使用的时候，`code`就是本次生成的验证码，可以将其保存在`session`中，进行验证，或者其它方式。\n\n![](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200903092919938-545169787.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "验证码"
    ],
    "createdAt": "2020-09-04 08:58:04"
  },
  {
    "title": ".NET Core API文档管理组件 Swagger",
    "author": "阿星Plus",
    "url": "2020-09-06-swagger",
    "markdown": "`Swagger`这个优秀的开源项目相信大家都用过，不多介绍了，这里简单记录一下使用过程。\n\n开源地址：[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)\n\n在项目中添加组件\n\n```PowerShell\nInstall-Package Swashbuckle.AspNetCore\n```\n\n下面用最少的代码完成接入，在`Startup`启动项中配置。\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    ...\n    services.AddSwaggerGen(x =>\n    {\n        x.SwaggerDoc(\"v1\", new Microsoft.OpenApi.Models.OpenApiInfo\n        {\n            Version = \"v1.0.0\",\n            Title = \"Api\",\n            Description = \"XXX Api\"\n        });\n    });\n    ...\n}\n```\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    ...\n\n    app.UseSwagger();\n    app.UseSwaggerUI(c =>\n    {\n        c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"API\");\n    });\n    ...\n}\n```\n\n这样便完成了，`swagger`会自动发现我们在`controller`中写的api，默认打开页面为：`~/swagger`。\n\n同时还可以让其支持分组展示，只需要像上面一样配置多个节点信息接口，如下面代码：\n\n```csharp\nservices.AddSwaggerGen(options =>\n{\n    options.SwaggerDoc(\"v1\", new Microsoft.OpenApi.Models.OpenApiInfo\n    {\n        Version = \"v1.0.0\",\n        Title = \"Api1\",\n        Description = \"XXX Api1\"\n    });\n\n    options.SwaggerDoc(\"v2\", new Microsoft.OpenApi.Models.OpenApiInfo\n    {\n        Version = \"v1.0.0\",\n        Title = \"Api2\",\n        Description = \"XXX Api2\"\n    });\n});\n```\n\n```csharp\napp.UseSwaggerUI(c =>\n{\n    c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"API1\");\n    c.SwaggerEndpoint(\"/swagger/v2/swagger.json\", \"API2\");\n});\n```\n\n如果在控制器中不指定接口的分组名称，那么每个分组都会显示这个接口，如果需要单独指定可以使用特性`[ApiExplorerSettings(GroupName = \"v1\")]`这样。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154357776-1892618855.gif)\n\n如果想要显示接口的注释，模型的注释等信息，需要我们将对应的项目设置输出XML文件，并在代码中使用`options.IncludeXmlComments(xxx.xml)`即可。\n\n下面来说一下`swagger`的一些其它功能，当我们接口开启了`JWT`方式的认证，默认`swagger`是不支持的，需要我们手动去适配一下。\n\n需要额外添加一个组件\n\n```PowerShell\nInstall-Package Swashbuckle.AspNetCore.Filters\n```\n\n```csharp\ncontext.Services.AddSwaggerGen(options =>\n{\n    ...\n\n    var security = new OpenApiSecurityScheme\n    {\n        Description = \"<b>please enter <code>Bearer {Token}</code> for authentication.</b>\",\n        Name = \"Authorization\",\n        In = ParameterLocation.Header,\n        Type = SecuritySchemeType.ApiKey\n    };\n\n    options.AddSecurityDefinition(\"oauth2\", security);\n    options.AddSecurityRequirement(new OpenApiSecurityRequirement { { security, null } });\n    options.OperationFilter<AddResponseHeadersFilter>();\n    options.OperationFilter<AppendAuthorizeToSummaryOperationFilter>();\n    options.OperationFilter<SecurityRequirementsOperationFilter>();\n});\n```\n\n现在UI界面便会出现小绿锁，这样就可以很方便的在`swagger`上进行需要授权的接口调试工作了。\n\n同时`swagger`还支持一些高级操作，比如自定义UI界面、注入JS、CSS代码，因为这个用的不是很多，实际要用的时候可以去GitHub查看使用方法。\n\n```csharp\n// Customize index.html\napp.UseSwaggerUI(c =>\n{\n    c.IndexStream = () => GetType().Assembly.GetManifestResourceStream(\"CustomUIIndex.Swagger.index.html\");\n});\n\n// Inject Custom CSS\napp.UseSwaggerUI(c =>\n{\n    ...\n    c.InjectStylesheet(\"/swagger-ui/custom.css\");\n}\n```\n\n这里还要说一下`swagger`的过滤器，我们可以实现`IDocumentFilter`接口，来实现自定义的接口排序，个性化接口描述，以及各种骚操作，比如我们想要隐藏某些API，当然隐藏API可以使用.NET Core 的特性`[ApiExplorerSettings(IgnoreApi = true)]`实现。\n\n这里隐藏是指不在`swagger`UI中显示，实际接口还是存在的。\n\n```csharp\npublic class SwaggerDocumentFilter : IDocumentFilter\n{\n    public void Apply(OpenApiDocument swaggerDoc, DocumentFilterContext context)\n    {\n        var tags = new List<OpenApiTag>\n        {\n            new OpenApiTag {\n                Name = \"Authentication\",\n                Description = \"Authentication\",\n                ExternalDocs = new OpenApiExternalDocs { Description = \"Authentication\" }\n            },\n            new OpenApiTag {\n                Name = \"Localization\",\n                Description = \"Localization\",\n                ExternalDocs = new OpenApiExternalDocs { Description = \"Localization\" }\n            }\n        };\n\n        swaggerDoc.Tags = tags.OrderBy(x => x.Name).ToList();\n\n        var apis = context.ApiDescriptions.Where(x => x.RelativePath.Contains(\"abp\"));\n        if (apis.Any())\n        {\n            foreach (var item in apis)\n            {\n                swaggerDoc.Paths.Remove(\"/\" + item.RelativePath);\n            }\n        }\n    }\n}\n```\n\n上面这段代码，使用了abp框架搭建的项目，abp默认实现了一部分接口，如果我们不需要的话就可以使用上面的方式进行过滤。\n\n最后一点，如果我们用了第三方框架，像上面说的abp，或者使用了动态API生成的组件，比如：[`Plus.AutoApi`](autoapi.md)，想要在`swagger`中显示出api接口，需要添加下面这句代码。\n\n```csharp\ncontext.Services.AddSwaggerGen(options =>\n{\n    ...\n    options.DocInclusionPredicate((docName, description) => true);\n    ...\n});\n```\n\n`swagger`推出的同时还推出了一款工具`ReDoc`，下面也简单介绍一下。\n\n`ReDoc`和`swagger`比较类似，只是一个文档展示工具，不提供接口调试的功能。\n\n他们的使用方式基本一致，先在项目中添加一下组件\n\n```PowerShell\nInstall-Package Swashbuckle.AspNetCore.ReDoc\n```\n\n在`OnApplicationInitialization`中直接添加一句配置即可。\n\n```csharp\napp.UseReDoc();\n```\n\n它支持多种参数选项，可以自行查看，默认打开页面为：`~/api-docs`，下面是他的UI界面。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154409589-2083003502.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Swagger"
    ],
    "createdAt": "2020-09-06 14:20:06"
  },
  {
    "title": ".NET Core 生成二维码",
    "author": "阿星Plus",
    "url": "2020-09-07-qrcode",
    "markdown": "二维码的生成有好多种方式，本篇将使用`QRCoder`来实现，小巧易用，支持并发生成，不依赖第三方库。\n\n开源地址：[https://github.com/codebude/QRCoder](https://github.com/codebude/QRCoder)\n\n先在项目中添加组件\n\n```PowerShell\nInstall-Package QRCoder\n```\n\n然后添加一个生成二维码的接口，并且实现\n\n```csharp\nusing QRCoder;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.IO;\n\npublic interface IQRCode\n{\n    byte[] GenerateQRCode(string content);\n}\n\npublic class QRCode : IQRCode\n{\n    public byte[] GenerateQRCode(string content)\n    {\n        var generator = new QRCodeGenerator();\n\n        var codeData = generator.CreateQrCode(content, QRCodeGenerator.ECCLevel.M, true);\n        QRCoder.QRCode qrcode = new QRCoder.QRCode(codeData);\n\n        var bitmapImg = qrcode.GetGraphic(10, Color.Black, Color.White, false);\n\n        using MemoryStream stream = new MemoryStream();\n        bitmapImg.Save(stream, ImageFormat.Jpeg);\n        return stream.GetBuffer();\n    }\n}\n```\n\n`qrcode.GetGraphic(...)`默认返回了`Bitmap`类型，这里处理成了`byte[]`。\n\n`qrcode.GetGraphic(...)`方法参数简单说明，可以根据开发时候的注释说明进一步了解。\n\n```csharp\npublic Bitmap GetGraphic(int pixelsPerModule, Color darkColor, Color lightColor, Bitmap icon = null, int iconSizePercent = 15, int iconBorderWidth = 6, bool drawQuietZones = true)\n{\n    // int pixelsPerModule 生成二维码图片的像素大小\n    // Color darkColor 暗色 一般设置为Color.Black 黑色\n    // Color lightColor 亮色 一般设置为Color.White 白色\n    // Bitmap icon 二维码水印图标 例如：Bitmap icon = new Bitmap(context.Server.MapPath(\"~/images/zs.png\"));默认为NULL ，加上这个二维码中间会显示一个图标\n    // int iconSizePercent 水印图标的大小比例 ，可根据自己的喜好设置\n    // int iconBorderWidth 水印图标的边框\n    // bool drawQuietZones 静止区，位于二维码某一边的空白边界,用来阻止读者获取与正在浏览的二维码无关的信息，即是否绘画二维码的空白边框区域 默认为true\n}\n```\n\n在控制器中注入调用\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\n\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class QrCodeController : ControllerBase\n{\n    [HttpGet]\n    public FileContentResult QrCode([FromServices] IQRCode _qrcode, string content)\n    {\n        var buffer = _qrcode.GenerateQRCode(content);\n\n        return File(buffer, \"image/jpeg\");\n    }\n}\n```\n\n`QRCoder`会根据content的内容来生成对应的二维码，如果传入的是纯文本，则返回文本内容，如果传入的是一个标准的URL，则扫描二维码的时候会直接打开链接，还是很方便人性化的。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154253646-67912313.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "二维码"
    ],
    "createdAt": "2020-09-07 09:16:07"
  },
  {
    "title": ".NET Core 下收发邮件之 MailKit",
    "author": "阿星Plus",
    "url": "2020-09-07-mailkit",
    "markdown": "利用代码发送邮件在工作中还是比较常见的，相信大家都用过`SmtpClient`来处理发送邮件的操作，不过这个类以及被标记已过时，所以介绍一个微软推荐的库`MailKit`来处理。\n\n`MailKit`开源地址：[https://github.com/jstedfast/MailKit](https://github.com/jstedfast/MailKit)\n\n新建一个控制台应用程序，将`MailKit`添加到项目中。\n\n```PowerShell\nInstall-Package MailKit\n```\n\n新建一个`IEmail`接口。\n\n```csharp\nusing MimeKit;\nusing System.Threading.Tasks;\n\nnamespace EmailDemo\n{\n    public interface IEmail\n    {\n        /// <summary>\n        /// 发送Email\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <returns></returns>\n        Task SendEmailAsync(MimeMessage message);\n    }\n}\n```\n\n然后添加`Email.cs`实现这个接口。\n\n```csharp\nusing MailKit.Net.Smtp;\nusing MimeKit;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace EmailDemo\n{\n    public class Email : IEmail\n    {\n        public async Task SendEmailAsync(MimeMessage message)\n        {\n            var host = \"smtp.exmail.qq.com\";\n            var port = 465;\n            var useSsl = true;\n            var from_username = \"123@meowv.com\";\n            var from_password = \"...\";\n            var from_name = \"测试\";\n            var from_address = \"123@meowv.com\";\n\n            var address = new List<MailboxAddress>\n            {\n                new MailboxAddress(\"111\",\"111@meowv.com\"),\n                new MailboxAddress(\"222\",\"222@meowv.com\")\n            };\n\n            message.From.Add(new MailboxAddress(from_name, from_address));\n            message.To.AddRange(address);\n\n            using var client = new SmtpClient\n            {\n                ServerCertificateValidationCallback = (s, c, h, e) => true\n            };\n            client.AuthenticationMechanisms.Remove(\"XOAUTH2\");\n\n            await client.ConnectAsync(host, port, useSsl);\n            await client.AuthenticateAsync(from_username, from_password);\n            await client.SendAsync(message);\n            await client.DisconnectAsync(true);\n        }\n    }\n}\n```\n\n上面关于邮箱的账号密码服务器可以放在配置文件中，这里为了方便直接写了，演示了发送邮件到两个Email地址。\n\n然后在`Program.cs`中使用依赖注入的方式调用。\n\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\nusing MimeKit;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace EmailDemo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            IServiceCollection service = new ServiceCollection();\n\n            service.AddSingleton<IEmail, Email>();\n\n            var provider = service.BuildServiceProvider().GetRequiredService<IEmail>();\n\n            var message = new MimeMessage\n            {\n                Subject = \"我是邮件主题\",\n                Body = new BodyBuilder\n                {\n                    HtmlBody = $\"我是邮件内容，时间:{DateTime.Now:yyyy-MM-dd HH:mm:ss}\"\n                }.ToMessageBody()\n            };\n\n            await provider.SendEmailAsync(message);\n        }\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154126134-1307378345.png)\n\n以上演示了在 .NET Core 中发送邮件的示例，同时利用`MailKit`也可以接收邮件，这里使用场景不多，如有需要可以参考`MailKit`GitHub代码示例。\n\n通常发送邮件可以提前写好HTML模板，然后将关键内容做字符串替换，这样发出去的就是一个比较美观的邮件了。\n\n`MailKit`还支持将图片作为数据内容发送出去。\n\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\nusing MimeKit;\nusing MimeKit.Utils;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace EmailDemo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            IServiceCollection service = new ServiceCollection();\n\n            service.AddSingleton<IEmail, Email>();\n\n            var provider = service.BuildServiceProvider().GetRequiredService<IEmail>();\n\n            var path = \"D:\\\\bg.jpg\";\n\n            var builder = new BodyBuilder();\n\n            var image = builder.LinkedResources.Add(path);\n            image.ContentId = MimeUtils.GenerateMessageId();\n\n            builder.HtmlBody = $\"当前时间:{DateTime.Now:yyyy-MM-dd HH:mm:ss} <img src=\\\"cid:{image.ContentId}\\\"/>\";\n\n            var message = new MimeMessage\n            {\n                Subject = \"带图片的邮件推送\",\n                Body = builder.ToMessageBody()\n            };\n\n            await provider.SendEmailAsync(message);\n        }\n    }\n}\n```\n\n先在本地准备一张图片，利用ContentId的方式嵌入在img标签中，成功将其发送出去。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154141161-1568668270.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "MailKit"
    ],
    "createdAt": "2020-09-07 09:17:07"
  },
  {
    "title": ".NET Core 集成JWT认证",
    "author": "阿星Plus",
    "url": "2020-09-07-json-web-token",
    "markdown": "`JWT(Json web token)`就不用过多的介绍了，在 .NET Core 开发中使用JWT进行认证也是比较常见的，而且接入过程也比较简单，随便配置配置就好了。\n\n要想使用JWT，仅仅只需要在项目中引用微软的一个认证组件。\n\n```PowerShell\nInstall-Package Microsoft.AspNetCore.Authentication.JwtBearer\n```\n\n然后将一些敏感数据可以放在配置文件`appsettings.json`中。\n\n```json\n{\n    \"JWT\": {\n        \"ClockSkew\": 10,\n        \"ValidAudience\": \"https://meowv.com\",\n        \"ValidIssuer\": \"阿星Plus\",\n        \"IssuerSigningKey\": \"6Zi/5pifUGx1c+mYv+aYn1BsdXPpmL/mmJ9QbHVz6Zi/5pifUGx1c+mYv+aYn1BsdXPpmL/mmJ9QbHVz6Zi/5pifUGx1c+mYv+aYn1BsdXPpmL/mmJ9QbHVz6Zi/5pifUGx1cw==\",\n        \"Expires\": 30\n    }\n}\n```\n\n在`Startup`中添加配置并且使用\n\n```csharp\nservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n        .AddJwtBearer(options =>\n        {\n            options.TokenValidationParameters = new TokenValidationParameters\n            {\n                ValidateIssuer = true,\n                ValidateAudience = true,\n                ValidateLifetime = true,\n                ClockSkew = TimeSpan.FromSeconds(Convert.ToInt32(Configuration.GetSection(\"JWT\")[\"ClockSkew\"])),\n                ValidateIssuerSigningKey = true,\n                ValidAudience = Configuration.GetSection(\"JWT\")[\"ValidAudience\"],\n                ValidIssuer = Configuration.GetSection(\"JWT\")[\"ValidIssuer\"],\n                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration.GetSection(\"JWT\")[\"IssuerSigningKey\"]))\n            };\n        });\n\nservices.AddAuthorization();\n```\n\n```csharp\napp.UseAuthentication();\napp.UseAuthorization();\n```\n\n这样一个简单的JWT配置就完成了，接下来新写一个接口去生成token。\n\n```csharp\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.IdentityModel.Tokens;\nusing System;\nusing System.IdentityModel.Tokens.Jwt;\nusing System.Security.Claims;\nusing System.Text;\n\nnamespace JsonWebTokenDemo.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class AuthController : ControllerBase\n    {\n        public AuthController(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        [HttpGet]\n        [Route(\"Token\")]\n        public string GenerateTokenAsync(string username, string password)\n        {\n            if (username == \"meowv\" && password == \"123\")\n            {\n                var claims = new[] {\n                    new Claim(ClaimTypes.Name, username),\n                    new Claim(ClaimTypes.Email, \"123@meowv.com\"),\n                    new Claim(JwtRegisteredClaimNames.Exp, $\"{new DateTimeOffset(DateTime.Now.AddMinutes(Convert.ToInt32(Configuration.GetSection(\"JWT\")[\"Expires\"]))).ToUnixTimeSeconds()}\"),\n                    new Claim(JwtRegisteredClaimNames.Nbf, $\"{new DateTimeOffset(DateTime.Now).ToUnixTimeSeconds()}\")\n                };\n\n                var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration.GetSection(\"JWT\")[\"IssuerSigningKey\"]));\n                var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n                var securityToken = new JwtSecurityToken(\n                    issuer: Configuration.GetSection(\"JWT\")[\"ValidIssuer\"],\n                    audience: Configuration.GetSection(\"JWT\")[\"ValidAudience\"],\n                    claims: claims,\n                    expires: DateTime.Now.AddMinutes(Convert.ToInt32(Configuration.GetSection(\"JWT\")[\"Expires\"])),\n                    signingCredentials: creds);\n\n                var token = new JwtSecurityTokenHandler().WriteToken(securityToken);\n\n                return token;\n            }\n            else\n            {\n                throw new Exception(\"账号密码错误\");\n            }\n        }\n    }\n}\n```\n\n模拟用户登录，成功登录则去生成token，在实际应用中还可以对接第三方登录系统进行认证，调用接口看下效果。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154534757-255403430.png)\n\n可以看到第一个接口输入正确的账号密码，成功返回了token，第二个接口会抛出一个异常。\n\n接下来去写两个接口，去验证一下token的使用是否正常，写一个需要授权的接口和一个不需要授权的接口。\n\n```csharp\n[HttpGet]\n[Authorize]\n[Route(\"AuthorizeTest\")]\npublic string AuthorizeTest()\n{\n    return \"我是返回结果\";\n}\n\n[HttpGet]\n[AllowAnonymous]\n[Route(\"AllowAnonymousTest\")]\npublic string AllowAnonymousTest()\n{\n    return \"我是返回结果\";\n}\n```\n\n这两个接口的唯一区别就是，`[Authorize]`、`[AllowAnonymous]`。\n\n添加了 `[Authorize]`特性的表明是需要进行授权才可以访问此接口，而添加了`[AllowAnonymous]`特性则表明不需要授权谁都可以访问，同样调用看一下效果。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154612020-1275379515.png)\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154617717-947359483.png)\n\n第一个接口没有返回出结果，可见生效了，此时调用的时候就需要带上我们前面生成的token成功授权后才能返回数据。\n\n有时候当我们没有成功授权，会直接返回一个401的错误页面，如果需要自定义返回信息需要怎么做呢？\n\n这个有好几种做法，可以用中间件，拦截器等等，不过这里推荐一种组件集成好的做法，直接上代码。\n\n```csharp\nservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n        .AddJwtBearer(options =>\n        {\n            ...\n\n            options.Events = new JwtBearerEvents\n            {\n                OnChallenge = async context =>\n                {\n                    context.HandleResponse();\n\n                    context.Response.ContentType = \"application/json;charset=utf-8\";\n                    context.Response.StatusCode = StatusCodes.Status401Unauthorized;\n\n                    await context.Response.WriteAsync(\"{\\\"message\\\":\\\"Unauthorized\\\",\\\"success\\\":false}\");\n                }\n            };\n        });\n```\n\n添加上面这段代码即可，`await context.Response.WriteAsync()`可以返回你自定义的错误消息，这里返回的是一个json字符串。\n\n另外还有一种场景，默认我们拿到token进行授权访问，是需要在请求头中添加`Authorization Bearer {token}`这种方式的，如果我不想在请求头中使用要怎么做呢？比如我想将token放在URL参数中，或者cookie中？\n\n同样也是可以的，而且实现方式也超级简单，看下面代码。\n\n```csharp\nservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n        .AddJwtBearer(options =>\n        {\n            ...\n\n            options.Events = new JwtBearerEvents\n            {\n                ...\n                OnMessageReceived = async context =>\n                {\n                    context.Token = context.Request.Query[\"token\"];\n\n                    await Task.CompletedTask;\n                }\n            };\n        });\n```\n\n这里演示了将token放在URL请求参数中，其它情况请根据实际开发场景进行修改即可。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154652088-92719170.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "jwt"
    ],
    "createdAt": "2020-09-07 09:26:07"
  },
  {
    "title": ".NET Core 下的爬虫利器",
    "author": "阿星Plus",
    "url": "2020-09-09-spider",
    "markdown": "爬虫大家或多或少的都应该接触过的，爬虫有风险，抓数需谨慎。\n\n本着研究学习的目的，记录一下在 .NET Core 下抓取数据的实际案例。爬虫代码一般具有时效性，当我们的目标发生改版升级，规则转换后我们写的爬虫代码就会失效，需要重新应对。抓取数据的主要思路就是去分析目标网站的页面逻辑，利用[`xpath`](https://www.cnblogs.com/meowv/p/11310538.html)、正则表达式等知识去解析网页拿到我们想要的数据。\n\n本篇主要简单介绍三个组件的使用，`HtmlAgilityPack`、`AngleSharp`、`PuppeteerSharp`，前两个可以处理传统的页面，无法抓取单页应用，如果需要抓取单页应用可以使用`PuppeteerSharp`。\n\n关于这三个组件库的实际应用可以参考一下[定时任务最佳实战](https://www.cnblogs.com/meowv/p/12971041.html)系列文章。\n\n新建一个控制台项目，抓取几个站点的数据来试试，先做准备工作，添加一个`IHotNews`的接口。\n\n```csharp\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace SpiderDemo\n{\n    public interface IHotNews\n    {\n        Task<IList<HotNews>> GetHotNewsAsync();\n    }\n}\n```\n\n`HotNews`模型，包含标题和链接\n\n```csharp\nnamespace SpiderDemo\n{\n    public class HotNews\n    {\n        public string Title { get; set; }\n\n        public string Url { get; set; }\n    }\n}\n```\n\n最终我们通过依赖注入的方式，将抓取到的数据展示到控制台中。\n\n## HtmlAgilityPack\n\n- [https://html-agility-pack.net/](https://html-agility-pack.net/)\n- [https://github.com/zzzprojects/html-agility-pack](https://github.com/zzzprojects/html-agility-pack)\n\n在项目中安装`HtmlAgilityPack`组件\n\n```PowerShell\nInstall-Package HtmlAgilityPack\n```\n\n这里以博客园为抓取目标，我们抓取首页的文章标题和链接。\n\n```csharp\nusing HtmlAgilityPack;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace SpiderDemo\n{\n    public class HotNewsHtmlAgilityPack : IHotNews\n    {\n        public async Task<IList<HotNews>> GetHotNewsAsync()\n        {\n            var list = new List<HotNews>();\n\n            var web = new HtmlWeb();\n\n            var htmlDocument = await web.LoadFromWebAsync(\"https://www.cnblogs.com/\");\n\n            var node = htmlDocument.DocumentNode.SelectNodes(\"//*[@id='post_list']/article/section/div/a\").ToList();\n\n            foreach (var item in node)\n            {\n                list.Add(new HotNews\n                {\n                    Title = item.InnerText,\n                    Url = item.GetAttributeValue(\"href\", \"\")\n                });\n            }\n\n            return list;\n        }\n    }\n}\n```\n\n添加`HotNewsHtmlAgilityPack.cs`实现`IHotNews`接口，访问博客园网址，拿到HTML数据后，使用xpath语法解析HTML，这里主要是拿到a标签即可。\n\n通过查看网页分析可以得到这个xpath：`//*[@id='post_list']/article/section/div/a`。\n\n然后在`Program.cs`中注入`IHotNews`，循环遍历看看效果。\n\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace SpiderDemo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            IServiceCollection service = new ServiceCollection();\n\n            service.AddSingleton<IHotNews, HotNewsHtmlAgilityPack>();\n\n            var provider = service.BuildServiceProvider().GetRequiredService<IHotNews>();\n\n            var list = await provider.GetHotNewsAsync();\n\n            if (list.Any())\n            {\n                Console.WriteLine($\"一共{list.Count}条数据\");\n\n                foreach (var item in list)\n                {\n                    Console.WriteLine($\"{item.Title}\\t{item.Url}\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"无数据\");\n            }\n        }\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904154959186-1429012873.png)\n\n## AngleSharp\n\n- [https://anglesharp.github.io/](https://anglesharp.github.io/)\n- [https://github.com/AngleSharp/AngleSharp](https://github.com/AngleSharp/AngleSharp)\n\n在项目中安装`AngleSharp`组件\n\n```PowerShell\nInstall-Package AngleSharp\n```\n\n同样的，新建一个`HotNewsAngleSharp.cs`也实现`IHotNews`接口，这次使用`AngleSharp`抓取。\n\n```csharp\nusing AngleSharp;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace SpiderDemo\n{\n    public class HotNewsAngleSharp : IHotNews\n    {\n        public async Task<IList<HotNews>> GetHotNewsAsync()\n        {\n            var list = new List<HotNews>();\n\n            var config = Configuration.Default.WithDefaultLoader();\n            var address = \"https://www.cnblogs.com\";\n            var context = BrowsingContext.New(config);\n            var document = await context.OpenAsync(address);\n\n            var cellSelector = \"article.post-item\";\n            var cells = document.QuerySelectorAll(cellSelector);\n\n            foreach (var item in cells)\n            {\n                var a = item.QuerySelector(\"section>div>a\");\n                list.Add(new HotNews\n                {\n                    Title = a.TextContent,\n                    Url = a.GetAttribute(\"href\")\n                });\n            }\n\n            return list;\n        }\n    }\n}\n```\n\n`AngleSharp`解析数据和`HtmlAgilityPack`的方式有所不同，`AngleSharp`可以利用css规则去获取数据，用起来也是挺方便的。\n\n在`Program.cs`中注入`IHotNews`，循环遍历看看效果。\n\n```csharp\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace SpiderDemo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            IServiceCollection service = new ServiceCollection();\n\n            service.AddSingleton<IHotNews, HotNewsAngleSharp>();\n\n            var provider = service.BuildServiceProvider().GetRequiredService<IHotNews>();\n\n            var list = await provider.GetHotNewsAsync();\n\n            if (list.Any())\n            {\n                Console.WriteLine($\"一共{list.Count}条数据\");\n\n                foreach (var item in list)\n                {\n                    Console.WriteLine($\"{item.Title}\\t{item.Url}\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"无数据\");\n            }\n        }\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155347481-1567291647.png)\n\n## PuppeteerSharp\n\n- [https://www.puppeteersharp.com/](https://www.puppeteersharp.com/)\n- [https://github.com/hardkoded/puppeteer-sharp](https://github.com/hardkoded/puppeteer-sharp)\n\n`PuppeteerSharp`是基于`Puppeteer`的，`Puppeteer` 是一个Google 开源的NodeJS 库，它提供了一个高级API 来通过DevTools协议控制Chromium 浏览器。Puppeteer 默认以无头(Headless) 模式运行，但是可以通过修改配置运行“有头”模式。\n\n`PuppeteerSharp`可以干很多事情，不光可以用来抓取单页应用，还可以用来生成页面PDF或者图片，可以做自动化测试等。\n\n在项目中安装`PuppeteerSharp`组件\n\n```PowerShell\nInstall-Package PuppeteerSharp\n```\n\n使用`PuppeteerSharp`第一次会帮我们在项目根目录中下载浏览器执行程序，这个取决于当前网速的快慢，建议手动下载后放在指定位置即可。\n\n```csharp\nusing PuppeteerSharp;\nusing System.Threading.Tasks;\n\nnamespace SpiderDemo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            // 下载浏览器执行程序\n            await new BrowserFetcher().DownloadAsync(BrowserFetcher.DefaultRevision);\n\n            // 创建一个浏览器执行实例\n            using var browser = await Puppeteer.LaunchAsync(new LaunchOptions\n            {\n                Headless = true,\n                Args = new string[] { \"--no-sandbox\" }\n            });\n\n            // 打开一个页面\n            using var page = await browser.NewPageAsync();\n\n            // 设置页面大小\n            await page.SetViewportAsync(new ViewPortOptions\n            {\n                Width = 1920,\n                Height = 1080\n            });\n        }\n    }\n}\n```\n\n上面这段代码是初始化`PuppeteerSharp`必要的代码，可以根据实际开发需要进行修改，下面以\"https://juejin.im\"为例，演示几个常用操作。\n\n### 获取单页应用HTML\n\n```csharp\n...\nvar url = \"https://juejin.im\";\nawait page.GoToAsync(url, WaitUntilNavigation.Networkidle0);\nvar content = await page.GetContentAsync();\nConsole.WriteLine(content);\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155414787-2069362700.png)\n\n可以看到页面上的HTML全部被获取到了，这时候就可以利用规则解析HTML，拿到我们想要的数据了。\n\n### 保存为图片\n\n```csharp\n...\nvar url = \"https://juejin.im/\";\nawait page.GoToAsync(url, WaitUntilNavigation.Networkidle0);\n\nawait page.ScreenshotAsync(\"juejin.png\");\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155425135-1501076288.png)\n\n### 保存为PDF\n\n```csharp\nvar url = \"https://juejin.im/\";\nawait page.GoToAsync(url, WaitUntilNavigation.Networkidle0);\n\nawait page.PdfAsync(\"juejin.pdf\");\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155434635-1013890068.png)\n\n`PuppeteerSharp`的功能还有很多，比如页面注入HTML、执行JS代码等，使用的时候可以参考官网示例。\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "爬虫",
      "Spider"
    ],
    "createdAt": "2020-09-09 09:00:09"
  },
  {
    "title": ".NET Core 下使用 Apollo 配置中心",
    "author": "阿星Plus",
    "url": "2020-09-11-apollo-in-dotnet",
    "markdown": "> Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。\n\n`Apollo`开源地址：[https://github.com/ctripcorp/apollo](https://github.com/ctripcorp/apollo)\n\n更多产品介绍可以查看[Apollo配置中心介绍](https://github.com/ctripcorp/apollo/wiki/Apollo配置中心介绍)，本篇主要介绍在 .NET 环境下如何使用 `Apollo` 配置中心。\n\n## Quick Start\n\n- 本地部署：[https://github.com/ctripcorp/apollo/wiki/Quick-Start](https://github.com/ctripcorp/apollo/wiki/Quick-Start)\n- Docker部署：[https://github.com/ctripcorp/apollo/wiki/Apollo-Quick-Start-Docker部署](https://github.com/ctripcorp/apollo/wiki/Apollo-Quick-Start-Docker%E9%83%A8%E7%BD%B2)\n- 分布式部署：[https://github.com/ctripcorp/apollo/wiki/分布式部署指南](https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97)\n\n为了方便，本次我选择使用Docker部署，快速运用。\n\n> 另外需要说明的是，不管是Docker方式部署Quick Start还是常规方式部署的，Quick Start只是用来快速入门、了解Apollo。如果部署Apollo在公司中使用，请参考分布式部署。\n\n请确保开发环境有docker环境，然后下载`docker-compose.yml`和所需的sql文件，然后在根目录执行`docker-compose up`，一次执行会触发下载镜像等操作，需要耐心等待一些时间。\n\n```yml\nversion: '2'\n\nservices:\n  apollo-quick-start:\n    image: nobodyiam/apollo-quick-start\n    container_name: apollo-quick-start\n    depends_on:\n      - apollo-db\n    ports:\n      - \"8080:8080\"\n      - \"8070:8070\"\n    links:\n      - apollo-db\n\n  apollo-db:\n    image: mysql:5.7\n    container_name: apollo-db\n    environment:\n      TZ: Asia/Shanghai\n      MYSQL_ALLOW_EMPTY_PASSWORD: 'yes'\n    depends_on:\n      - apollo-dbdata\n    ports:\n      - \"13306:3306\"\n    volumes:\n      - ./sql:/docker-entrypoint-initdb.d\n    volumes_from:\n      - apollo-dbdata\n\n  apollo-dbdata:\n    image: alpine:latest\n    container_name: apollo-dbdata\n    volumes:\n      - /var/lib/mysql\n```\n\n搜索所有`apollo-quick-start`开头的日志，看到以下日志说明启动成功：\n\n```bash\napollo-quick-start    | Waiting for config service startup.....\napollo-quick-start    | Config service started. You may visit http://localhost:8080 for service status now!\napollo-quick-start    | Waiting for admin service startup.\napollo-quick-start    | Admin service started\napollo-quick-start    | ==== starting portal ====\napollo-quick-start    | Portal logging file is ./portal/apollo-portal.log\napollo-quick-start    | Started [239]\napollo-quick-start    | Waiting for portal startup....\napollo-quick-start    | Portal started. You can visit http://localhost:8070 now!\n```\n\n> 数据库的端口映射为13306，所以如果希望在宿主机上访问数据库，可以通过localhost:13306，用户名是root，密码留空。如要查看更多服务的日志，可以通过docker exec -it apollo-quick-start bash登录， 然后到/apollo-quick-start/service和/apollo-quick-start/portal下查看日志信息。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155933529-251426993.png)\n\n访问[http://localhost:8070](http://localhost:8070)，可以看到`Apollo`UI界面，默认账号密码为：apollo/admin\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155945458-707465948.png)\n\n## .NET Core 接入\n\n新建一个 ASP.NET Core API项目，`ApolloDemo`，添加组件`Com.Ctrip.Framework.Apollo.Configuration`。\n\n```PowerShell\nInstall-Package Com.Ctrip.Framework.Apollo.Configuration\n```\n\n`Apollo`配置中心的 .NET 集成包开源地址：[https://github.com/ctripcorp/apollo.net/tree/dotnet-core](https://github.com/ctripcorp/apollo.net/tree/dotnet-core)\n\n接入也比较简单，在`appsettings.json`中配置`Apollo`服务地址。\n\n```json\n{\n  \"Apollo\": {\n    \"AppId\": \"ApolloDemo\",\n    \"Env\": \"DEV\",\n    \"MetaServer\": \"http://localhost:8080\",\n    \"ConfigServer\": [ \"http://localhost:8080\" ]\n  }\n}\n```\n\n关于配置可以查看文档：[https://github.com/ctripcorp/apollo.net/tree/dotnet-core/Apollo.Configuration](https://github.com/ctripcorp/apollo.net/tree/dotnet-core/Apollo.Configuration)\n\n为什么地址端口是8080而不是8070？\n\n因为在`docker-compose.yml`中我们暴露两个端口：8080个8070，8070是我们的`Apollo`配置中心管理界面，而8080端口是`Spring Eureka`服务注册中心。所以配置的应该是服务端的地址。\n\n紧接着在`Program.cs`应用配置，代码如下：\n\n```csharp {18-23}\nusing Com.Ctrip.Framework.Apollo;\nusing Com.Ctrip.Framework.Apollo.Logging;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace ApolloDemo\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((hostingContext, builder) =>\n                {\n                    LogManager.UseConsoleLogging(LogLevel.Trace);\n\n                    builder.AddApollo(builder.Build().GetSection(\"Apollo\")).AddDefault();\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```\n\n然后我们在`Apollo`管理界面新建一个与配置在`appsettings.json`中AppId同名的项目`ApolloDemo`。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904160008097-1371075850.png)\n\n`Apollo`有一个核心的概念：`Namespace`。\n\n- `Namespace`是配置项的集合，类似于一个配置文件的概念。\n- `Namespace`类型有三种：私有类型、公共类型、关联类型（继承类型）。\n- `Namespace`的获取权限分为两种：private （私有的）、public （公共的），这里的获取权限是相对于Apollo客户端来说的。\n\n配置文件有多种格式，例如：properties、xml、yml、yaml、json等。同样Namespace也具有这些格式。在Portal UI中可以看到“application”的Namespace上有一个“properties”标签，表明“application”是properties格式的。\n\n> 非properties格式的namespace，在客户端使用时需要调用ConfigService.getConfigFile(String namespace, ConfigFileFormat configFileFormat)来获取，如果使用Http接口直接调用时，对应的namespace参数需要传入namespace的名字加上后缀名，如datasources.json。\n> apollo-client 1.3.0版本开始对yaml/yml做了更好的支持，使用起来和properties格式一致：Config config = ConfigService.getConfig(\"application.yml\");，Spring的注入方式也和properties一致。\n\n关于Namespace`的文档：[https://github.com/ctripcorp/apollo/wiki/Apollo核心概念之“Namespace”](https://github.com/ctripcorp/apollo/wiki/Apollo%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B9%8B%E2%80%9CNamespace%E2%80%9D)\n\n接下来去新增几个配置属性，然后发布。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904160020498-1193370672.png)\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904160024359-1017695962.png)\n\n现在去写一个接口，来实时读取`Apollo`中的配置。\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\n\nnamespace ApolloDemo.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class ValuesController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"Apollo\")]\n        public IActionResult ApolloTest([FromServices] IConfiguration configuration, string key)\n        {\n            return Content(configuration.GetValue<string>(key));\n        }\n    }\n}\n```\n\n使用起来也非常简单，这里根据传入的key值不同，获取到我们配置在`Apollo`中的value，并且是具有热更新，实时动态改变的。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904160034816-862233072.png)\n\n然后修改name和age的值，在调用接口看看。注意在`Apollo`中修改后，需要发布才会生效。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904160041944-774373808.png)\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904160051491-1579758125.png)\n\n简单介绍了 .NET Core 下使用`Apollo`配置中心，`Apollo`的功能远不止于此，根据需要可以去Github查看官网Wiki介绍，有详细的使用说明文档。\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Apollo"
    ],
    "createdAt": "2020-09-11 09:46:11"
  },
  {
    "title": ".NET Core 下使用 gRPC",
    "author": "阿星Plus",
    "url": "2020-09-14-grpc-in-dotnet",
    "markdown": "gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。\n\n- [https://grpc.io/docs/guides/](https://grpc.io/docs/guides/)\n- [https://github.com/grpc/grpc-dotnet](https://github.com/grpc/grpc-dotnet)\n- [https://docs.microsoft.com/zh-cn/aspnet/core/grpc](https://docs.microsoft.com/zh-cn/aspnet/core/grpc)\n\ngRPC 的主要优点\n\n- 现代高性能轻量级 RPC 框架。\n- 协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。\n- 可用于多种语言的工具，以生成强类型服务器和客户端。\n- 支持客户端、服务器和双向流式处理调用。\n- 使用 Protobuf 二进制序列化减少对网络的使用。\n\n这些优点使 gRPC 适用于\n\n- 效率至关重要的轻量级微服务。\n- 需要多种语言用于开发的 Polyglot 系统。\n- 需要处理流式处理请求或响应的点对点实时服务。\n\ngRPC 现在可以非常简单的在 .NET Core 和 ASP.NET Core 中使用，并且已经开源，它目前由微软官方 ASP.NET 项目的人员进行维护，良好的接入 .NET Core 生态。\n\n接下来演示如何使用 gRPC，要想使用 gRPC 需要 .NET Core 3.1或者以上的SDK支持。gRPC分服务端和客户端，所以新建两个项目，一个控制台当作客户端`gRPC_ClientDemo`，一个ASP.NET Core 项目当作服务端`gRPC_ServerDemo`。\n\n先将服务端搞定，添加`Grpc.AspNetCore`组件\n\n```PowerShell\nInstall-Package Grpc.AspNetCore\n```\n\n然后`Startup.cs`中添加`services.AddGrpc()`。\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddGrpc();\n}\n```\n\n因为 gRPC 是基于 HTTP/2 来通信的，所以需要在配置文件中添加Kestrel 启用 HTTP/2 的配置。\n\n```json\n{\n  \"Kestrel\": {\n    \"EndpointDefaults\": {\n      \"Protocols\": \"Http2\"\n    }\n  }\n}\n```\n\ngRPC 与传统的api是不同的，需要我们自己定义`proto`文件，gRPC 使用协定优先方法进行 API 开发。 默认情况下，协议缓冲区 (protobuf) 用作接口设计语言 (IDL)。 *.proto 文件包含：\n\n- gRPC 服务的定义。\n- 在客户端与服务器之间发送的消息。\n\n有关 protobuf 文件的语法的详细信息，可以查看官方文档 ([protobuf](https://developers.google.com/protocol-buffers/docs/proto3))。\n\n`proto`文件在实际开发中肯定会有多个存在，这里有一个技巧就是将`proto`文件放在一个文件夹内，然后利用`Protobuf`的`Link`关联即可，这样就只用维护一份`proto`文件即可。\n\n同时微软还帮我们提供了`dotnet-grpc`，.NET Core 全局工具，请运行以下命令：\n\n```bash\ndotnet tool install -g dotnet-grpc\n```\n\n`dotnet-grpc` 可以用于将 `Protobuf` 引用作为 `<Protobuf />` 项添加到 .csproj 文件：\n\n```xml\n<Protobuf Include=\"Protos\\greet.proto\" GrpcServices=\"Server\" />\n```\n\n具体用法可以查看文档：[https://docs.microsoft.com/zh-cn/aspnet/core/grpc/dotnet-grpc](https://docs.microsoft.com/zh-cn/aspnet/core/grpc/dotnet-grpc)\n\n在解决访问文件夹根目录添加 Proto 文件夹，新建一个`hello.proto`proto文件，将其分别连接到两个项目中。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155752849-1924869983.png)\n\n现在来开始编写`hello.proto`，添加一个`SayHello`方法。\n\n```csharp\nsyntax = \"proto3\";\n\npackage hello; //定义包名\n\n// 定义服务\nservice HelloService {\n    // 定义一个 SayHello 方法\n    rpc SayHello (HelloRequest) returns (HelloReply);\n}\n\nmessage HelloRequest {\n    string name = 1;\n}\n\nmessage HelloReply {\n    string message = 1;\n}\n```\n\n然后来实现这个服务，在服务端添加一个`GreeterService.cs`。\n\n```csharp\nusing Grpc.Core;\nusing Hello;\nusing Microsoft.Extensions.Logging;\nusing System.Threading.Tasks;\n\nnamespace gRPC_ServerDemo.Services\n{\n    public class GreeterService : HelloService.HelloServiceBase\n    {\n        private readonly ILogger _logger;\n\n        public GreeterService(ILoggerFactory loggerFactory)\n        {\n            _logger = loggerFactory.CreateLogger<GreeterService>();\n        }\n\n        public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)\n        {\n            _logger.LogInformation($\"Sending hello to {request.Name}\");\n\n            return Task.FromResult(new HelloReply { Message = \"Hello \" + request.Name });\n        }\n    }\n}\n```\n\n`HelloService.HelloServiceBase`是`proto`文件为我们自动生成的类。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155809313-620441733.png)\n\n调用重载方法`SayHello()`，记录了一条日志然后返回客户端传进来的字段name。\n\n在配置文件中将`GreeterService`服务添加到路由管道中\n\n```csharp\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapGet(\"/\", async context =>\n    {\n        await context.Response.WriteAsync(\"Hello World!\");\n    });\n\n    endpoints.MapGrpcService<GreeterService>();\n});\n```\n\n支持我们服务端完成，启动服务端拿到启动地址，[https://localhost:5001](https://localhost:5001)。\n\n现在去客户端配置地址调用我们写的服务，在开始之前需要在客户端解决方案先引用下面几个nuget包。\n\n```PowerShell\nInstall-Package Grpc.Net.Client\nInstall-Package Google.Protobuf\nInstall-Package Grpc.Tools\n```\n\n```csharp\nusing Grpc.Net.Client;\nusing Hello;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace gRPC_ClientDemo\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            using var channel = GrpcChannel.ForAddress(\"https://localhost:5001\");\n\n            var client = new HelloService.HelloServiceClient(channel);\n\n            await UnaryCallExample(client);\n        }\n\n        private static async Task UnaryCallExample(HelloService.HelloServiceClient client)\n        {\n            var reply = await client.SayHelloAsync(new HelloRequest { Name = \"阿星Plus\" });\n\n            Console.WriteLine(\"Greeting: \" + reply.Message);\n        }\n    }\n}\n```\n\n启动服务端和客户端看看效果，成功发送消息和获取消息。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904155818951-1808954326.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "GRPC"
    ],
    "createdAt": "2020-09-14 08:59:14"
  },
  {
    "title": ".NET Core 下使用 ElasticSearch",
    "author": "阿星Plus",
    "url": "2020-09-16-elasticsearch-in-dotnet",
    "markdown": "## 快速入门\n\n### Elasticsearch 快速入门\n\n[ElasticSearch](https://www.elastic.co/cn/) 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库，无论是开源还是私有。\n\n但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene 非常 复杂。\n\n[ElasticSearch](https://www.elastic.co/cn/) 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。\n\n然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：\n\n- 一个分布式的实时文档存储，每个字段 可以被索引与搜索\n- 一个分布式实时分析搜索引擎\n- 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据\n\n官方客户端在Java、.NET、PHP、Python、Ruby、Nodejs和许多其他语言中都是可用的。根据 DB-Engines 的排名显示，ElasticSearch 是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。\n\n### ES 开发指南\n\n中文文档请参考：[《Elasticsearch: 权威指南》](https://www.elastic.co/guide/cn/elasticsearch/guide/cn/index.html \"《Elasticsearch: 权威指南》\")\n\n英文文档请参考：[《Elasticsearch Reference》](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html \"《Elasticsearch Reference》\")\n\n下载： [https://www.elastic.co/cn/downloads/](https://www.elastic.co/cn/downloads/)\n\n### ES API文档\n\n[API Conventions](https://www.elastic.co/guide/en/elasticsearch/reference/current/api-conventions.html \"API Conventions\")\n\n[Document APIs](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html \"Document APIs\")\n\n[Search APIs](https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html \"Search APIs\")\n\n[Indices APIs](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices.html \"Indices APIs\")\n\n[cat APIs](https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html \"cat APIs\")\n\n[Cluster APIs](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html \"Cluster APIs\")\n\n[Javascript api](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html \"Javascript api\")\n\n### Logstash\n\n[Logstash Reference](https://www.elastic.co/guide/en/logstash/current/index.html \"Logstash Reference\")\n\n[Configuring Logstash](https://www.elastic.co/guide/en/logstash/current/configuration.html \"Configuring Logstash\")\n\n[Input plugins](https://www.elastic.co/guide/en/logstash/current/input-plugins.html \"Input plugins\")\n\n[Output plugins](https://www.elastic.co/guide/en/logstash/current/output-plugins.html \"Output plugins\")\n\n[Filter plugins](https://www.elastic.co/guide/en/logstash/current/filter-plugins.html \"Filter plugins\")\n\n### Kibana DevTools 快捷键\n\n- Ctrl+i 自动缩进\n- Ctrl+Enter 提交\n- Down 打开自动补全菜单\n- Enter 或 Tab 选中项自动补全\n- Esc 关闭补全菜单\n\n`pretty = true`在任意的查询字符串中增加pretty参数，会让 Elasticsearch 美化输出(pretty-print)JSON响应以便更加容易阅读。\n\n### Kibana 命令\n\n```bash\n// 查询集群的磁盘状态\nGET _cat/allocation?v\n\n// 获取所有索引\nGET _cat/indices\n\n// 按索引数量排序\nGET _cat/indices?s=docs.count:desc\nGET _cat/indices?v&s=index\n\n// 集群有多少节点\nGET _cat/nodes\n\n// 集群的状态\nGET _cluster/health?pretty=true\nGET _cat/indices/*?v&s=index\n\n//获取指定索引的分片信息\nGET logs/_search_shards\n\n...\n```\n\n### 集群状态\n\n```json\ncurl -s -XGET 'http://<host>:9200/_cluster/health?pretty'\n\n//系统正常，返回的结果\n{\n  \"cluster_name\" : \"es-qwerty\",\n  \"status\" : \"green\",\n  \"timed_out\" : false,\n  \"number_of_nodes\" : 3,\n  \"number_of_data_nodes\" : 3,\n  \"active_primary_shards\" : 1,\n  \"active_shards\" : 2,\n  \"relocating_shards\" : 0,\n  \"initializing_shards\" : 0,\n  \"unassigned_shards\" : 0,\n  \"delayed_unassigned_shards\" : 0,\n  \"number_of_pending_tasks\" : 0,\n  \"number_of_in_flight_fetch\" : 0,\n  \"task_max_waiting_in_queue_millis\" : 0,\n  \"active_shards_percent_as_number\" : 100.0\n}\n```\n\n### 检索文档\n\n```json\nPOST logs/_search\n{\n  \"query\":{\n    \"range\":{\n      \"createdAt\":{\n        \"gt\":\"2020-04-25\",\n        \"lt\":\"2020-04-27\",\n        \"format\": \"yyyy-MM-dd\"\n      }\n    }\n  },\n  \"size\":0,\n  \"aggs\":{\n    \"url_type_stats\":{\n      \"terms\": {\n        \"field\": \"urlType.keyword\",\n        \"size\": 2\n      }\n    }\n  }\n}\n\nPOST logs/_search\n{\n  \"query\":{\n    \"range\":{\n      \"createdAt\":{\n        \"gte\":\"2020-04-26 00:00:00\",\n        \"lte\":\"now\",\n        \"format\": \"yyyy-MM-dd hh:mm:ss\"\n      }\n    }\n  },\n  \"size\":0,\n  \"aggs\":{\n    \"url_type_stats\":{\n      \"terms\": {\n        \"field\": \"urlType.keyword\",\n        \"size\": 2\n      }\n    }\n  }\n}\n\nPOST logs/_search\n{\n  \"query\":{\n    \"range\": {\n      \"createdAt\": {\n        \"gte\": \"2020-04-26 00:00:00\",\n        \"lte\": \"now\",\n         \"format\": \"yyyy-MM-dd hh:mm:ss\"\n      }\n    }\n  },\n  \"size\" : 0,\n  \"aggs\":{\n    \"total_clientIp\":{\n      \"cardinality\":{\n        \"field\": \"clientIp.keyword\"\n      }\n    },\n    \"total_userAgent\":{\n      \"cardinality\": {\n        \"field\": \"userAgent.keyword\"\n      }\n    }\n  }\n}\n\nPOST logs/_search\n{\n  \"size\" : 0,\n  \"aggs\":{\n    \"date_total_ClientIp\":{\n      \"date_histogram\":{\n        \"field\": \"createdAt\",\n        \"interval\": \"quarter\",\n        \"format\": \"yyyy-MM-dd\",\n        \"extended_bounds\":{\n          \"min\": \"2020-04-26 13:00:00\",\n          \"max\": \"2020-04-26 14:00:00\",\n        }\n      },\n      \"aggs\":{\n        \"url_type_api\": {\n          \"terms\": {\n            \"field\": \"urlType.keyword\",\n            \"size\": 10\n          }\n        }\n      }\n    }\n  }\n}\n\nPOST logs/_search\n{\n  \"size\" : 0,\n  \"aggs\":{\n    \"total_clientIp\":{\n      \"terms\":{\n        \"size\":30,\n        \"field\": \"clientIp.keyword\"\n      }\n    }\n  }\n}\n```\n\n### 删除文档\n\n```bash\n// 删除\nPOST logs/_delete_by_query {\"query\":{\"match_all\": {}}}\n\n// 删除索引\nDELETE logs\n```\n\n### 创建索引\n\n数据迁移本质是索引的重建，重建索引不会尝试设置目标索引，它不会复制源索引的设置。 所以在操作之前设置目标索引，包括设置映射，分片数，副本等。\n\n### 数据迁移\n\n#### Reindex from Remoteedit\n\n```json\n// Reindex支持从远程Elasticsearch集群重建索引：\nPOST _reindex\n{\n  \"source\": {\n    \"remote\": {\n      \"host\": \"http://lotherhost:9200\",\n      \"username\": \"user\",\n      \"password\": \"pass\"\n    },\n    \"index\": \"source\",\n    \"query\": {\n      \"match\": {\n        \"test\": \"data\"\n      }\n    }\n  },\n  \"dest\": {\n    \"index\": \"dest\"\n  }\n}\n\n// host参数必须包含scheme、host和port（例如https://lotherhost:9200）\n// username和password参数可选\n```\n\n使用时需要在elasticsearch.yml中配置 reindex.remote.whitelist 属性。可以设置多组（例如，lotherhost:9200, another:9200, 127.0.10.\\*:9200, localhost:\\*）。\n\n具体使用可参考 [Reindex from Remoteedit](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html#reindex-from-remote \"Reindex from Remoteedit\")\n\n#### Elasticsearch-Dump\n\nElasticsearch-Dump是一个elasticsearch数据导入导出开源工具包。安装、迁移相关执行可以在相同可用区的云主机上进行，使用方便。\n\n需要node环境，npm安装elasticdump\n\n```bash\nnpm install elasticdump -g\nelasticdump\n\n// Copy an index from production to staging with analyzer and mapping:\nelasticdump \\\n  --input=http://production.es.com:9200/my_index \\\n  --output=http://staging.es.com:9200/my_index \\\n  --type=analyzer\nelasticdump \\\n  --input=http://production.es.com:9200/my_index \\\n  --output=http://staging.es.com:9200/my_index \\\n  --type=mapping\nelasticdump \\\n  --input=http://production.es.com:9200/my_index \\\n  --output=http://staging.es.com:9200/my_index \\\n  --type=data\n\n// Copy a single shard data:\nelasticdump \\\n  --input=http://es.com:9200/api \\\n  --output=http://es.com:9200/api2 \\\n  --params='{\"preference\" : \"_shards:0\"}'\n```\n\nelasticdump 命令其他参数使用参考 [Elasticdump Options](https://github.com/taskrabbit/elasticsearch-dump#options \"Elasticdump Options\")\n\n### 深度分页\n\n- elasticsearch 超过10000条数据的分页查询会报异常，官方提供了 search_after 的方式来支持\n- search_after 要求提供上一页两个必须的排序标识\n\n```json\n//https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-request-search-after.html\nGET logs/_search\n{\n  \"from\":9990,\n  \"size\":10,\n  \"_source\": [\"url\",\"clientIp\",\"createdAt\"],\n  \"query\":{\n    \"match_all\": {}\n  },\n  \"sort\":[\n    {\n      \"createdAt\":{\n        \"order\":\"desc\"\n      }\n    },\n    {\n      \"_id\":{\n        \"order\":\"desc\"\n      }\n    }\n    ]\n}\n\nGET logs/_search\n{\n  \"from\":-1,\n  \"size\":10,\n  \"_source\": [\"url\",\"clientIp\",\"createdAt\"],\n  \"query\":{\n    \"match_all\": {}\n  },\n  \"search_after\": [1588042597000, \"V363vnEBz1D1HVfYBb0V\"],\n  \"sort\":[\n    {\n      \"createdAt\":{\n        \"order\":\"desc\"\n      }\n    },\n    {\n      \"_id\":{\n        \"order\":\"desc\"\n      }\n    }\n    ]\n}\n```\n\n## 安装\n\n- docker下安装Elasticsearch\n\n```bash\ndocker pull docker.elastic.co/elasticsearch/elasticsearch:7.8.1\ndocker run -p 9200:9200 --name elasticsearch -p 9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.8.1\n```\n\n```bash\ndocker pull docker.elastic.co/kibana/kibana:7.8.1\ndocker run -p 5601:5601 --name kibana --link 14e385b1e761:elasticsearch -e \"elasticsearch.hosts=http://127.0.0.1:9200\" -d docker.elastic.co/kibana/kibana:7.8.1\n```\n\n- [其它平台安装Elasticsearch](https://www.elastic.co/cn/downloads/ \"安装Elasticsearch\")\n\n## 接入使用\n\n新建一个webapi项目，然后安装两个组件。\n\n```PowerShell\nInstall-Package NEST\nInstall-Package Swashbuckle.AspNetCore\n```\n\n通过`NEST`来实现操作Elasticsearch，开源地址：[https://github.com/elastic/elasticsearch-net](https://github.com/elastic/elasticsearch-net)，同时将swagger也添加以下方便后面调用接口。\n\n接下来演示一个对Elasticsearch的增删改查操作。\n\n添加实体类：`VisitLog.cs`。\n\n```csharp\nusing System;\n\nnamespace ESDemo.Domain\n{\n    public class VisitLog\n    {\n        public string Id { get; set; }\n\n        /// <summary>\n        /// UserAgent\n        /// </summary>\n        public string UserAgent { get; set; }\n\n        /// <summary>\n        /// Method\n        /// </summary>\n        public string Method { get; set; }\n\n        /// <summary>\n        /// Url\n        /// </summary>\n        public string Url { get; set; }\n\n        /// <summary>\n        /// Referrer\n        /// </summary>\n        public string Referrer { get; set; }\n\n        /// <summary>\n        /// IpAddress\n        /// </summary>\n        public string IpAddress { get; set; }\n\n        /// <summary>\n        /// Milliseconds\n        /// </summary>\n        public int Milliseconds { get; set; }\n\n        /// <summary>\n        /// QueryString\n        /// </summary>\n        public string QueryString { get; set; }\n\n        /// <summary>\n        /// Request Body\n        /// </summary>\n        public string RequestBody { get; set; }\n\n        /// <summary>\n        /// Cookies\n        /// </summary>\n        public string Cookies { get; set; }\n\n        /// <summary>\n        /// Headers\n        /// </summary>\n        public string Headers { get; set; }\n\n        /// <summary>\n        /// StatusCode\n        /// </summary>\n        public int StatusCode { get; set; }\n\n        /// <summary>\n        /// Response Body\n        /// </summary>\n        public string ResponseBody { get; set; }\n\n        public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;\n    }\n}\n```\n\n确定好实体类后，来包装一下Elasticsearch，简单封装一个基类用于仓储的集成使用。\n\n添加一个接口类`IElasticsearchProvider`。\n\n```csharp\nusing Nest;\n\nnamespace ESDemo.Elasticsearch\n{\n    public interface IElasticsearchProvider\n    {\n        IElasticClient GetClient();\n    }\n}\n```\n\n在`ElasticsearchProvider`中实现`IElasticsearchProvider`接口。\n\n```csharp\nusing Nest;\nusing System;\n\nnamespace ESDemo.Elasticsearch\n{\n    public class ElasticsearchProvider : IElasticsearchProvider\n    {\n        public IElasticClient GetClient()\n        {\n            var connectionSettings = new ConnectionSettings(new Uri(\"http://localhost:9200\"));\n\n            return new ElasticClient(connectionSettings);\n        }\n    }\n}\n```\n\n添加Elasticsearch仓储基类，`ElasticsearchRepositoryBase`。\n\n```csharp\nusing Nest;\n\nnamespace ESDemo.Elasticsearch\n{\n    public abstract class ElasticsearchRepositoryBase\n    {\n        private readonly IElasticsearchProvider _elasticsearchProvider;\n\n        public ElasticsearchRepositoryBase(IElasticsearchProvider elasticsearchProvider)\n        {\n            _elasticsearchProvider = elasticsearchProvider;\n        }\n\n        protected IElasticClient Client => _elasticsearchProvider.GetClient();\n\n        protected abstract string IndexName { get; }\n    }\n}\n```\n\n也就是一个抽象类，当我们集成此基类的时候需要重写`protected abstract string IndexName { get; }`，指定IndexName。\n\n完成上面简单封装，现在新建一个`IVisitLogRepository`仓储接口，里面添加四个方法：\n\n```csharp\nusing ESDemo.Domain;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace ESDemo.Repositories\n{\n    public interface IVisitLogRepository\n    {\n        Task InsertAsync(VisitLog visitLog);\n\n        Task DeleteAsync(string id);\n\n        Task UpdateAsync(VisitLog visitLog);\n\n        Task<Tuple<int, IList<VisitLog>>> QueryAsync(int page, int limit);\n    }\n}\n```\n\n所以接下来不用说你也知道改干嘛，实现这个仓储接口，添加`VisitLogRepository`，代码如下：\n\n```csharp\nusing ESDemo.Domain;\nusing ESDemo.Elasticsearch;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace ESDemo.Repositories\n{\n    public class VisitLogRepository : ElasticsearchRepositoryBase, IVisitLogRepository\n    {\n        public VisitLogRepository(IElasticsearchProvider elasticsearchProvider) : base(elasticsearchProvider)\n        {\n        }\n\n        protected override string IndexName => \"visitlogs\";\n\n        public async Task InsertAsync(VisitLog visitLog)\n        {\n            await Client.IndexAsync(visitLog, x => x.Index(IndexName));\n        }\n\n        public async Task DeleteAsync(string id)\n        {\n            await Client.DeleteAsync<VisitLog>(id, x => x.Index(IndexName));\n        }\n\n        public async Task UpdateAsync(VisitLog visitLog)\n        {\n            await Client.UpdateAsync<VisitLog>(visitLog.Id, x => x.Index(IndexName).Doc(visitLog));\n        }\n\n        public async Task<Tuple<int, IList<VisitLog>>> QueryAsync(int page, int limit)\n        {\n            var query = await Client.SearchAsync<VisitLog>(x => x.Index(IndexName)\n                                    .From((page - 1) * limit)\n                                    .Size(limit)\n                                    .Sort(x => x.Descending(v => v.CreatedAt)));\n            return new Tuple<int, IList<VisitLog>>(Convert.ToInt32(query.Total), query.Documents.ToList());\n        }\n    }\n}\n```\n\n现在去写接口，添加一个`VisitLogController`API控制器，代码如下：\n\n```csharp\nusing ESDemo.Domain;\nusing ESDemo.Repositories;\nusing Microsoft.AspNetCore.Mvc;\nusing System.ComponentModel.DataAnnotations;\nusing System.Threading.Tasks;\n\nnamespace ESDemo.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class VisitLogController : ControllerBase\n    {\n        private readonly IVisitLogRepository _visitLogRepository;\n\n        public VisitLogController(IVisitLogRepository visitLogRepository)\n        {\n            _visitLogRepository = visitLogRepository;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> QueryAsync(int page = 1, int limit = 10)\n        {\n            var result = await _visitLogRepository.QueryAsync(page, limit);\n\n            return Ok(new\n            {\n                total = result.Item1,\n                items = result.Item2\n            });\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> InsertAsync([FromBody] VisitLog visitLog)\n        {\n            await _visitLogRepository.InsertAsync(visitLog);\n\n            return Ok(\"新增成功\");\n        }\n\n        [HttpDelete]\n        public async Task<IActionResult> DeleteAsync([Required] string id)\n        {\n            await _visitLogRepository.DeleteAsync(id);\n\n            return Ok(\"删除成功\");\n        }\n\n        [HttpPut]\n        public async Task<IActionResult> UpdateAsync([FromBody] VisitLog visitLog)\n        {\n            await _visitLogRepository.UpdateAsync(visitLog);\n\n            return Ok(\"修改成功\");\n        }\n    }\n}\n```\n\n大功告成，最后一步不要忘记在`Startup.cs`中添加服务，不然无法使用依赖注入。\n\n```csharp\n...\nservices.AddSingleton<IElasticsearchProvider, ElasticsearchProvider>();\nservices.AddSingleton<IVisitLogRepository, VisitLogRepository>();\n...\n```\n\n一切准备就绪，现在满怀期待的运行项目，打开swagger界面。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200909110506607-1992128291.png)\n\n按照新增、更新、删除、查询的顺序依次调用接口。新增可以多来几次，因为默认是没有数据的，多添加一点可以测试分页是否ok，这里就不再演示了。\n\n如果你有安装kibana，现在可以满怀惊喜的去查看一下刚才添加的数据。\n\n```bash\nGET _cat/indices\n\nGET visitlogs/_search\n{}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200909110514709-1458252237.png)\n\n可以看到，数据已经安安静静的躺在这里了。\n\n本篇简单介绍Elasticsearch在.NET Core中的使用，关于检索数据还有很多语法没有体现出来，如果在开发中需要用到，可以参考官方的各种数据查询示例：[https://github.com/elastic/elasticsearch-net/tree/master/examples](https://github.com/elastic/elasticsearch-net/tree/master/examples)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "ElasticSearch"
    ],
    "createdAt": "2020-09-16 08:50:16"
  },
  {
    "title": ".NET Core 下使用 RabbitMQ",
    "author": "阿星Plus",
    "url": "2020-09-16-rabbitmq-in-dotnet",
    "markdown": "## 介绍\n\nRabbitMQ是一个开源的,基于AMQP(Advanced Message Queuing Protocol)协议的完整,可复用的企业级消息队列(Message Queue 一种应用程序与应用程序之间的一种通信方法)系统,RabbitMQ可以实现点对点,发布订阅等消息处理模式\n\n- 官网：[https://www.rabbitmq.com/dotnet.html](https://www.rabbitmq.com/dotnet.html)\n- 开源地址：[https://github.com/rabbitmq/rabbitmq-dotnet-client](https://github.com/rabbitmq/rabbitmq-dotnet-client)\n\n## 安装\n\n- [docker下安装 RabbitMQ](https://docs.meowv.com/stack/docker/repo/rabbitmq.html)\n- [其他平台安装 RabbitMQ](https://www.rabbitmq.com/download.html)\n\n为了开发方便，我在docker中安装了RabbitMQ，RabbitMQ安装完成后，默认端口打开地址为：`http://localhost:15672`，输入默认账号密码，guest/guest，可以看到RabbitMQ UI界面。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904161123520-1579876319.png)\n\n## 快速开始\n\n接下来我们用RabbitMQ来完成一个比较常见的生产者和消费者模式的代码，新建两个控制台项目，`RabbitMQConsumer`和`RabbitMQProducer`。\n\n分别在两个项目中安装组件\n\n```PowerShell\nInstall-Package RabbitMQ.Client\n```\n\n在`RabbitMQProducer`生产者项目中，添加以下代码。\n\n```csharp\nusing RabbitMQ.Client;\nusing System;\nusing System.Text;\n\nnamespace RabbitMQProducer\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var factory = new ConnectionFactory()\n            {\n                HostName = \"localhost\",\n                Port = 5672,\n                UserName = \"guest\",\n                Password = \"guest\"\n            };\n\n            using var connection = factory.CreateConnection();\n            using var channel = connection.CreateModel();\n\n            var exchange = \"msg_test\";\n\n            channel.ExchangeDeclare(exchange, type: ExchangeType.Fanout);\n\n            for (int i = 0; i < 10000; i++)\n            {\n                var message = $\"hello，我是生产者【{i + 1}】号\";\n                var body = Encoding.UTF8.GetBytes(message);\n\n                channel.BasicPublish(exchange, routingKey: \"\", basicProperties: null, body: body);\n\n                Console.WriteLine($\"- 发送消息：{message}\");\n            }\n        }\n    }\n}\n```\n\n模拟发出10000次消息，接下来在`RabbitMQConsumer`消费者项目中接收消息，代码如下：\n\n```csharp\nusing RabbitMQ.Client;\nusing RabbitMQ.Client.Events;\nusing System;\nusing System.Text;\n\nnamespace RabbitMQConsumer\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var factory = new ConnectionFactory()\n            {\n                HostName = \"localhost\",\n                Port = 5672,\n                UserName = \"guest\",\n                Password = \"guest\"\n            };\n\n            using var connection = factory.CreateConnection();\n            using var channel = connection.CreateModel();\n\n            var exchange = \"msg_test\";\n\n            channel.ExchangeDeclare(exchange, type: ExchangeType.Fanout);\n\n            var queueName = channel.QueueDeclare().QueueName;\n            channel.QueueBind(queue: queueName, exchange, routingKey: \"\");\n\n            Console.WriteLine(\"开始监听消息...\");\n            while (true)\n            {\n                var consumer = new EventingBasicConsumer(channel);\n\n                consumer.Received += (model, ea) =>\n                {\n                    byte[] body = ea.Body.ToArray();\n                    var message = Encoding.UTF8.GetString(body);\n\n                    Console.WriteLine($\"- 接收到消息：{message}\");\n                };\n\n                channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer);\n            }\n        }\n    }\n}\n```\n\n同时启动两个看看效果。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904161139983-907092140.png)\n\n一闪而过，速度还是挺快的，更多操作可以查看官方教程：[https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "RabbitMQ"
    ],
    "createdAt": "2020-09-16 08:52:16"
  },
  {
    "title": ".NET Core 下使用 Kafka",
    "author": "阿星Plus",
    "url": "2020-09-18-kafka-in-dotnet",
    "markdown": "## 安装\n\n### CentOS 安装 kafka\n\n- Kafka : [http://kafka.apache.org/downloads](http://kafka.apache.org/downloads)\n- ZooLeeper : [https://zookeeper.apache.org/releases.html](https://zookeeper.apache.org/releases.html)\n\n#### 下载并解压\n\n```bash\n# 下载，并解压\n$ wget https://archive.apache.org/dist/kafka/2.1.1/kafka_2.12-2.1.1.tgz\n$ tar -zxvf  kafka_2.12-2.1.1.tgz\n$ mv kafka_2.12-2.1.1.tgz /data/kafka\n\n# 下载 zookeeper，解压\n$ wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.5.8/apache-zookeeper-3.5.8-bin.tar.gz\n$ tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz\n$ mv apache-zookeeper-3.5.8-bin /data/zookeeper\n```\n\n#### 启动 ZooKeeper\n\n```bash\n# 复制配置模版\n$ cd /data/kafka/conf\n$ cp zoo_sample.cfg zoo.cfg\n\n# 看看配置需不需要改\n$ vim zoo.cfg\n\n# 命令\n$ ./bin/zkServer.sh start    # 启动\n$ ./bin/zkServer.sh status   # 状态\n$ ./bin/zkServer.sh stop     # 停止\n$ ./bin/zkServer.sh restart  # 重启\n\n# 使用客户端测试\n$ ./bin/zkCli.sh -server localhost:2181\n$ quit\n```\n\n#### 启动 Kafka\n\n```bash\n# 备份配置\n$ cd /data/kafka\n$ cp config/server.properties config/server.properties_copy\n\n# 修改配置\n$ vim /data/kafka/config/server.properties\n\n# 集群配置下，每个 broker 的 id 是必须不同的\n# broker.id=0\n\n# 监听地址设置（内网）\n# listeners=PLAINTEXT://ip:9092\n\n# 对外提供服务的IP、端口\n# advertised.listeners=PLAINTEXT://106.75.84.97:9092\n\n# 修改每个topic的默认分区参数num.partitions，默认是1，具体合适的取值需要根据服务器配置进程确定，UCloud.ukafka = 3\n# num.partitions=3\n\n# zookeeper 配置\n# zookeeper.connect=localhost:2181\n\n# 通过配置启动 kafka\n$  ./bin/kafka-server-start.sh  config/server.properties&\n\n# 状态查看\n$ ps -ef|grep kafka\n$ jps\n```\n\n### docker下安装Kafka\n\n```bash\ndocker pull wurstmeister/zookeeper\ndocker run -d --name zookeeper -p 2181:2181 wurstmeister/zookeeper\n```\n\n```bash\ndocker pull wurstmeister/kafka\ndocker run -d --name kafka --publish 9092:9092 --link zookeeper --env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 --env KAFKA_ADVERTISED_HOST_NAME=192.168.1.111 --env KAFKA_ADVERTISED_PORT=9092 wurstmeister/kafka\n```\n\n## 介绍\n\n- Broker：消息中间件处理节点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。\n- Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发。\n- Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。\n- Segment：partition物理上由多个segment组成，下面2.2和2.3有详细说明。\n- offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904161605310-1875847528.png)\n\nkafka partition 和 consumer 数目关系\n\n- 如果consumer比partition多是浪费，因为kafka的设计是在一个partition上是不允许并发的，所以consumer数不要大于partition数 。\n- 如果consumer比partition少，一个consumer会对应于多个partitions，这里主要合理分配consumer数和partition数，否则会导致partition里面的数据被取的不均匀 。最好partiton数目是consumer数目的整数倍，所以partition数目很重要，比如取24，就很容易设定consumer数目 。\n- 如果consumer从多个partition读到数据，不保证数据间的顺序性，kafka只保证在一个partition上数据是有序的，但多个partition，根据你读的顺序会有不同\n- 增减consumer，broker，partition会导致rebalance，所以rebalance后consumer对应的partition会发生变化\n\n## 快速开始\n\n在 .NET Core 项目中安装组件\n\n```PowerShell\nInstall-Package Confluent.Kafka\n```\n\n开源地址：[https://github.com/confluentinc/confluent-kafka-dotnet](https://github.com/confluentinc/confluent-kafka-dotnet)\n\n添加`IKafkaService`服务接口\n\n```csharp\npublic interface IKafkaService\n{\n    /// <summary>\n    /// 发送消息至指定主题\n    /// </summary>\n    /// <typeparam name=\"TMessage\"></typeparam>\n    /// <param name=\"topicName\"></param>\n    /// <param name=\"message\"></param>\n    /// <returns></returns>\n    Task PublishAsync<TMessage>(string topicName, TMessage message) where TMessage : class;\n\n    /// <summary>\n    /// 从指定主题订阅消息\n    /// </summary>\n    /// <typeparam name=\"TMessage\"></typeparam>\n    /// <param name=\"topics\"></param>\n    /// <param name=\"messageFunc\"></param>\n    /// <param name=\"cancellationToken\"></param>\n    /// <returns></returns>\n    Task SubscribeAsync<TMessage>(IEnumerable<string> topics, Action<TMessage> messageFunc, CancellationToken cancellationToken) where TMessage : class;\n}\n```\n\n实现`IKafkaService`\n\n```csharp\npublic class KafkaService : IKafkaService\n{\n    public async Task PublishAsync<TMessage>(string topicName, TMessage message) where TMessage : class\n    {\n        var config = new ProducerConfig\n        {\n            BootstrapServers = \"127.0.0.1:9092\"\n        };\n        using var producer = new ProducerBuilder<string, string>(config).Build();\n        await producer.ProduceAsync(topicName, new Message<string, string>\n        {\n            Key = Guid.NewGuid().ToString(),\n            Value = message.SerializeToJson()\n        });\n    }\n\n    public async Task SubscribeAsync<TMessage>(IEnumerable<string> topics, Action<TMessage> messageFunc, CancellationToken cancellationToken) where TMessage : class\n    {\n        var config = new ConsumerConfig\n        {\n            BootstrapServers = \"127.0.0.1:9092\",\n            GroupId = \"crow-consumer\",\n            EnableAutoCommit = false,\n            StatisticsIntervalMs = 5000,\n            SessionTimeoutMs = 6000,\n            AutoOffsetReset = AutoOffsetReset.Earliest,\n            EnablePartitionEof = true\n        };\n        //const int commitPeriod = 5;\n        using var consumer = new ConsumerBuilder<Ignore, string>(config)\n                             .SetErrorHandler((_, e) =>\n                             {\n                                 Console.WriteLine($\"Error: {e.Reason}\");\n                             })\n                             .SetStatisticsHandler((_, json) =>\n                             {\n                                 Console.WriteLine($\" - {DateTime.Now:yyyy-MM-dd HH:mm:ss} > 消息监听中..\");\n                             })\n                             .SetPartitionsAssignedHandler((c, partitions) =>\n                             {\n                                 string partitionsStr = string.Join(\", \", partitions);\n                                 Console.WriteLine($\" - 分配的 kafka 分区: {partitionsStr}\");\n                             })\n                             .SetPartitionsRevokedHandler((c, partitions) =>\n                             {\n                                 string partitionsStr = string.Join(\", \", partitions);\n                                 Console.WriteLine($\" - 回收了 kafka 的分区: {partitionsStr}\");\n                             })\n                             .Build();\n        consumer.Subscribe(topics);\n        try\n        {\n            while (true)\n            {\n                try\n                {\n                    var consumeResult = consumer.Consume(cancellationToken);\n                    Console.WriteLine($\"Consumed message '{consumeResult.Message?.Value}' at: '{consumeResult?.TopicPartitionOffset}'.\");\n                    if (consumeResult.IsPartitionEOF)\n                    {\n                        Console.WriteLine($\" - {DateTime.Now:yyyy-MM-dd HH:mm:ss} 已经到底了：{consumeResult.Topic}, partition {consumeResult.Partition}, offset {consumeResult.Offset}.\");\n                        continue;\n                    }\n                    TMessage messageResult = null;\n                    try\n                    {\n                        messageResult = JsonConvert.DeserializeObject<TMessage>(consumeResult.Message.Value);\n                    }\n                    catch (Exception ex)\n                    {\n                        var errorMessage = $\" - {DateTime.Now:yyyy-MM-dd HH:mm:ss}【Exception 消息反序列化失败，Value：{consumeResult.Message.Value}】 ：{ex.StackTrace?.ToString()}\";\n                        Console.WriteLine(errorMessage);\n                        messageResult = null;\n                    }\n                    if (messageResult != null/* && consumeResult.Offset % commitPeriod == 0*/)\n                    {\n                        messageFunc(messageResult);\n                        try\n                        {\n                            consumer.Commit(consumeResult);\n                        }\n                        catch (KafkaException e)\n                        {\n                            Console.WriteLine(e.Message);\n                        }\n                    }\n                }\n                catch (ConsumeException e)\n                {\n                    Console.WriteLine($\"Consume error: {e.Error.Reason}\");\n                }\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            Console.WriteLine(\"Closing consumer.\");\n            consumer.Close();\n        }\n        await Task.CompletedTask;\n    }\n}\n```\n\n注入`IKafkaService`，在需要使用的地方直接调用即可。\n\n```csharp\npublic class MessageService : IMessageService, ITransientDependency\n{\n    private readonly IKafkaService _kafkaService;\n    public MessageService(IKafkaService kafkaService)\n    {\n        _kafkaService = kafkaService;\n    }\n\n    public async Task RequestTraceAdded(XxxEventData eventData)\n    {\n        await _kafkaService.PublishAsync(eventData.TopicName, eventData);\n    }\n}\n```\n\n以上相当于一个生产者，当我们消息队列发出后，还需一个消费者进行消费，所以可以使用一个控制台项目接收消息来处理业务。\n\n```csharp\nvar cts = new CancellationTokenSource();\nConsole.CancelKeyPress += (_, e) =>\n{\n    e.Cancel = true;\n    cts.Cancel();\n};\n\nawait kafkaService.SubscribeAsync<XxxEventData>(topics, async (eventData) =>\n{\n    // Your logic\n\n    Console.WriteLine($\" - {eventData.EventTime:yyyy-MM-dd HH:mm:ss} 【{eventData.TopicName}】- > 已处理\");\n}, cts.Token);\n```\n\n在`IKafkaService`中已经写了订阅消息的接口，这里也是注入后直接使用即可。\n\n## 生产者消费者示例\n\n### 生产者\n\n```csharp\nstatic async Task Main(string[] args)\n{\n    if (args.Length != 2)\n    {\n        Console.WriteLine(\"Usage: .. brokerList topicName\");\n        // 127.0.0.1:9092 helloTopic\n        return;\n    }\n\n    var brokerList = args.First();\n    var topicName = args.Last();\n\n    var config = new ProducerConfig { BootstrapServers = brokerList };\n\n    using var producer = new ProducerBuilder<string, string>(config).Build();\n\n    Console.WriteLine(\"\\n-----------------------------------------------------------------------\");\n    Console.WriteLine($\"Producer {producer.Name} producing on topic {topicName}.\");\n    Console.WriteLine(\"-----------------------------------------------------------------------\");\n    Console.WriteLine(\"To create a kafka message with UTF-8 encoded key and value:\");\n    Console.WriteLine(\"> key value<Enter>\");\n    Console.WriteLine(\"To create a kafka message with a null key and UTF-8 encoded value:\");\n    Console.WriteLine(\"> value<enter>\");\n    Console.WriteLine(\"Ctrl-C to quit.\\n\");\n\n    var cancelled = false;\n\n    Console.CancelKeyPress += (_, e) =>\n    {\n        e.Cancel = true;\n        cancelled = true;\n    };\n\n    while (!cancelled)\n    {\n        Console.Write(\"> \");\n\n        var text = string.Empty;\n\n        try\n        {\n            text = Console.ReadLine();\n        }\n        catch (IOException)\n        {\n            break;\n        }\n\n        if (string.IsNullOrWhiteSpace(text))\n        {\n            break;\n        }\n\n        var key = string.Empty;\n        var val = text;\n\n        var index = text.IndexOf(\" \");\n        if (index != -1)\n        {\n            key = text.Substring(0, index);\n            val = text.Substring(index + 1);\n        }\n\n        try\n        {\n            var deliveryResult = await producer.ProduceAsync(topicName, new Message<string, string>\n            {\n                Key = key,\n                Value = val\n            });\n\n            Console.WriteLine($\"delivered to: {deliveryResult.TopicPartitionOffset}\");\n        }\n        catch (ProduceException<string, string> e)\n        {\n            Console.WriteLine($\"failed to deliver message: {e.Message} [{e.Error.Code}]\");\n        }\n    }\n}\n```\n\n### 消费者\n\n```csharp\nstatic void Main(string[] args)\n{\n    if (args.Length != 2)\n    {\n        Console.WriteLine(\"Usage: .. brokerList topicName\");\n        // 127.0.0.1:9092 helloTopic\n        return;\n    }\n\n    var brokerList = args.First();\n    var topicName = args.Last();\n\n    Console.WriteLine($\"Started consumer, Ctrl-C to stop consuming\");\n\n    var cts = new CancellationTokenSource();\n    Console.CancelKeyPress += (_, e) =>\n    {\n        e.Cancel = true;\n        cts.Cancel();\n    };\n\n    var config = new ConsumerConfig\n    {\n        BootstrapServers = brokerList,\n        GroupId = \"consumer\",\n        EnableAutoCommit = false,\n        StatisticsIntervalMs = 5000,\n        SessionTimeoutMs = 6000,\n        AutoOffsetReset = AutoOffsetReset.Earliest,\n        EnablePartitionEof = true\n    };\n\n    const int commitPeriod = 5;\n\n    using var consumer = new ConsumerBuilder<Ignore, string>(config)\n                         .SetErrorHandler((_, e) =>\n                         {\n                             Console.WriteLine($\"Error: {e.Reason}\");\n                         })\n                         .SetStatisticsHandler((_, json) =>\n                         {\n                             Console.WriteLine($\" - {DateTime.Now:yyyy-MM-dd HH:mm:ss} > monitoring..\");\n                             //Console.WriteLine($\"Statistics: {json}\");\n                         })\n                         .SetPartitionsAssignedHandler((c, partitions) =>\n                         {\n                             Console.WriteLine($\"Assigned partitions: [{string.Join(\", \", partitions)}]\");\n                         })\n                         .SetPartitionsRevokedHandler((c, partitions) =>\n                         {\n                             Console.WriteLine($\"Revoking assignment: [{string.Join(\", \", partitions)}]\");\n                         })\n                         .Build();\n    consumer.Subscribe(topicName);\n\n    try\n    {\n        while (true)\n        {\n            try\n            {\n                var consumeResult = consumer.Consume(cts.Token);\n\n                if (consumeResult.IsPartitionEOF)\n                {\n                    Console.WriteLine($\"Reached end of topic {consumeResult.Topic}, partition {consumeResult.Partition}, offset {consumeResult.Offset}.\");\n\n                    continue;\n                }\n\n                Console.WriteLine($\"Received message at {consumeResult.TopicPartitionOffset}: {consumeResult.Message.Value}\");\n\n                if (consumeResult.Offset % commitPeriod == 0)\n                {\n                    try\n                    {\n                        consumer.Commit(consumeResult);\n                    }\n                    catch (KafkaException e)\n                    {\n                        Console.WriteLine($\"Commit error: {e.Error.Reason}\");\n                    }\n                }\n            }\n            catch (ConsumeException e)\n            {\n                Console.WriteLine($\"Consume error: {e.Error.Reason}\");\n            }\n        }\n    }\n    catch (OperationCanceledException)\n    {\n        Console.WriteLine(\"Closing consumer.\");\n        consumer.Close();\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904161622717-1214914585.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Kafka"
    ],
    "createdAt": "2020-09-18 08:45:18"
  },
  {
    "title": ".NET Core 下使用 Exceptionless 记录日志",
    "author": "阿星Plus",
    "url": "2020-09-21-exceptionless-in-dotnet",
    "markdown": "`ExceptionLess`是一套免费开源分布式系统日志收集框架，也是我无意中发现的，支持自己部署和平台托管的方式接入使用。\n\n- `ExceptionLess`官网：[https://exceptionless.com](https://exceptionless.com)\n- `ExceptionLess`开源地址：[https://github.com/exceptionless/Exceptionless](https://github.com/exceptionless/Exceptionless)\n- `ExceptionLess`.NET客户端开源地址：[https://github.com/exceptionless/Exceptionless.Net](https://github.com/exceptionless/Exceptionless.Net)\n\n## 安装\n\n如果是自己小项目，可以直接使用托管的方式接入`ExceptionLess`，但是如果是公司项目还是建议自己部署吧。\n\n```powershell\ndocker run --rm -it -p 5000:80 exceptionless/exceptionless:6.1.0\n```\n\n成功后，打开：[http://localhost:5000](http://localhost:5000)，可以看到`dashboard`界面，注册账号登录，创建一个项目。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152005423-459335741.png)\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152013740-736910732.png)\n\n可以看到选择不同的项目类型，配置方法也写的非常清楚，在 .NET Core 照着配置即可。\n\n更多安装方式参考：[https://github.com/exceptionless/Exceptionless/wiki/Self-Hosting](https://github.com/exceptionless/Exceptionless/wiki/Self-Hosting)\n\n## 使用\n\n安装 NuGet 程序包到项目中：\n\n```powershell\nInstall-Package Exceptionless.AspNetCore\n```\n\n在`dashboard`界面可以得到一个api密钥，和`dashboard`服务地址，可以放在配置文件中。\n\n```json\n{\n    \"Exceptionless\": {\n        \"ServerUrl\": \"http://localhost:5000\",\n        \"ApiKey\": \"pz2zGzIxbAWjHVU4FqR2UV7ATDfYxbpFZXGjQmCR\"\n    }\n}\n```\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    ...\n    app.UseExceptionless(Configuration);\n    ...\n}\n```\n\n`UseExceptionless`有多个重载方法，根据需要选择，这里将`IConfiguration`对象传进去，获取`Exceptionless`配置的服务地址和api密钥。\n\n然后在项目中随意写几个接口并访问，在`dashboard`界面就可以实时看到访问日志了，还是挺方便的。\n\n![](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152031750-861913901.png)\n\n现在您的项目可以自动将所有未处理异常发送到`Exceptionless`了，也可以通过 `ex.ToExceptionless().Submit()`向`Exceptionless`发送已处理的异常。\n\n更多使用方法请参考：[https://github.com/exceptionless/Exceptionless.Net/wiki](https://github.com/exceptionless/Exceptionless.Net/wiki)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Exceptionless"
    ],
    "createdAt": "2020-09-21 08:47:21"
  },
  {
    "title": ".NET Core 下使用 Serilog 记录日志",
    "author": "阿星Plus",
    "url": "2020-09-21-serilog-in-dotnet",
    "markdown": "## Serilog\n\n> Like many other libraries for .NET, Serilog provides diagnostic logging to files, the console, and elsewhere. It is easy to set up, has a clean API, and is portable between recent .NET platforms.\n> Unlike other logging libraries, Serilog is built with powerful structured event data in mind.\n\n## 最佳实践\n\n### 控制台项目\n\n在项目中添加下面几个组件包\n\n```powershell\nInstall-Package Serilog.Extensions.Logging\nInstall-Package Serilog.Sinks.Console\nInstall-Package Serilog.Sinks.File\n```\n\n```csharp\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        Log.Logger = new LoggerConfiguration()\n           .MinimumLevel.Information()\n           .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Warning)\n#if DEBUG\n            .MinimumLevel.Override(\"Xxx\", LogEventLevel.Debug)\n#else\n            .MinimumLevel.Override(\"Xxx\", LogEventLevel.Information)\n#endif\n           .Enrich.FromLogContext()\n           .WriteTo.File(Path.Combine(Directory.GetCurrentDirectory(), \"Logs/logs.txt\"))\n           .WriteTo.Console()\n           .CreateLogger();\n\n        await CreateHostBuilder(args).RunConsoleAsync();\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureLogging((context, logging) => logging.ClearProviders())\n            .ConfigureServices((hostContext, services) =>\n            {\n                services.AddHostedService<XxxHostedService>();\n            });\n}\n```\n\n```csharp\n//XxxHostedService.cs\npublic class XxxHostedService : IHostedService\n{\n    private readonly IHostApplicationLifetime _hostApplicationLifetime;\n\n    public XxxHostedService(IHostApplicationLifetime hostApplicationLifetime)\n    {\n        _hostApplicationLifetime = hostApplicationLifetime;\n    }\n\n    public async Task StartAsync(CancellationToken cancellationToken)\n    {\n        using var application = AbpApplicationFactory.Create<XxxModule>(options =>\n        {\n            options.UseAutofac();\n            options.Services.AddLogging(c => c.AddSerilog());\n        });\n        application.Initialize();\n\n        var service = await application.ServiceProvider.GetRequiredService<XxxService>();\n        service.XxxAsync();\n\n        application.Shutdown();\n\n        _hostApplicationLifetime.StopApplication();\n    }\n\n    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;\n}\n```\n\n### AspNetCore项目\n\n在项目中添加下面几个组件包\n\n```powershell\nInstall-Package Serilog.AspNetCore\nInstall-Package Serilog.Sinks.Async\nInstall-Package Serilog.Sinks.File\n```\n\n```csharp\npublic static async Task Main(string[] args)\n{\n    Log.Logger = new LoggerConfiguration()\n#if DEBUG\n        .MinimumLevel.Debug()\n#else\n        .MinimumLevel.Information()\n#endif\n        .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Information)\n        .Enrich.FromLogContext()\n        .WriteTo.Async(c => c.File($\"Logs/{DateTime.Now:yyyy/MMdd}/logs.txt\"))\n        .CreateLogger();\n\n        try\n        {\n            Log.Information(\"Starting Xxx.\");\n\n            await CreateHostBuilder(args).Build().RunAsync();\n        }\n        catch (Exception ex)\n        {\n            Log.Fatal(ex, \"Xxx terminated unexpectedly!\");\n        }\n        finally\n        {\n            Log.CloseAndFlush();\n        }\n    }\n\n    internal static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .ConfigureWebHostDefaults(webBuilder =>\n            {\n                webBuilder.UseIISIntegration()\n                          .UseStartup<Startup>();\n            }).UseAutofac().UseSerilog();\n}\n```\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Serilog"
    ],
    "createdAt": "2020-09-21 08:49:21"
  },
  {
    "title": ".NET Core 下使用 Log4Net 记录日志",
    "author": "阿星Plus",
    "url": "2020-09-24-log4net-in-dotnet",
    "markdown": "`Log4Net`相信大家都很熟悉了，算是比较主流和著名的日志组件了。\n\n- 官网：[http://logging.apache.org](http://logging.apache.org)\n- 开源地址：[https://github.com/apache/logging-log4net](https://github.com/apache/logging-log4net)\n\n## 最佳实践\n\n在项目中添加组件包\n\n```powershell\nInstall-Package log4net\n```\n\n添加`log4net.config`文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<configuration>\n  <configSections>\n    <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler, log4net\"/>\n  </configSections>\n  <log4net debug=\"false\">\n\n    <appender name=\"info\" type=\"log4net.Appender.RollingFileAppender,log4net\">\n      <param name=\"File\" value=\"log4net/info/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"MaxSizeRollBackups\" value=\"-1\"/>\n      <param name=\"MaximumFileSize\" value=\"5MB\"/>\n      <param name=\"RollingStyle\" value=\"Composite\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\\\\HH\".log\"\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n\n{\n    \"system\": \"Meowv.Blog\",\n    \"datetime\": \"%d\",\n    \"description\": \"%m\",\n  \"level\": \"%p\",\n    \"info\": \"%exception\"\n}\" />\n      </layout>\n      <filter type=\"log4net.Filter.LevelRangeFilter\">\n        <levelMin value=\"INFO\" />\n        <levelMax value=\"INFO\" />\n      </filter>\n    </appender>\n\n    <appender name=\"error\" type=\"log4net.Appender.RollingFileAppender,log4net\">\n      <param name=\"File\" value=\"log4net/error/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"MaxSizeRollBackups\" value=\"-1\"/>\n      <param name=\"MaximumFileSize\" value=\"5MB\"/>\n      <param name=\"RollingStyle\" value=\"Composite\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\\\\HH\".log\"\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n\n{\n    \"system\": \"Meowv.Blog\",\n    \"datetime\": \"%d\",\n    \"description\": \"%m\",\n  \"level\": \"%p\",\n    \"info\": \"%exception\"\n}\" />\n      </layout>\n      <filter type=\"log4net.Filter.LevelRangeFilter\">\n        <levelMin value=\"ERROR\" />\n        <levelMax value=\"ERROR\" />\n      </filter>\n    </appender>\n\n    <root>\n      <level value=\"ALL\"></level>\n      <appender-ref ref=\"info\"/>\n      <appender-ref ref=\"error\"/>\n    </root>\n\n  </log4net>\n\n</configuration>\n```\n\n### 控制台项目\n\n```csharp\nusing log4net;\nusing log4net.Config;\nusing System;\nusing System.IO;\nusing System.Reflection;\n\nnamespace ConsoleAppDemo\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var log4netRepository = LogManager.GetRepository(Assembly.GetEntryAssembly());\n            XmlConfigurator.Configure(log4netRepository, new FileInfo(\"log4net.config\"));\n\n            ILog log = LogManager.GetLogger(log4netRepository.Name, \"NETCorelog4net\");\n\n            log.Info(\"NETCorelog4net log\");\n            log.Info(\"test log\");\n            log.Error(\"error\");\n            log.Info(\"linezero\");\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904142743809-773586721.png)\n\n### AspNetCore项目\n\n新建一个静态类，写一个扩展方法`UseLog4Net()`，用于`log4net`初始化。\n\n```csharp\npublic static class Log4NetExtensions\n{\n    public static IHostBuilder UseLog4Net(this IHostBuilder hostBuilder)\n    {\n        var log4netRepository = LogManager.GetRepository(Assembly.GetEntryAssembly());\n        XmlConfigurator.Configure(log4netRepository, new FileInfo(\"log4net.config\"));\n\n        return hostBuilder;\n    }\n}\n```\n\n扩展方法返回`IHostBuilder`对象，这样可以链式调用，美化代码，然后在`Program.cs`中使用扩展方法`UseLog4Net()`。\n\n```csharp\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace WebAppDemo\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                }).UseLog4Net();\n    }\n}\n```\n\n配置完成，然后在任意地方写入日志即可。\n\n```csharp\nusing log4net;\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace WebAppDemo.Controllers\n{\n    [ApiController]\n    [Route(\"[controller]\")]\n    public class WeatherForecastController : ControllerBase\n    {\n        private static readonly string[] Summaries = new[]\n        {\n            \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\"\n        };\n\n        private readonly ILog _log;\n\n        public WeatherForecastController()\n        {\n            _log = LogManager.GetLogger(typeof(WeatherForecastController));\n        }\n\n        [HttpGet]\n        public IEnumerable<WeatherForecast> Get()\n        {\n            _log.Info(\"Hello, this is a Weather api!\");\n            _log.Warn(\"Wran !!!\");\n            _log.Error(\"Controller Error\");\n\n            var rng = new Random();\n            return Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = rng.Next(-20, 55),\n                Summary = Summaries[rng.Next(Summaries.Length)]\n            })\n            .ToArray();\n        }\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904142802319-1890498790.png)\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Log4Net"
    ],
    "createdAt": "2020-09-24 08:42:24"
  },
  {
    "title": ".NET Core 使用 Consul 服务注册发现",
    "author": "阿星Plus",
    "url": "2020-09-27-consul",
    "markdown": "`Consul`是一个用来实现分布式系统服务发现与配置的开源工具。它内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具，使用起来也较为简单。\n\n- `Consul`官网：[https://www.consul.io](https://www.consul.io)\n- 开源地址：[https://github.com/hashicorp/consul](https://github.com/hashicorp/consul)、[https://github.com/G-Research/consuldotnet](https://github.com/G-Research/consuldotnet)\n\n## 安装\n\n`Consul`支持各种平台的安装，安装文档：[https://www.consul.io/downloads](https://www.consul.io/downloads)，为了快速使用，我这里选择用[docker方式安装](https://docs.meowv.com/stack/docker/repo/consul.html)。\n\n```yaml\nversion: \"3\"\n\nservices:\n  service_1:\n    image: consul\n    command: agent -server -client=0.0.0.0 -bootstrap-expect=3 -node=service_1\n    volumes:\n      - /usr/local/docker/consul/data/service_1:/data\n  service_2:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=service_1 -node=service_2\n    volumes:\n      - /usr/local/docker/consul/data/service_2:/data\n    depends_on:\n      - service_1\n  service_3:\n    image: consul\n    command: agent -server -client=0.0.0.0 -retry-join=service_1 -node=service_3\n    volumes:\n      - /usr/local/docker/consul/data/service_3:/data\n    depends_on:\n      - service_1\n  client_1:\n    image: consul\n    command: agent -client=0.0.0.0 -retry-join=service_1 -ui -node=client_1\n    ports:\n      - 8500:8500\n    volumes:\n      - /usr/local/docker/consul/data/client_1:/data\n    depends_on:\n      - service_2\n      - service_3\n```\n\n提供一个`docker-compose.yaml`，使用`docker-compose up`编排脚本启动`Consul`，如果你不熟悉，可以选择其它方式能运行`Consul`即可。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152722056-927545654.png)\n\n这里使用 Docker 搭建 3个 server 节点 + 1 个 client 节点，API 服务通过 client 节点进行服务注册和发现。\n\n安装完成启动`Consul`，打开默认地址 [http://localhost:8500](http://localhost:8500) 可以看到`Consul`ui界面。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152742897-949048002.png)\n\n## 快速使用\n\n添加两个webapi服务，ServiceA和ServiceB，一个webapi客户端Client来调用服务。\n\n```bash\ndotnet new sln -n consul_demo\n\ndotnet new webapi -n ServiceA\ndotnet sln add ServiceA/ServiceA.csproj\n\ndotnet new webapi -n ServiceB\ndotnet sln add ServiceB/ServiceB.csproj\n\ndotnet new webapi -n Client\ndotnet sln add Client/Client.csproj\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152755607-758719340.png)\n\n在项目中添加`Consul`组件包\n\n```powershell\nInstall-Package Consul\n```\n\n### 服务注册\n\n接下来在两个服务中添加必要的代码来实现将服务注册到`Consul`中。\n\n首先将`Consul`配置信息添加到`appsettings.json`\n\n```json\n{\n    \"Consul\": {\n        \"Address\": \"http://host.docker.internal:8500\",\n        \"HealthCheck\": \"/healthcheck\",\n        \"Name\": \"ServiceA\",\n        \"Ip\": \"host.docker.internal\"\n    }\n}\n```\n\n因为我们要将项目都运行在docker中，所以这里的地址要用 host.docker.internal 代替，使用 localhost 无法正常启动，如果不在 docker 中运行，这里就配置层 localhost。\n\n添加一个扩展方法`UseConul(this IApplicationBuilder app, IConfiguration configuration, IHostApplicationLifetime lifetime)`。\n\n```csharp\nusing System;\nusing Consul;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace ServiceA\n{\n    public static class Extensions\n    {\n        public static IApplicationBuilder UseConul(this IApplicationBuilder app, IConfiguration configuration, IHostApplicationLifetime lifetime)\n        {\n            var client = new ConsulClient(options =>\n            {\n                options.Address = new Uri(configuration[\"Consul:Address\"]); // Consul客户端地址\n            });\n\n            var registration = new AgentServiceRegistration\n            {\n                ID = Guid.NewGuid().ToString(), // 唯一Id\n                Name = configuration[\"Consul:Name\"], // 服务名\n                Address = configuration[\"Consul:Ip\"], // 服务绑定IP\n                Port = Convert.ToInt32(configuration[\"Consul:Port\"]), // 服务绑定端口\n                Check = new AgentServiceCheck\n                {\n                    DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5), // 服务启动多久后注册\n                    Interval = TimeSpan.FromSeconds(10), // 健康检查时间间隔\n                    HTTP = $\"http://{configuration[\"Consul:Ip\"]}:{configuration[\"Consul:Port\"]}{configuration[\"Consul:HealthCheck\"]}\", // 健康检查地址\n                    Timeout = TimeSpan.FromSeconds(5) // 超时时间\n                }\n            };\n\n            // 注册服务\n            client.Agent.ServiceRegister(registration).Wait();\n\n            // 应用程序终止时，取消服务注册\n            lifetime.ApplicationStopping.Register(() =>\n            {\n                client.Agent.ServiceDeregister(registration.ID).Wait();\n            });\n\n            return app;\n        }\n    }\n}\n```\n\n然后在`Startup.cs`中使用扩展方法即可。\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env, IHostApplicationLifetime lifetime)\n{\n    ...\n    app.UseConul(Configuration, lifetime);\n}\n```\n\n注意，这里将`IConfiguration`和`IHostApplicationLifetime`作为参数传进来的，根据实际开发做对应的修改就可以了。\n\n分别在ServiceA和ServiceB都完成一遍上述操作，因为不是实际项目，这里就产生的许多重复代码，在真正的项目开发过程中可以考虑放在一个单独的项目中，ServiceA和ServiceB分别引用，调用。\n\n接着去实现健康检查接口。\n\n```csharp\n// ServiceA\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace ServiceA.Controllers\n{\n    [Route(\"[controller]\")]\n    [ApiController]\n    public class HealthCheckController : ControllerBase\n    {\n        /// <summary>\n        /// 健康检查\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet]\n        public IActionResult api()\n        {\n            return Ok();\n        }\n    }\n}\n```\n\n```csharp\n// ServiceB\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace ServiceB.Controllers\n{\n    [Route(\"[controller]\")]\n    [ApiController]\n    public class HealthCheckController : ControllerBase\n    {\n        /// <summary>\n        /// 健康检查\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet]\n        public IActionResult Get()\n        {\n            return Ok();\n        }\n    }\n}\n```\n\n最后在ServiceA和ServiceB中都添加一个接口。\n\n```csharp\n// ServiceA\nusing System;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\n\nnamespace ServiceA.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class ServiceAController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult Get([FromServices] IConfiguration configuration)\n        {\n            var result = new\n            {\n                msg = $\"我是{nameof(ServiceA)}，当前时间：{DateTime.Now:G}\",\n                ip = Request.HttpContext.Connection.LocalIpAddress.ToString(),\n                port = configuration[\"Consul:Port\"]\n            };\n\n            return Ok(result);\n        }\n    }\n}\n```\n\n```csharp\n// ServiceB\nusing System;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\n\nnamespace ServiceB.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class ServiceBController : ControllerBase\n    {\n        [HttpGet]\n        public IActionResult Get([FromServices] IConfiguration configuration)\n        {\n            var result = new\n            {\n                msg = $\"我是{nameof(ServiceB)}，当前时间：{DateTime.Now:G}\",\n                ip = Request.HttpContext.Connection.LocalIpAddress.ToString(),\n                port = configuration[\"Consul:Port\"]\n            };\n\n            return Ok(result);\n        }\n    }\n}\n```\n\n这样我们写了两个服务，ServiceA和ServiceB。都添加了健康检查接口和一个自己的服务接口，返回一段json。\n\n我们现在来运行看看效果，可以使用任何方式，只要能启动即可，我这里选择在docker中运行，直接在 Visual Studio中对着两个解决方案右键添加，选择Docker支持，默认会帮我们自动创建好Dockfile，非常方便。\n\n生成的Dockfile文件内容如下：\n\n```docker\n# ServiceA\nFROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base\nWORKDIR /app\nEXPOSE 80\nEXPOSE 443\n\nFROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build\nWORKDIR /src\nCOPY [\"ServiceA/ServiceA.csproj\", \"ServiceA/\"]\nRUN dotnet restore \"ServiceA/ServiceA.csproj\"\nCOPY . .\nWORKDIR \"/src/ServiceA\"\nRUN dotnet build \"ServiceA.csproj\" -c Release -o /app/build\n\nFROM build AS publish\nRUN dotnet publish \"ServiceA.csproj\" -c Release -o /app/publish\n\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\nENTRYPOINT [\"dotnet\", \"ServiceA.dll\"]\n```\n\n```docker\n# ServiceB\nFROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base\nWORKDIR /app\nEXPOSE 80\nEXPOSE 443\n\nFROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build\nWORKDIR /src\nCOPY [\"ServiceB/ServiceB.csproj\", \"ServiceB/\"]\nRUN dotnet restore \"ServiceB/ServiceB.csproj\"\nCOPY . .\nWORKDIR \"/src/ServiceB\"\nRUN dotnet build \"ServiceB.csproj\" -c Release -o /app/build\n\nFROM build AS publish\nRUN dotnet publish \"ServiceB.csproj\" -c Release -o /app/publish\n\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\nENTRYPOINT [\"dotnet\", \"ServiceB.dll\"]\n```\n\n然后定位到项目根目录，使用命令去编译两个镜像，service_a和service_b\n\n```bash\ndocker build -t service_a:dev -f ./ServiceA/Dockerfile .\n\ndocker build -t service_b:dev -f ./ServiceB/Dockerfile .\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152824547-2040250804.png)\n\n看到 Successfully 就成功了，通过`docker image ls`可以看到我们打包的两个镜像。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152845886-341809487.png)\n\n这里顺便提一句，已经可以看到我们编译的镜像，service_a和service_b了，但是还有许多名称为`<none>`的镜像，这些镜像可以不用管它，这种叫做虚悬镜像，既没有仓库名，也没有标签。是因为`docker build`导致的这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 `<none>` 的镜像。\n\n一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以`docker image prune`命令删除，这样镜像列表就干净多了。\n\n最后将两个镜像service_a和service_b，分别运行三个实例。\n\n```powershell\ndocker run -d -p 5050:80 --name service_a1 service_a:dev --Consul:Port=\"5050\"\ndocker run -d -p 5051:80 --name service_a2 service_a:dev --Consul:Port=\"5051\"\ndocker run -d -p 5052:80 --name service_a3 service_a:dev --Consul:Port=\"5052\"\n\ndocker run -d -p 5060:80 --name service_b1 service_b:dev --Consul:Port=\"5060\"\ndocker run -d -p 5061:80 --name service_b2 service_b:dev --Consul:Port=\"5061\"\ndocker run -d -p 5062:80 --name service_b3 service_b:dev --Consul:Port=\"5062\"\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152855788-1381581379.png)\n\n运行成功，接下来就是见证奇迹的时刻，去到`Consul`看看。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152908470-1574072711.png)\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152912275-124464728.png)\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904152957654-691179708.png)\n\n成功将两个服务注册到`Consul`，并且每个服务都有多个实例。\n\n访问一下接口试试吧，看看能不能成功出现结果。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904153026632-1273615038.png)\n\n因为终端编码问题，导致显示乱码，这个不影响，ok，至此服务注册大功告成。\n\n### 服务发现\n\n搞定了服务注册，接下来演示一下如何服务发现，在Client项目中先将`Consul`地址配置到`appsettings.json`中。\n\n```json\n{\n    \"Consul\": {\n        \"Address\": \"http://host.docker.internal:8500\"\n    }\n}\n```\n\n然后添加一个接口，`IService.cs`，添加三个方法，分别获取两个服务的返回结果以及初始化服务的方法。\n\n```csharp\nusing System.Threading.Tasks;\n\nnamespace Client\n{\n    public interface IService\n    {\n        /// <summary>\n        /// 获取 ServiceA 返回数据\n        /// </summary>\n        /// <returns></returns>\n        Task<string> GetServiceA();\n\n        /// <summary>\n        /// 获取 ServiceB 返回数据\n        /// </summary>\n        /// <returns></returns>\n        Task<string> GetServiceB();\n\n        /// <summary>\n        /// 初始化服务\n        /// </summary>\n        void InitServices();\n    }\n}\n```\n\n实现类：`Service.cs`\n\n```csharp\nusing System;\nusing System.Collections.Concurrent;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Consul;\nusing Microsoft.Extensions.Configuration;\n\nnamespace Client\n{\n    public class Service : IService\n    {\n        private readonly IConfiguration _configuration;\n        private readonly ConsulClient _consulClient;\n\n        private ConcurrentBag<string> _serviceAUrls;\n        private ConcurrentBag<string> _serviceBUrls;\n\n        private IHttpClientFactory _httpClient;\n\n        public Service(IConfiguration configuration, IHttpClientFactory httpClient)\n        {\n            _configuration = configuration;\n\n            _consulClient = new ConsulClient(options =>\n            {\n                options.Address = new Uri(_configuration[\"Consul:Address\"]);\n            });\n\n            _httpClient = httpClient;\n        }\n\n        public async Task<string> GetServiceA()\n        {\n            if (_serviceAUrls == null)\n                return await Task.FromResult(\"ServiceA正在初始化...\");\n\n            using var httpClient = _httpClient.CreateClient();\n\n            var serviceUrl = _serviceAUrls.ElementAt(new Random().Next(_serviceAUrls.Count()));\n\n            Console.WriteLine(\"ServiceA：\" + serviceUrl);\n\n            var result = await httpClient.GetStringAsync($\"{serviceUrl}/api/servicea\");\n\n            return result;\n        }\n\n        public async Task<string> GetServiceB()\n        {\n            if (_serviceBUrls == null)\n                return await Task.FromResult(\"ServiceB正在初始化...\");\n\n            using var httpClient = _httpClient.CreateClient();\n\n            var serviceUrl = _serviceBUrls.ElementAt(new Random().Next(_serviceBUrls.Count()));\n\n            Console.WriteLine(\"ServiceB：\" + serviceUrl);\n\n            var result = await httpClient.GetStringAsync($\"{serviceUrl}/api/serviceb\");\n\n            return result;\n        }\n\n        public void InitServices()\n        {\n            var serviceNames = new string[] { \"ServiceA\", \"ServiceB\" };\n\n            foreach (var item in serviceNames)\n            {\n                Task.Run(async () =>\n                {\n                    var queryOptions = new QueryOptions\n                    {\n                        WaitTime = TimeSpan.FromMinutes(5)\n                    };\n                    while (true)\n                    {\n                        await InitServicesAsync(queryOptions, item);\n                    }\n                });\n            }\n\n            async Task InitServicesAsync(QueryOptions queryOptions, string serviceName)\n            {\n                var result = await _consulClient.Health.Service(serviceName, null, true, queryOptions);\n\n                if (queryOptions.WaitIndex != result.LastIndex)\n                {\n                    queryOptions.WaitIndex = result.LastIndex;\n\n                    var services = result.Response.Select(x => $\"http://{x.Service.Address}:{x.Service.Port}\");\n\n                    if (serviceName == \"ServiceA\")\n                    {\n                        _serviceAUrls = new ConcurrentBag<string>(services);\n                    }\n                    else if (serviceName == \"ServiceB\")\n                    {\n                        _serviceBUrls = new ConcurrentBag<string>(services);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n代码就不解释了，相信都可以看懂，使用了`Random`类随机获取一个服务，关于这点可以选择更合适的负载均衡方式。\n\n在`Startup.cs`中添加接口依赖注入、使用初始化服务等代码。\n\n```csharp\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nnamespace Client\n{\n    public class Startup\n    {\n        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n\n        public IConfiguration Configuration { get; }\n\n        public void ConfigureServices(IServiceCollection services)\n        {\n\n            services.AddControllers();\n\n            services.AddHttpClient();\n\n            services.AddSingleton<IService, Service>();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IService service)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseHttpsRedirection();\n\n            app.UseRouting();\n\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapControllers();\n            });\n\n            service.InitServices();\n        }\n    }\n}\n```\n\n一切就绪，添加api访问我们的两个服务。\n\n```csharp\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace Client.Controllers\n{\n    [Route(\"api\")]\n    [ApiController]\n    public class HomeController : ControllerBase\n    {\n        [HttpGet]\n        [Route(\"service_result\")]\n        public async Task<IActionResult> GetService([FromServices] IService service)\n        {\n            return Ok(new\n            {\n                serviceA = await service.GetServiceA(),\n                serviceB = await service.GetServiceB()\n            });\n        }\n    }\n}\n```\n\n直接在Visual Studio中运行Client项目，在浏览器访问api。\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200904153041814-472019665.png)\n\n大功告成，服务注册与发现，现在就算之中的某个节点挂掉，服务也可以照常运行。\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "Consul"
    ],
    "createdAt": "2020-09-27 08:50:27"
  },
  {
    "title": ".NET Core 下的 API 网关",
    "author": "阿星Plus",
    "url": "2020-09-28-gateway",
    "markdown": "![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200923155620310-913141341.png)\n\n## 网关介绍\n\n网关其实就是将我们写好的API全部放在一个统一的地址暴露在公网，提供访问的一个入口。在 .NET Core下可以使用`Ocelot`来帮助我们很方便的接入API 网关。与之类似的库还有[`ProxyKit`](https://github.com/proxykit/ProxyKit)，微软也发布了一个反向代理的库[`YARP`](https://github.com/microsoft/reverse-proxy)。\n\n关于网关的介绍不多说了，网上文章也挺多的，这些都是不错的选择，听说后期`Ocelot`将会使用`YARP`来重写。本篇主要实践一下在.NET Core环境下使用`Ocelot`。\n\n- Ocelot官网：[https://threemammals.com/ocelot](https://threemammals.com/ocelot)\n- Ocelot文档：[https://ocelot.readthedocs.io](https://ocelot.readthedocs.io)\n- GitHub：[https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)\n- Ocelot资源汇总：[https://www.cnblogs.com/shanyou/p/10363360.html](https://www.cnblogs.com/shanyou/p/10363360.html)\n\n## 接入使用\n\n### 接口示例\n\n先创建几个项目用于测试，创建两个默认的API项目，Api_A和Api_B，在创建一个网关项目Api_Gateway，网关项目可以选择空的模板。\n\n现在分别在Api_A和Api_B中写几个api，将默认的`WeatherForecastController`中返回模型`WeatherForecast`添加一个字段Source，用于区分是哪个API返回的数据。\n\n```csharp\nusing System;\n\nnamespace Api_A\n{\n    public class WeatherForecast\n    {\n        public string Source { get; set; } = \"Api_A\";\n\n        public DateTime Date { get; set; }\n\n        public int TemperatureC { get; set; }\n\n        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);\n\n        public string Summary { get; set; }\n    }\n}\n\nusing System;\n\nnamespace Api_B\n{\n    public class WeatherForecast\n    {\n        public string Source { get; set; } = \"Api_B\";\n\n        public DateTime Date { get; set; }\n\n        public int TemperatureC { get; set; }\n\n        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);\n\n        public string Summary { get; set; }\n    }\n}\n```\n\n直接使用`WeatherForecastController`默认方法，在路由中添加api前缀。\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Api_A.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class WeatherForecastController : ControllerBase\n    {\n        private static readonly string[] Summaries = new[]\n        {\n            \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\"\n        };\n\n        [HttpGet]\n        public IEnumerable<WeatherForecast> Get()\n        {\n            var rng = new Random();\n            return Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = rng.Next(-20, 55),\n                Summary = Summaries[rng.Next(Summaries.Length)]\n            }).ToArray();\n        }\n    }\n}\n\nusing Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Api_B.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class WeatherForecastController : ControllerBase\n    {\n        private static readonly string[] Summaries = new[]\n        {\n            \"Freezing\", \"Bracing\", \"Chilly\", \"Cool\", \"Mild\", \"Warm\", \"Balmy\", \"Hot\", \"Sweltering\", \"Scorching\"\n        };\n\n        [HttpGet]\n        public IEnumerable<WeatherForecast> Get()\n        {\n            var rng = new Random();\n            return Enumerable.Range(1, 5).Select(index => new WeatherForecast\n            {\n                Date = DateTime.Now.AddDays(index),\n                TemperatureC = rng.Next(-20, 55),\n                Summary = Summaries[rng.Next(Summaries.Length)]\n            }).ToArray();\n        }\n    }\n}\n```\n\n再分别在Api_A和Api_B中添加两个控制器：ApiAController、ApiBController，然后加上几个简单的restful api。\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing System.Collections.Generic;\n\nnamespace Api_A.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class ApiAController : ControllerBase\n    {\n        [HttpGet]\n        public IEnumerable<string> Get()\n        {\n            return new string[] { \"value1\", \"value2\" };\n        }\n\n        [HttpGet(\"{id}\")]\n        public string Get(int id)\n        {\n            return $\"Get：{id}\";\n        }\n\n        [HttpPost]\n        public string Post([FromForm] string value)\n        {\n            return $\"Post:{value}\";\n        }\n\n        [HttpPut(\"{id}\")]\n        public string Put(int id, [FromForm] string value)\n        {\n            return $\"Put:{id}:{value}\";\n        }\n\n        [HttpDelete(\"{id}\")]\n        public string Delete(int id)\n        {\n            return $\"Delete:{id}\";\n        }\n    }\n}\n```\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing System.Collections.Generic;\n\nnamespace Api_B.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class ApiBController : ControllerBase\n    {\n        [HttpGet]\n        public IEnumerable<string> Get()\n        {\n            return new string[] { \"value1\", \"value2\" };\n        }\n\n        [HttpGet(\"{id}\")]\n        public string Get(int id)\n        {\n            return $\"Get：{id}\";\n        }\n\n        [HttpPost]\n        public string Post([FromForm] string value)\n        {\n            return $\"Post:{value}\";\n        }\n\n        [HttpPut(\"{id}\")]\n        public string Put(int id, [FromForm] string value)\n        {\n            return $\"Put:{id}:{value}\";\n        }\n\n        [HttpDelete(\"{id}\")]\n        public string Delete(int id)\n        {\n            return $\"Delete:{id}\";\n        }\n    }\n}\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200923155651456-948152726.png)\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200923155657562-25482906.png)\n\n方便查看接口，这里添加一下`swagger`组件，这样我们Api_A和Api_B项目分别就有了6个接口。\n\n接着打包docker镜像，放在docker中运行这两个api项目。这一步可以用任何你熟悉的方式，run起来即可。\n\n```bash\ndocker build -t api_a:dev -f ./Api_A/Dockerfile .\ndocker build -t api_b:dev -f ./Api_B/Dockerfile .\n```\n\nbuild成功后，指定两个端口运行api项目。\n\n```powershell\ndocker run -d -p 5050:80 --name api_a api_a:dev\ndocker run -d -p 5051:80 --name api_b api_b:dev\n```\n\nApi_A指定了5050端口，通过 [http://localhost:5050/swagger](http://localhost:5050/swagger)打开可以看到swagger文档界面，Api_B指定了5051端口，通过 [http://localhost:5051/swagger](http://localhost:5051/swagger)打开可以看到swagger文档界面，这样就大功告成了，接下来才是重点将两个api项目配置到Api_Gateway网关项目中。\n\n### 配置网关\n\n在网关项目Api_Gateway中都添加`Ocelot`组件包。\n\n```powershell\nInstall-Package Ocelot\n```\n\n`Ocelot`中最关键的就是配置路由信息，新建一个`ocelot.json`配置文件，将我们的两个API接口匹配规则放进去。\n\n```json\n{\n  \"Routes\": [\n    //ApiA\n    {\n      \"DownstreamPathTemplate\": \"/api/WeatherForecast\",\n      \"DownstreamScheme\": \"http\",\n      \"DownstreamHostAndPorts\": [\n        {\n          \"Host\": \"localhost\",\n          \"Port\": 5050\n        }\n      ],\n      \"UpstreamPathTemplate\": \"/ApiA/WeatherForecast\",\n      \"UpstreamHttpMethod\": [ \"Get\" ]\n    },\n    {\n      \"DownstreamPathTemplate\": \"/api/ApiA\",\n      \"DownstreamScheme\": \"http\",\n      \"DownstreamHostAndPorts\": [\n        {\n          \"Host\": \"localhost\",\n          \"Port\": 5050\n        }\n      ],\n      \"UpstreamPathTemplate\": \"/ApiA\",\n      \"UpstreamHttpMethod\": [ \"Get\", \"POST\" ]\n    },\n    {\n      \"DownstreamPathTemplate\": \"/api/ApiA/{id}\",\n      \"DownstreamScheme\": \"http\",\n      \"DownstreamHostAndPorts\": [\n        {\n          \"Host\": \"localhost\",\n          \"Port\": 5050\n        }\n      ],\n      \"UpstreamPathTemplate\": \"/ApiA/{id}\",\n      \"UpstreamHttpMethod\": [ \"Get\", \"Put\", \"Delete\" ]\n    },\n    //ApiB\n    {\n      \"DownstreamPathTemplate\": \"/api/WeatherForecast\",\n      \"DownstreamScheme\": \"http\",\n      \"DownstreamHostAndPorts\": [\n        {\n          \"Host\": \"localhost\",\n          \"Port\": 5051\n        }\n      ],\n      \"UpstreamPathTemplate\": \"/ApiB/WeatherForecast\",\n      \"UpstreamHttpMethod\": [ \"Get\" ]\n    },\n    {\n      \"DownstreamPathTemplate\": \"/api/ApiB\",\n      \"DownstreamScheme\": \"http\",\n      \"DownstreamHostAndPorts\": [\n        {\n          \"Host\": \"localhost\",\n          \"Port\": 5051\n        }\n      ],\n      \"UpstreamPathTemplate\": \"/ApiB\",\n      \"UpstreamHttpMethod\": [ \"Get\", \"POST\" ]\n    },\n    {\n      \"DownstreamPathTemplate\": \"/api/ApiB/{id}\",\n      \"DownstreamScheme\": \"http\",\n      \"DownstreamHostAndPorts\": [\n        {\n          \"Host\": \"localhost\",\n          \"Port\": 5051\n        }\n      ],\n      \"UpstreamPathTemplate\": \"/ApiB/{id}\",\n      \"UpstreamHttpMethod\": [ \"Get\", \"Put\", \"Delete\" ]\n    }\n  ],\n  \"GlobalConfiguration\": {\n    \"BaseUrl\": \"https://localhost:44335\"\n  }\n}\n```\n\n关于配置文件中的各项具体含义，可以参考官方文档中的介绍。主要就是将DownstreamPathTemplate模板内容转换为UpstreamPathTemplate模板内容进行接口的访问，同时可以指定HTTP请求的方式等等。GlobalConfiguration中的BaseUrl为我们暴漏出去的网关地址。\n\n设置好`ocelot.json`后，需要在代码中使用它，在`Program.cs`中添加配置文件。\n\n```csharp\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Hosting;\n\nnamespace Api_Gateway\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            CreateHostBuilder(args).Build().Run();\n        }\n\n        public static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureAppConfiguration((context, config) =>\n                {\n                    config.AddJsonFile(\"ocelot.json\", optional: false, reloadOnChange: true);\n                })\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n    }\n}\n```\n\n在`Startup.cs`中使用`Ocelot`。\n\n```csharp\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Ocelot.DependencyInjection;\nusing Ocelot.Middleware;\n\nnamespace Api_Gateway\n{\n    public class Startup\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddOcelot();\n        }\n\n        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n\n            app.UseEndpoints(endpoints =>\n            {\n                endpoints.MapGet(\"/\", async context =>\n                {\n                    await context.Response.WriteAsync(\"Hello World!\");\n                });\n            });\n\n            app.UseOcelot().Wait();\n        }\n    }\n}\n```\n\n完成以上操作后，我们试着去调用接口看看能否正确获取预期数据。\n\n```bash\ncurl -X GET \"https://localhost:44335/ApiA\"\ncurl -X GET \"https://localhost:44335/ApiB\"\n\ncurl -X POST \"https://localhost:44335/ApiA\" -H \"Content-Type: multipart/form-data\" -F \"value=ApiA\"\ncurl -X POST \"https://localhost:44335/ApiB\" -H \"Content-Type: multipart/form-data\" -F \"value=ApiB\"\n\ncurl -X GET \"https://localhost:44335/ApiA/12345\"\ncurl -X GET \"https://localhost:44335/ApiB/12345\"\n\ncurl -X PUT \"https://localhost:44335/ApiA/12345\" -H \"Content-Type: multipart/form-data\" -F \"value=ApiA\"\ncurl -X PUT \"https://localhost:44335/ApiB/12345\" -H \"Content-Type: multipart/form-data\" -F \"value=ApiB\"\n\ncurl -X DELETE \"https://localhost:44335/ApiA/12345\"\ncurl -X DELETE \"https://localhost:44335/ApiB/12345\"\n\ncurl -X GET \"https://localhost:44335/ApiA/WeatherForecast\"\ncurl -X GET \"https://localhost:44335/ApiB/WeatherForecast\"\n```\n\n![ ](https://api.meowv.com/api/meowv/tool/img?url=https://img2020.cnblogs.com/blog/891843/202009/891843-20200923155706965-118109408.png)\n\n可以看到，两个项目中的接口全部可以通过网关项目暴露的地址进行中转，是不是很方便？\n\n本篇只是简单的应用，对于`Ocelot`的功能远不止于此，它非常强大，还可以实现请求聚合、服务发现、认证、鉴权、限流熔断、并内置了负载均衡器，而且这些功能都是只需要简单的配置即可完成。就不一一描述了，如有实际开发需求和问题，可以查看官方文档和示例。\n\n",
    "category": ".NET",
    "tag": [
      ".NET Core",
      "ApiGateway"
    ],
    "createdAt": "2020-09-28 08:42:28"
  },
  {
    "title": "从读大学到工作，我的这几年时光是如何度过的",
    "author": "阿星Plus",
    "url": "2020-10-22-from-college-to-work",
    "markdown": "就从14年开始回忆吧，这一年我参加了高考，进入了大学校园。当年的学习成绩并不好，未能进入到理想大学，算是一个遗憾吧，不过这是自己的原因也赖不得任何人。从小对计算机感兴趣的我否决掉亲戚朋友父母的建议，毅然选择了软件开发专业，进一步学习软件开发知识。很庆幸自己的选择，让我今天可以凭借这一技能养活自己。\n\n进入大学后像是开了窍似的，当时我就有一个坚定的想法就是要改变自己。因为在上大学之前的我是比较沉默寡言的，所以在刚入学的时候我就参与竞选了班上的学习委员职务，结果也不负所望，凭借自己的计算机基础舌战群雄成功当选。然后还报名了学校计算机社团、和微博工作室社团，锻炼自己。\n\n在很长一段时间里，我保持着高效的学习，白天上专业课，晚上回寝室看各种视频教程，提前学习各种编程知识。就这样我的专业课程始终保持着班级、年级前列。由于学习成绩优异加上辅导员的看重，以压倒性的优势干掉其他班委，励志奖学金、入党积极分子都一并收入囊中。\n\n在班级上担任职位、参加社团活动，让自己不再沉默寡言，沟通协调能力不断增长，同时也结交了不错的小伙伴们。伴随着专业技能的不断增长，慢慢有了独立开发项目的能力，然后就有位老师给我介绍了一个外包项目，尚在学校的我成功赚到一小笔生活费。\n\n随着时间的推移，在学校的第一个暑假到来，单身的我迎来了春天。这个暑假我没有选择回家，没有选择和朋友们出去玩，我留在了学校。帮助学校进行招生工作，正是这个决定同时让我遇到了现在的女朋友，未来的老婆。选择留校的另一个原因就是，在招生办公室工作是有工资拿的，记得当时结了几千块钱。\n\n大学时光总是短暂的，由于对自己专业能力的认可和信心，我没有上完学校的专业课程，提前一年多就外出实习了，我应该是当时全年级第一个出去找工作的了。经辅导员和各任课老师的批准，就这样我的大学时光结束了，投简历、面试，过五关斩六将，很快就找到了一份实习工作。由于工作地点离学校比较远，在老师和同学们的帮助下，租了个小单间。这样就开始了朝九晚六的上班生涯，每天挤公交上下班，工资不高，但很有干劲，领导安排的任务，总是能超额完成，记得干了大概两个星期左右，经理找我谈话，给我加薪了。在这段紧凑的时间里，还成功拿到了驾驶证，从出来工作开始我就不在用父母的钱了，我终于可以自己养活自己了，并且还有些许能力去反馈他们给他们买些小礼物，现在想想还是很有成就感的。\n\n本着年轻就是资本，大城市机会多的想法，后来我辞掉了在武汉的工作，独自一人一个背包，一个行李箱来到了上海，投靠了在上海的亲戚一星期后，一个人搞定了租房，投简历，面试入职等一系列事情。此时的我没有毕业证，还是只能算实习生，不过工资倒是翻倍了，心情还是倍爽的。在这家公司呆了两年，期间拿了毕业证，成为学校的优秀毕业生，答辩时被老师邀请给学弟学妹们做了简单的心得分享，工作上成功转正加了薪，并且这一年同时还成为了一名正式党员。这两年时间做了很多项目，提升了好多技能。在这里要感谢我的上级领导，真心待我不错，给了我很多机会。但是由于某些原因，我还是离开了，现在任职一家互联网教育行业的公司也有一年多了。工作之余，做了几个开源项目，在微信公众号上发表了系列文章，收获了不少读者。\n\n今年一场疫情改变了所有的计划，年前我和我父母一起去了我女朋友家里，双方家长见面后打算过完年他们来我家玩玩，然而一切都泡汤了。由于老家是湖北的，疫情期间又出不了远门迟迟不能返工，就报名成为一名志愿者主动参加抗击疫情。就这样所有计划推迟到了十一假期，短暂的假期我们决定了婚期。没错，终于修成正果，我们要结婚了。时间定在12月份，已经向领导请好假期，下个月我就要回家准备婚礼了。缘分这东西说不清道不明，虽说磕磕绊绊，但也向着好的方向发展。我们一起经历了各种酸甜苦辣，并且双方家长见了面。感谢你，陪我一起度过这段美好时光；感谢你，愿意陪我一起经受磨难；感谢你，始终如一的不离不弃。你为我付出了好多，往后余生，我会加倍呵护。\n\n这几年时间说长不长，说短不短，经历了各种大小琐事，从青涩到懵懂，从懵懂到成熟。短暂的几年虽说不那么轰轰烈烈但也不平淡，有烦恼有忧愁有开心有快乐。这几年是我认认真真经历的，现在回首我可以自信的说，时间没有荒废掉而且收获颇多。感谢这几年我遇到的所有人，我相信后面的日子会越来越好。\n",
    "category": "Life",
    "tag": [
      "工作总结",
      "总结",
      "大学"
    ],
    "createdAt": "2020-10-22 11:04:22"
  },
  {
    "title": "2020年终总结",
    "author": "阿星Plus",
    "url": "2021-01-14-2020-summary",
    "markdown": "2020，始料未及，不知不觉中，2020年已经过去。\n\n一场疫情改变了我们所有的计划，这一年变化万千，五味杂陈。\n\n2020年，终究没能重启也不可能重启，在口罩的伴随下顺利结束。\n\n过年在家期间，主动担任战役志愿者抗击疫情。4月份才回到工作岗位上的我慢慢进入状态，工作之外，开始了开源项目的创作，完善了个人博客的升级改版，在微信公众号分享技术文章，与此同时也收获了不少点赞和关注，涨粉上千余人。\n\n2020年对所有人来说都是不容易的一年，疫情、口罩、网课、云办公、健康码、武汉、火神山、雷神山、方舱、推迟高考、暴雨、洪灾、嫦娥探月……这些关键词是这一年无法忘却的标志。\n\n虽说艰难，但也有美好，2020年我正式结束了单身生活，5年长跑修成正果，于11月11日和老婆一起将结婚证领了，并与12月2号(农历十月十八)这一天举办了婚礼。\n\n看似平淡的一年却也经历了大大小小这么多的事情。\n\n其实2020，无需重启。\n\n因为你经历的与记住的所有，终会成为你生命的一部分。\n\n当你收拾好自己重新上路，它们会给予你意想不到的力量。\n\n所以，去理解2020、拥抱2020吧！\n\n并且，用同样的热情与爱意，去相信那个等待与你相遇的2021年。\n\n相信2021年，我们的日子会更加美好！\n",
    "category": "Summary",
    "tag": [
      "年终总结",
      "总结",
      "2020"
    ],
    "createdAt": "2021-01-14 15:11:14"
  }
]